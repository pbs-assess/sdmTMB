[{"path":"https://sdmTMB.github.io/sdmTMB/articles/age-composition.html","id":"area-expansion","dir":"Articles","previous_headings":"","what":"Area expansion","title":"Area-weighted age composition standardization with sdmTMB","text":"Now let’s calculate area-weighted abundance indices age class. First, need set ‘grid’ data frame predict. make simple grid 0-1 simulated survey domain. Calculate indices age: Plot abundance indices age:","code":"# Create prediction grid on the same 0-1 spatial domain n_pred <- 10 pred_grid <- expand.grid(   x = seq(0, 1, length.out = n_pred),   y = seq(0, 1, length.out = n_pred) )  # Each grid cell area (since we're on 0-1 domain) cell_area <- (1 / n_pred)^2  # Replicate over years and ages nd <- replicate_df(pred_grid, \"year\", years) nd <- replicate_df(nd, \"age\", ages) nd$year_age <- paste(nd$year, nd$age, sep = \"_\")  # Use helper function to add model matrix columns nd_setup <- sdmTMB::make_category_svc(   data = nd,   category_column = \"age\",   time_column = \"year\",   share_spatial_sd = TRUE,   share_spatiotemporal_sd = TRUE ) ind_list <- lapply(ages, function(age) {   cat(\"Calculating index for age:\", age, \"\\n\")    # Subset prediction data for this age   nd_age <- nd_setup$data_expanded[nd_setup$data_expanded$age == age, ]    # Get predictions   pred <- predict(fit_sdmTMB, newdata = nd_age, return_tmb_object = TRUE)    # Calculate area-weighted index   ind <- get_index(pred, area = cell_area, bias_correct = TRUE)   data.frame(ind, age = age) })  ind <- do.call(rbind, ind_list) ggplot(ind, aes(year, est)) +   geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.3) +   geom_line() +   facet_wrap(~age, scales = \"free_y\") +   scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.05))) +   labs(     x = \"Year\",     y = \"Abundance index\",     title = \"Age-specific abundance indices\"   )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/age-composition.html","id":"convert-to-age-composition-proportions","dir":"Articles","previous_headings":"","what":"Convert to age composition (proportions)","title":"Area-weighted age composition standardization with sdmTMB","text":"Convert abundance indices proportions--age: Plot age composition:","code":"ind_props <- ind |>   group_by(year) |>   mutate(     total = sum(est),     proportion = est / total   ) |>   ungroup() ggplot(ind_props, aes(year, proportion, fill = factor(age, levels = rev(ages)))) +   geom_area(position = \"stack\", alpha = 0.7) +   labs(     x = \"Year\",     y = \"Proportion\",     fill = \"Age\",   ) ggplot(ind_props, aes(year, proportion, colour = age)) +   geom_line() +   geom_point() +   labs(     x = \"Year\",     y = \"Proportion\",     colour = \"Age\",   )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/age-composition.html","id":"calculate-effective-sample-sizes","dir":"Articles","previous_headings":"","what":"Calculate effective sample sizes","title":"Area-weighted age composition standardization with sdmTMB","text":"’ll calculate effective sample sizes age composition, following method VAST (Thorson 2019) described Thorson Haltuch (2018). Plot effective sample sizes:","code":"# Function to calculate effective sample sizes from index estimates # This may be folded into sdmTMB eventually get_comp_neff <- function(dat, index_df, time_column = \"year\", bin_column = \"age\") {   # Get unique years and ages in original order   years_unique <- unique(dat[[time_column]])   bins_unique <- unique(dat[[bin_column]])   nyrs <- length(years_unique)   nbins <- length(bins_unique)    # Reshape estimates and SEs to matrices (bins x years)   est_mat <- t(matrix(index_df$est, nrow = nyrs, ncol = nbins))   se_mat <- t(matrix(index_df$se_natural, nrow = nyrs, ncol = nbins))    # Calculate total abundance and SE by year   total_by_year <- colSums(est_mat)   total_se_by_year <- sqrt(colSums(se_mat^2))    # Calculate proportions   prop_mat <- est_mat / rep(total_by_year, each = nbins)    # Calculate proportion variance and effective sample sizes using delta method   var_prop_mat <- matrix(NA, nrow = nbins, ncol = nyrs)   neff_mat <- matrix(NA, nrow = nbins, ncol = nyrs)    for (i in 1:nbins) {     for (j in 1:nyrs) {       if (est_mat[i, j] > 0) {         var_prop_mat[i, j] <- est_mat[i, j]^2 / total_by_year[j]^2 *           (se_mat[i, j]^2 / est_mat[i, j]^2 -             2 * se_mat[i, j]^2 / (est_mat[i, j] * total_by_year[j]) +             total_se_by_year[j]^2 / total_by_year[j]^2)         neff_mat[i, j] <- prop_mat[i, j] * (1 - prop_mat[i, j]) / var_prop_mat[i, j]       } else {         var_prop_mat[i, j] <- 0         neff_mat[i, j] <- 0       }     }   }    # Calculate median Neff by year   neff_median <- apply(neff_mat, 2, median, na.rm = TRUE)    # Convert to data frame   bin_indices <- rep(1:nbins, nyrs)   year_indices <- rep(1:nyrs, each = nbins)   result <- data.frame(     prop_se = sqrt(as.vector(var_prop_mat)),     prop = as.vector(prop_mat),     neff = as.vector(neff_mat),     neff_median = rep(neff_median, each = nbins)   )    # Add year and bin columns   result[[time_column]] <- years_unique[year_indices]   result[[bin_column]] <- bins_unique[bin_indices]   result }  # Calculate effective sample sizes neff_results <- get_comp_neff(data, ind)  # Show results head(neff_results) #>      prop_se      prop      neff neff_median year   age #> 1 0.18427485 0.2419754  5.401600    8.519126 2018 age_1 #> 2 0.19090118 0.2575352  5.246810    8.519126 2018 age_2 #> 3 0.09922406 0.1119492 10.097755    8.519126 2018 age_3 #> 4 0.10186871 0.1156016  9.852132    8.519126 2018 age_4 #> 5 0.12500528 0.1462638  7.991050    8.519126 2018 age_5 #> 6 0.11057981 0.1266747  9.047203    8.519126 2018 age_6 ggplot(neff_results, aes(year, neff, colour = age)) +   geom_line() +   geom_point() +   labs(     x = \"Year\",     y = \"Effective sample size\",     colour = \"Age\",     title = \"Effective sample sizes by age\"   ) # Plot median effective sample size across ages neff_median <- neff_results |>   select(year, neff_median) |>   distinct()  ggplot(neff_median, aes(year, neff_median)) +   geom_line() +   geom_point() +   labs(     x = \"Year\",     y = \"Median effective sample size\",     title = \"Median effective sample size across ages\"   )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/age-composition.html","id":"troubleshooting-and-advanced-options","dir":"Articles","previous_headings":"","what":"Troubleshooting and advanced options","title":"Area-weighted age composition standardization with sdmTMB","text":"previous example assumed shared spatial spatiotemporal SDs across ages. However, several common scenarios might want modify behaviour handle challenging data structures.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/age-composition.html","id":"sdmtmb-vs--tinyvast-for-age-composition-models","dir":"Articles","previous_headings":"Troubleshooting and advanced options","what":"sdmTMB vs. tinyVAST for age composition models","title":"Area-weighted age composition standardization with sdmTMB","text":"want independent spatial/spatiotemporal fields across ages (shown examples ), can fit identical models either sdmTMB tinyVAST. choice doesn’t matter functionally. However, want correlation age-specific spatial fields, ’ll need use tinyVAST. published applications, including approach described Thorson Haltuch (2018), use independent fields across ages. Also, want different levels observation error age, ’ll need use tinyVAST. branch sdmTMB, hasn’t merged main yet.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/age-composition.html","id":"different-spatialspatiotemporal-sds-by-age","dir":"Articles","previous_headings":"Troubleshooting and advanced options","what":"Different spatial/spatiotemporal SDs by age","title":"Area-weighted age composition standardization with sdmTMB","text":"expect different magnitude spatial spatiotemporal variation age, can specify independent SDs age. harder estimate.","code":"# Set up model with independent spatial and spatiotemporal SDs for each age svc_setup_independent <- sdmTMB::make_category_svc(   data = data,   category_column = \"age\",   time_column = \"year\",   share_spatial_sd = FALSE,      # Each age has its own spatial SD   share_spatiotemporal_sd = FALSE # Each age has its own spatiotemporal SD )  # Now there's one factor level for each field print(svc_setup_independent$svc_map)  # Then fit the model as before with the new 'map'"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/age-composition.html","id":"selective-sharing-of-spatial-sds","dir":"Articles","previous_headings":"Troubleshooting and advanced options","what":"Selective sharing of spatial SDs","title":"Area-weighted age composition standardization with sdmTMB","text":"Sometimes may want ages share SDs others kept independent. can manually manipulate map creating helper function. share spatiotemporal SDs share spatial SDs. Look original map structure Look order fields column names. ageage1 ageage_6 spatial fields. rest spatiotemporal fields. Manually modify map share SDs ages. example, share spatial SDs ages 1-4, keep 5-6 independent:","code":"# Start with independent SDs using the helper function svc_setup_selective <- sdmTMB::make_category_svc(   data = data,   category_column = \"age\",   time_column = \"year\",   share_spatial_sd = FALSE,   share_spatiotemporal_sd = TRUE ) print(svc_setup_selective$svc_map) #> $ln_tau_Z #>  [1] 1 2 3 4 5 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 #> [39] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 #> Levels: 1 2 3 4 5 6 7 print(colnames(svc_setup_selective$data_expanded)) #>  [1] \"year\"                      \"x\"                         #>  [3] \"y\"                         \"abundance_per_area\"        #>  [5] \"age\"                       \"year_age\"                  #>  [7] \"ageage_1\"                  \"ageage_2\"                  #>  [9] \"ageage_3\"                  \"ageage_4\"                  #> [11] \"ageage_5\"                  \"ageage_6\"                  #> [13] \"factor(year)2018:ageage_1\" \"factor(year)2019:ageage_1\" #> [15] \"factor(year)2020:ageage_1\" \"factor(year)2021:ageage_1\" #> [17] \"factor(year)2022:ageage_1\" \"factor(year)2023:ageage_1\" #> [19] \"factor(year)2024:ageage_1\" \"factor(year)2025:ageage_1\" #> [21] \"factor(year)2018:ageage_2\" \"factor(year)2019:ageage_2\" #> [23] \"factor(year)2020:ageage_2\" \"factor(year)2021:ageage_2\" #> [25] \"factor(year)2022:ageage_2\" \"factor(year)2023:ageage_2\" #> [27] \"factor(year)2024:ageage_2\" \"factor(year)2025:ageage_2\" #> [29] \"factor(year)2018:ageage_3\" \"factor(year)2019:ageage_3\" #> [31] \"factor(year)2020:ageage_3\" \"factor(year)2021:ageage_3\" #> [33] \"factor(year)2022:ageage_3\" \"factor(year)2023:ageage_3\" #> [35] \"factor(year)2024:ageage_3\" \"factor(year)2025:ageage_3\" #> [37] \"factor(year)2018:ageage_4\" \"factor(year)2019:ageage_4\" #> [39] \"factor(year)2020:ageage_4\" \"factor(year)2021:ageage_4\" #> [41] \"factor(year)2022:ageage_4\" \"factor(year)2023:ageage_4\" #> [43] \"factor(year)2024:ageage_4\" \"factor(year)2025:ageage_4\" #> [45] \"factor(year)2018:ageage_5\" \"factor(year)2019:ageage_5\" #> [47] \"factor(year)2020:ageage_5\" \"factor(year)2021:ageage_5\" #> [49] \"factor(year)2022:ageage_5\" \"factor(year)2023:ageage_5\" #> [51] \"factor(year)2024:ageage_5\" \"factor(year)2025:ageage_5\" #> [53] \"factor(year)2018:ageage_6\" \"factor(year)2019:ageage_6\" #> [55] \"factor(year)2020:ageage_6\" \"factor(year)2021:ageage_6\" #> [57] \"factor(year)2022:ageage_6\" \"factor(year)2023:ageage_6\" #> [59] \"factor(year)2024:ageage_6\" \"factor(year)2025:ageage_6\" modified_map <- svc_setup_selective$svc_map  modified_map$ln_tau_Z[1:4] <- factor(1)  # get rid of empty factor levels: modified_map$ln_tau_Z <- droplevels(modified_map$ln_tau_Z)  print(modified_map$ln_tau_Z) #>  [1] 1 1 1 1 5 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 #> [39] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 #> Levels: 1 5 6 7  # Now use the modified map in the model"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/age-composition.html","id":"fixing-spatial-sds-to-zero-turning-off-spatial-variation","dir":"Articles","previous_headings":"Troubleshooting and advanced options","what":"Fixing spatial SDs to zero (turning off spatial variation)","title":"Area-weighted age composition standardization with sdmTMB","text":"ages spatial spatiotemporal SDs want collapse zero want turn spatial variation specific ages, can map corresponding ln_tau_Z elements factor(NA) set starting values large value. Among times, necessary empty categories (age-year combinations) separate spatiotemporal SDs age. can ignore warning sanity() sigma_Z less 0.01; ’ve set way purpose! check output summary() though make sure spatially varying SDs haven’t collapsed.","code":"# Set up independent SDs first using the helper function svc_setup_fixed <- sdmTMB::make_category_svc(   data = data,   category_column = \"age\",   time_column = \"year\",   share_spatial_sd = FALSE,   share_spatiotemporal_sd = TRUE )  # Create map and starting values to fix some SDs to effectively zero # Suppose we want to turn off spatial variation for ages 5 and 6 modified_map_fixed <- svc_setup_fixed$svc_map  print(modified_map_fixed) #> $ln_tau_Z #>  [1] 1 2 3 4 5 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 #> [39] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 #> Levels: 1 2 3 4 5 6 7  modified_map_fixed$ln_tau_Z[5:6] <- factor(NA) modified_map_fixed$ln_tau_Z <- droplevels(modified_map_fixed$ln_tau_Z)  print(modified_map_fixed) #> $ln_tau_Z #>  [1] 1    2    3    4    <NA> <NA> 7    7    7    7    7    7    7    7    7    #> [16] 7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    #> [31] 7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    #> [46] 7    7    7    7    7    7    7    7    7    #> Levels: 1 2 3 4 7  # Set starting ln_tau_Z values to large for fixed parameters to imply # a near zero marginal SD # sdmTMB is expecting a matrix here # for a 'delta' model, sdmTMB would be expecting a 2 column matrix # we can check this with: head(fit_sdmTMB$tmb_params$ln_tau_Z) #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]    0 #> [6,]    0  # all 0s as default: ln_tau_start <- matrix(0, ncol = 1, nrow = length(modified_map_fixed$ln_tau_Z))  # find the correct index: cn <- colnames(svc_setup$data_expanded) cn[7:60] #>  [1] \"ageage_1\"                  \"ageage_2\"                  #>  [3] \"ageage_3\"                  \"ageage_4\"                  #>  [5] \"ageage_5\"                  \"ageage_6\"                  #>  [7] \"factor(year)2018:ageage_1\" \"factor(year)2019:ageage_1\" #>  [9] \"factor(year)2020:ageage_1\" \"factor(year)2021:ageage_1\" #> [11] \"factor(year)2022:ageage_1\" \"factor(year)2023:ageage_1\" #> [13] \"factor(year)2024:ageage_1\" \"factor(year)2025:ageage_1\" #> [15] \"factor(year)2018:ageage_2\" \"factor(year)2019:ageage_2\" #> [17] \"factor(year)2020:ageage_2\" \"factor(year)2021:ageage_2\" #> [19] \"factor(year)2022:ageage_2\" \"factor(year)2023:ageage_2\" #> [21] \"factor(year)2024:ageage_2\" \"factor(year)2025:ageage_2\" #> [23] \"factor(year)2018:ageage_3\" \"factor(year)2019:ageage_3\" #> [25] \"factor(year)2020:ageage_3\" \"factor(year)2021:ageage_3\" #> [27] \"factor(year)2022:ageage_3\" \"factor(year)2023:ageage_3\" #> [29] \"factor(year)2024:ageage_3\" \"factor(year)2025:ageage_3\" #> [31] \"factor(year)2018:ageage_4\" \"factor(year)2019:ageage_4\" #> [33] \"factor(year)2020:ageage_4\" \"factor(year)2021:ageage_4\" #> [35] \"factor(year)2022:ageage_4\" \"factor(year)2023:ageage_4\" #> [37] \"factor(year)2024:ageage_4\" \"factor(year)2025:ageage_4\" #> [39] \"factor(year)2018:ageage_5\" \"factor(year)2019:ageage_5\" #> [41] \"factor(year)2020:ageage_5\" \"factor(year)2021:ageage_5\" #> [43] \"factor(year)2022:ageage_5\" \"factor(year)2023:ageage_5\" #> [45] \"factor(year)2024:ageage_5\" \"factor(year)2025:ageage_5\" #> [47] \"factor(year)2018:ageage_6\" \"factor(year)2019:ageage_6\" #> [49] \"factor(year)2020:ageage_6\" \"factor(year)2021:ageage_6\" #> [51] \"factor(year)2022:ageage_6\" \"factor(year)2023:ageage_6\" #> [53] \"factor(year)2024:ageage_6\" \"factor(year)2025:ageage_6\"  # large value means a very small marginal field SD for age 5 and 6 spatial fields here: ln_tau_start[5:6,1] <- 10  head(ln_tau_start) #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #> [5,]   10 #> [6,]   10 fit_fixed <- sdmTMB(   abundance_per_area ~ 0 + year_age,   mesh = mesh_sdm,   data = svc_setup_fixed$data_expanded,   family = tweedie(),   time = \"year\",   spatial = \"off\",   spatiotemporal = \"off\",   spatial_varying = svc_setup_fixed$svc_formula,   control = sdmTMBcontrol(     map = modified_map_fixed, #< new     start = list(ln_tau_Z = ln_tau_start) #< new   ) )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/age-composition.html","id":"references","dir":"Articles","previous_headings":"Troubleshooting and advanced options","what":"References","title":"Area-weighted age composition standardization with sdmTMB","text":"Thorson, J.T., Haltuch, M.. 2018. Spatio-temporal analysis compositional data: increased precision improved workflow using model-based inputs stock assessment. Can. J. Fish. Aquat. Sci. doi:10.1139/cjfas-2018-0015. Thorson, J.T. 2019. Guidance decisions using Vector Autoregressive Spatio-Temporal (VAST) package stock, ecosystem, habitat climate assessments. Fisheries Research 210: 143–161. doi:10.1016/j.fishres.2018.10.013.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/basic-intro.html","id":"parameter-estimates","dir":"Articles","previous_headings":"","what":"Parameter estimates","title":"Introduction to modelling with sdmTMB","text":"can view confidence intervals fixed effects using tidy function. interpretation, think 1-unit increase standardized covariate 1 SD original units; exponentiate log-linked effects get multiplicative changes biomass density: similarly random effect variance parameters: parameters defined follows: range: derived parameter defines distance 2 points effectively independent (actually 13% correlated). share_range argument changed FALSE spatial spatiotemporal ranges unique, otherwise default share range. phi: Observation error scale parameter (e.g., SD Gaussian). sigma_O: SD spatial process (“Omega”). sigma_E: SD spatiotemporal process (“Epsilon”). tweedie_p: Tweedie p (power) parameter; 1 2. model used AR1 spatiotemporal fields : rho: Spatiotemporal correlation years; -1 1.","code":"tidy(m3, conf.int = TRUE) #> # A tibble: 3 × 5 #>   term                 estimate std.error conf.low conf.high #>   <chr>                   <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)              1.86     0.208     1.45      2.26 #> 2 poly(log(depth), 2)1   -65.1      6.32    -77.5     -52.8  #> 3 poly(log(depth), 2)2   -96.5      5.98   -108.      -84.8 tidy(m3, \"ran_pars\", conf.int = TRUE) #> # A tibble: 5 × 5 #>   term      estimate std.error conf.low conf.high #>   <chr>        <dbl>     <dbl>    <dbl>     <dbl> #> 1 range        19.8     3.03      14.6      26.7  #> 2 phi          11.0     0.377     10.3      11.8  #> 3 sigma_O       1.40    0.162      1.12      1.76 #> 4 sigma_E       1.55    0.129      1.32      1.83 #> 5 tweedie_p     1.50    0.0119     1.48      1.52"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/basic-intro.html","id":"model-diagnostics","dir":"Articles","previous_headings":"","what":"Model diagnostics","title":"Introduction to modelling with sdmTMB","text":"can inspect randomized quantile residuals:   Look straight QQ lines large spatial patches residuals; strong spatial patterns suggest missing covariates -coarse mesh. can also use simulation-based randomized quantile residuals.  See ?residuals.sdmTMB() residuals vignette.","code":"pcod$resids <- residuals(m3, type = \"mle-mvn\") # randomized quantile residuals qqnorm(pcod$resids) abline(0, 1) ggplot(pcod, aes(X, Y, col = resids)) +   scale_colour_gradient2() +   geom_point() +   facet_wrap(~year) +   coord_fixed() set.seed(19283) s <- simulate(m3, nsim = 300, type = \"mle-mvn\") dharma_residuals(s, m3)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/basic-intro.html","id":"spatial-predictions","dir":"Articles","previous_headings":"","what":"Spatial predictions","title":"Introduction to modelling with sdmTMB","text":"Now, purposes example (e.g., visualization), want predict fine-scale grid entire survey domain. grid built package Queen Charlotte Sound named qcs_grid. See discussion thread ’re looking suggestions form grid. prediction grid also needs covariates used model . replicate grid across years spatiotemporal fields can projected every time slice. can replicate grid across necessary years: Now make predictions new data: Let’s make small function help make maps. {{ }} syntax just “tidy-eval helper” lets us supply unquoted column name pass ggplot. four kinds predictions get model. Use cases: - est: fixed + spatial + spatiotemporal; use maps indices. - est_non_rf: fixed effects ; use understand covariate-driven signal. - omega_s: spatial random effects; use see persistent spatial deviations. - epsilon_st: spatiotemporal random effects; use see year-specific anomalies. First, show predictions incorporate fixed effects random effects:  can also look just fixed effects, quadratic effect depth:  can look spatial random effects represent consistent deviations space time accounted fixed effects. words, deviations represent consistent spatially structured biotic abiotic factors affecting biomass density accounted model.  finally can look spatiotemporal random effects represent deviation fixed effect predictions spatial random effect deviations. represent spatially structured biotic abiotic factors changing time accounted model.  can also estimate uncertainty spatiotemporal density predictions using simulations joint precision matrix setting nsim > 0 predict function. generate 100 estimates use apply() calculate upper lower confidence intervals, standard deviation, coefficient variation (CV). Plot CV estimates:","code":"glimpse(qcs_grid) #> Rows: 7,314 #> Columns: 5 #> $ X             <dbl> 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 4… #> $ Y             <dbl> 5636, 5636, 5636, 5636, 5636, 5636, 5636, 5636, 5636, 56… #> $ depth         <dbl> 347.08345, 223.33479, 203.74085, 183.29868, 182.99983, 1… #> $ depth_scaled  <dbl> 1.56081222, 0.56976988, 0.36336929, 0.12570465, 0.122036… #> $ depth_scaled2 <dbl> 2.436134794, 0.324637712, 0.132037240, 0.015801659, 0.01… grid_yrs <- replicate_df(qcs_grid, \"year\", unique(pcod$year)) predictions <- predict(m3, newdata = grid_yrs) plot_map <- function(dat, column) {   ggplot(dat, aes(X, Y, fill = {{ column }})) +     geom_raster() +     coord_fixed() } plot_map(predictions, exp(est)) +   scale_fill_viridis_c(     trans = \"sqrt\",     # trim extreme high values to make spatial variation more visible:     na.value = \"yellow\", limits = c(0, quantile(exp(predictions$est), 0.995))   ) +   facet_wrap(~year) +   ggtitle(\"Prediction (fixed effects + all random effects)\",     subtitle = paste(\"maximum estimated biomass density =\", round(max(exp(predictions$est))))   ) plot_map(predictions, exp(est_non_rf)) +   scale_fill_viridis_c(trans = \"sqrt\") +   ggtitle(\"Prediction (fixed effects only)\") plot_map(predictions, omega_s) +   scale_fill_gradient2() +   ggtitle(\"Spatial random effects only\") plot_map(predictions, epsilon_st) +   scale_fill_gradient2() +   facet_wrap(~year) +   ggtitle(\"Spatiotemporal random effects only\") sim <- predict(m3, newdata = grid_yrs, nsim = 100) sim_last <- sim[grid_yrs$year == max(grid_yrs$year), ] # just plot last year pred_last <- predictions[predictions$year == max(grid_yrs$year), ] pred_last$lwr <- apply(exp(sim_last), 1, quantile, probs = 0.025) pred_last$upr <- apply(exp(sim_last), 1, quantile, probs = 0.975) pred_last$sd <- round(apply(exp(sim_last), 1, function(x) sd(x)), 2) pred_last$cv <- round(apply(exp(sim_last), 1, function(x) sd(x) / mean(x)), 2) ggplot(pred_last, aes(X, Y, fill = cv)) +   geom_raster() +   scale_fill_viridis_c()"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/basic-intro.html","id":"conditional-effects","dir":"Articles","previous_headings":"","what":"Conditional effects","title":"Introduction to modelling with sdmTMB","text":"can visualize conditional effect covariates feeding simplified data frames predict function fix covariate values want fixed (e.g., means) vary parameters want visualize (across range values):  also visreg package. version link space residuals partial randomized quantile residuals. See scale argument visreg response scale plots.  ggeffects package marginal effects plot. also faster since relies already estimated coefficients variance-covariance matrix.","code":"nd <- data.frame(   depth = seq(min(pcod$depth),     max(pcod$depth),     length.out = 100   ),   year = 2015L # a chosen year ) p <- predict(m3, newdata = nd, se_fit = TRUE, re_form = NA)  ggplot(p, aes(depth, exp(est),   ymin = exp(est - 1.96 * est_se),   ymax = exp(est + 1.96 * est_se) )) +   geom_line() +   geom_ribbon(alpha = 0.4) +   scale_x_continuous() +   coord_cartesian(expand = F) +   labs(x = \"Depth (m)\", y = \"Biomass density (kg/km2)\") visreg::visreg(m3, \"depth\") ggeffects::ggeffect(m3, \"depth [0:500 by=1]\") |> plot() #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_line()`). #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_ribbon()`)."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/basic-intro.html","id":"time-varying-effects","dir":"Articles","previous_headings":"Conditional effects","what":"Time-varying effects","title":"Introduction to modelling with sdmTMB","text":"also let effect depth vary time. set time-varying coefficients follow AR1 process setting time_varying_type = \"ar1\" (year’s coefficient correlated previous year’s). \"ar1\" \"rw0\", fixed effects represent starting point time series time-varying process represents deviations time. , instead, used time_varying_type = \"rw\", first time step random effect process represent initial year values want omit matching effects main formula. example: include full length time increments extra_time ensure estimate time-varying coefficient values year, including years missing data. example, turn spatiotemporal random effects convergence issues turned . plot , make data frame contains combinations time-varying covariate time. easily created using expand.grid() tidyr::expand_grid().","code":"formula = density ~ 0, time_varying = ~ 1 + depth_scaled + depth_scaled2, time_varying_type = \"rw\" m4 <- sdmTMB(   density ~ 1 + depth_scaled + depth_scaled2,   data = pcod,   time_varying = ~ 1 + depth_scaled + depth_scaled2,   time_varying_type = \"ar1\",   extra_time = seq(min(pcod$year), max(pcod$year)),   mesh = mesh,   family = tweedie(link = \"log\"),   spatial = \"on\",   time = \"year\",   spatiotemporal = \"off\" ) m4 #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ 1 + depth_scaled + depth_scaled2 #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod #> Family: tweedie(link = 'log') #>   #> Conditional model: #>               coef.est coef.se #> (Intercept)       3.84    0.28 #> depth_scaled     -1.91    0.16 #> depth_scaled2    -1.72    0.18 #>  #> Time-varying parameters: #>                    coef.est coef.se #> (Intercept)-2003       0.00    0.08 #> (Intercept)-2004       0.21    0.08 #> (Intercept)-2005       0.17    0.08 #> (Intercept)-2006      -0.03    0.16 #> (Intercept)-2007      -0.25    0.09 #> (Intercept)-2008      -0.15    0.21 #> (Intercept)-2009      -0.25    0.08 #> (Intercept)-2010      -0.03    0.16 #> (Intercept)-2011       0.15    0.08 #> (Intercept)-2012       0.05    0.17 #> (Intercept)-2013       0.03    0.08 #> (Intercept)-2014       0.04    0.17 #> (Intercept)-2015       0.12    0.08 #> (Intercept)-2016       0.02    0.16 #> (Intercept)-2017      -0.06    0.08 #> depth_scaled-2003      0.00    0.04 #> depth_scaled-2004      0.00    0.04 #> depth_scaled-2005     -0.01    0.05 #> depth_scaled-2006      0.00    0.05 #> depth_scaled-2007     -0.01    0.07 #> depth_scaled-2008      0.00    0.04 #> depth_scaled-2009      0.01    0.06 #> depth_scaled-2010      0.00    0.05 #> depth_scaled-2011      0.01    0.05 #> depth_scaled-2012      0.00    0.04 #> depth_scaled-2013      0.00    0.04 #> depth_scaled-2014      0.00    0.05 #> depth_scaled-2015      0.03    0.11 #> depth_scaled-2016      0.00    0.04 #> depth_scaled-2017     -0.02    0.10 #> depth_scaled2-2003    -0.05    0.22 #> depth_scaled2-2004    -0.04    0.19 #> depth_scaled2-2005    -0.11    0.22 #> depth_scaled2-2006     0.00    0.42 #> depth_scaled2-2007    -0.02    0.24 #> depth_scaled2-2008     0.01    0.50 #> depth_scaled2-2009     0.69    0.19 #> depth_scaled2-2010     0.00    0.42 #> depth_scaled2-2011    -0.50    0.23 #> depth_scaled2-2012     0.00    0.42 #> depth_scaled2-2013     0.56    0.17 #> depth_scaled2-2014     0.00    0.46 #> depth_scaled2-2015    -0.06    0.23 #> depth_scaled2-2016     0.00    0.46 #> depth_scaled2-2017    -0.45    0.25 #> rho-(Intercept)        0.34    0.39 #> rho-depth_scaled       0.00    1.19 #> rho-depth_scaled2      0.01    0.40 #>  #> Dispersion parameter: 12.37 #> Tweedie p: 1.58 #> Matérn range: 15.41 #> Spatial SD: 1.75 #> ML criterion at convergence: 6361.987 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. nd <- expand.grid(   depth_scaled = seq(min(pcod$depth_scaled) + 0.2,     max(pcod$depth_scaled) - 0.2,     length.out = 50   ),   year = unique(pcod$year) # all years ) nd$depth_scaled2 <- nd$depth_scaled^2  p <- predict(m4, newdata = nd, se_fit = TRUE, re_form = NA)  ggplot(p, aes(depth_scaled, exp(est),   ymin = exp(est - 1.96 * est_se),   ymax = exp(est + 1.96 * est_se),   group = as.factor(year) )) +   geom_line(aes(colour = year), lwd = 1) +   geom_ribbon(aes(fill = year), alpha = 0.1) +   scale_colour_viridis_c() +   scale_fill_viridis_c() +   scale_x_continuous(labels = function(x) round(exp(x * pcod$depth_sd[1] + pcod$depth_mean[1]))) +   coord_cartesian(expand = F) +   labs(x = \"Depth (m)\", y = \"Biomass density (kg/km2)\")"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/bayesian.html","id":"simulating-data","dir":"Articles","previous_headings":"","what":"Simulating data","title":"Bayesian estimation with sdmTMB","text":"demonstrate using simulated dataset. Visualize simulated data:","code":"set.seed(123) predictor_dat <- data.frame(   X = runif(500), Y = runif(500),   a1 = rnorm(500) ) mesh <- make_mesh(predictor_dat, xy_cols = c(\"X\", \"Y\"), cutoff = 0.1) # plot(mesh) # mesh$mesh$n sim_dat <- sdmTMB_simulate(   formula = ~a1,   data = predictor_dat,   mesh = mesh,   family = gaussian(),   range = 0.3,   phi = 0.2,   sigma_O = 0.2,   seed = 123,   B = c(0.8, -0.4) # B0 = intercept, B1 = a1 slope ) ggplot(sim_dat, aes(X, Y, colour = observed)) +   geom_point() +   scale_color_viridis_c()"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/bayesian.html","id":"fitting-the-model-with-marginal-likelihood","dir":"Articles","previous_headings":"","what":"Fitting the model with marginal likelihood","title":"Bayesian estimation with sdmTMB","text":"First, fit spatial random field GLMM maximum likelihood:","code":"fit <- sdmTMB(   observed ~ a1,   data = sim_dat,   mesh = mesh,   family = gaussian(),   spatial = \"on\" ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: observed ~ a1 #> Mesh: mesh (isotropic covariance) #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)      0.8    0.06 #> a1              -0.4    0.01 #>  #> Dispersion parameter: 0.20 #> Matérn range: 0.32 #> Spatial SD: 0.17 #> ML criterion at convergence: -65.939 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/bayesian.html","id":"adding-priors","dir":"Articles","previous_headings":"","what":"Adding priors","title":"Bayesian estimation with sdmTMB","text":"first model fit use priors (maximum likelihood estimation, also can thought penalties likelihood). first model, priors implied uniform internal parameter space. However, sdmTMB provides option applying additional priors. show example applying Normal(0, 5) (mean, SD) prior intercept Normal(0, 1) prior slope parameter. guess model matrix structure based formula, can verify looking internal model matrix previous fit (using do_fit = FALSE save time didn’t want fit first time). column corresponds order b priors:","code":"head(fit$tmb_data$X_ij[[1]]) #>   (Intercept)          a1 #> 1           1 -0.60189285 #> 2           1 -0.99369859 #> 3           1  1.02678506 #> 4           1  0.75106130 #> 5           1 -1.50916654 #> 6           1 -0.09514745 fit <- sdmTMB(   observed ~ a1,   data = sim_dat,   mesh = mesh,   family = gaussian(),   spatial = \"on\",   priors = sdmTMBpriors(     # location = vector of means; scale = vector of standard deviations:     b = normal(location = c(0, 0), scale = c(5, 2)),   ) ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: observed ~ a1 #> Mesh: mesh (isotropic covariance) #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)      0.8    0.06 #> a1              -0.4    0.01 #>  #> Dispersion parameter: 0.20 #> Matérn range: 0.32 #> Spatial SD: 0.17 #> ML criterion at convergence: -62.846 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/bayesian.html","id":"fixing-a-spatial-correlation-parameter-to-improve-convergence","dir":"Articles","previous_headings":"","what":"Fixing a spatial correlation parameter to improve convergence","title":"Bayesian estimation with sdmTMB","text":"Sometimes spatial correlation parameters can challenging estimate Stan. One option apply penalized complexity (PC) priors sdmTMBpriors() Matérn parameters. Another option, can also used conjunction priors, fix one parameters maximum likelihood estimate (MLE) values. Frequently, fixing parameter ln_kappa can help convergence (e.g., Monnahan et al. 2021). estimated parameter transformed range estimate, controls rate spatial correlation decay. Now rebuild fitted object fixed (‘mapped’) ln_kappa parameters using update() function. ’ll use do_fit = FALSE avoid actually fitting updated model since ’s necessary.","code":"# grab the internal parameter list at estimated values: pars <- sdmTMB::get_pars(fit) # create a 'map' vector for TMB # factor NA values cause TMB to fix or map the parameter at the starting value: kappa_map <- factor(rep(NA, length(pars$ln_kappa)))  # rebuild model updating some elements: fit_mle <- update(   fit,   control = sdmTMBcontrol(     start = list(       ln_kappa = pars$ln_kappa #<     ),     map = list(       ln_kappa = kappa_map #<     )   ),   do_fit = FALSE #< ) #> ℹ Initiating `ln_kappa` at specified starting value(s) of: #> 2.173, 2.173 #> ℹ Fixing or mirroring `ln_kappa`"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/bayesian.html","id":"jacobian-adjustments","dir":"Articles","previous_headings":"","what":"Jacobian adjustments","title":"Bayesian estimation with sdmTMB","text":"Adding priors / penalties fixing spatial parameters represent strategies help successful convergence maximum likelihood estimation. want true Bayesian sampling need make one adjustment function call: accounting non-linear transformations parameters Jacobian adjustments. Jacobian adjustments need ? Jacobian adjustments necessary parameters model transformed way changes scale distribution. good example estimation variance parameters. Whether ’re interested spatial, spatiotemporal, residual variation, quantity interest usually variance standard deviation σ\\sigma. quantities constrained greater 0, widely used estimation strategy estimate log space, constrained. ‘ln_sigma’ estimated, ‘sigma = exp(ln_sigma)’ can calculated internal model used calculate likelihood. number helpful references detailing math behind greater detail including Stan manual. Without equations, Jacobian adjustment can thought properly stretching posterior distribution parameters account transformation variables. sdmTMB, can turn Jacobian adjustments flag bayesian = TRUE. Applying fit_mle object, important emphasize bayesian flag needs enabled model passed Stan; MCMC estimation without lead biased parameter estimates.","code":"fit_bayes <- update(fit_mle,   bayesian = TRUE ) #> ℹ Initiating `ln_kappa` at specified starting value(s) of: #> 2.173, 2.173 #> ℹ Fixing or mirroring `ln_kappa`"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/bayesian.html","id":"passing-the-model-to-tmbstan","dir":"Articles","previous_headings":"","what":"Passing the model to tmbstan","title":"Bayesian estimation with sdmTMB","text":"Now can pass $tmb_obj element model tmbstan::tmbstan(). using 1000 iterations 2 chains vignette builds quickly. practice, likely want use (e.g., 2000 iterations, 4 chains). Sometimes may need adjust sampler settings : See Details section ?rstan::stan. can also ‘thin’ samples via thin argument working model predictions becomes cumbersome given large number required samples. can look model: Rhat values look reasonable (< 1.05). n_eff (number effective samples) values mostly look reasonable (> 100) inference mean parameters except intercept (b_j[1]). Furthermore, can see correlation MCMC samples b_j[1]. try running iterations chains /placing priors parameters described (highly recommended). Now can use various functions visualize posterior:","code":"fit_stan <- tmbstan::tmbstan(   fit_bayes$tmb_obj,   iter = 1000, chains = 2,   seed = 8217 # ensures repeatability ) tmbstan::tmbstan(   ...,   control = list(adapt_delta = 0.9, max_treedepth = 12) ) fit_stan #> Inference for Stan model: sdmTMB. #> 2 chains, each with iter=1000; warmup=500; thin=1;  #> post-warmup draws per chain=500, total post-warmup draws=1000. #>  #>               mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat #> b_j[1]        0.81    0.01 0.05   0.69   0.77   0.81   0.84   0.92    71 1.03 #> b_j[2]       -0.40    0.00 0.01  -0.41  -0.40  -0.40  -0.39  -0.38  1923 1.00 #> ln_tau_O     -1.66    0.01 0.14  -1.93  -1.75  -1.65  -1.57  -1.37   384 1.00 #> ln_phi       -1.63    0.00 0.04  -1.70  -1.65  -1.63  -1.60  -1.56  1147 1.00 #> omega_s[1]   -0.09    0.01 0.09  -0.26  -0.15  -0.09  -0.04   0.08   148 1.02 #> omega_s[2]   -0.06    0.01 0.09  -0.23  -0.12  -0.06   0.00   0.11   168 1.01 #> omega_s[3]    0.01    0.01 0.09  -0.16  -0.05   0.01   0.07   0.20   228 1.01 #> omega_s[4]   -0.21    0.01 0.09  -0.38  -0.27  -0.21  -0.15  -0.02   193 1.01 #> omega_s[5]   -0.34    0.01 0.10  -0.53  -0.41  -0.34  -0.27  -0.14   324 1.00 #> omega_s[6]   -0.09    0.01 0.10  -0.29  -0.15  -0.09  -0.01   0.12   224 1.01 #> omega_s[7]   -0.03    0.01 0.08  -0.19  -0.09  -0.03   0.02   0.15   142 1.02 #> omega_s[8]   -0.23    0.01 0.09  -0.41  -0.29  -0.23  -0.17  -0.05   210 1.01 #> omega_s[9]   -0.32    0.01 0.09  -0.49  -0.38  -0.32  -0.26  -0.15   206 1.01 #> omega_s[10]   0.28    0.01 0.09   0.12   0.22   0.28   0.34   0.45   173 1.01 #> omega_s[11]  -0.16    0.01 0.09  -0.33  -0.22  -0.16  -0.10   0.02   169 1.01 #> omega_s[12]   0.00    0.01 0.10  -0.19  -0.07   0.00   0.06   0.20   321 1.01 #> omega_s[13]   0.18    0.01 0.08   0.04   0.13   0.18   0.24   0.34   157 1.02 #> omega_s[14]  -0.09    0.01 0.10  -0.28  -0.16  -0.09  -0.03   0.10   225 1.01 #> omega_s[15]   0.22    0.01 0.09   0.04   0.16   0.22   0.27   0.38   175 1.01 #> omega_s[16]  -0.02    0.01 0.09  -0.20  -0.08  -0.02   0.04   0.15   194 1.01 #> omega_s[17]  -0.15    0.01 0.09  -0.33  -0.21  -0.15  -0.09   0.03   266 1.00 #> omega_s[18]  -0.29    0.01 0.11  -0.49  -0.36  -0.29  -0.22  -0.09   254 1.00 #> omega_s[19]  -0.01    0.01 0.09  -0.19  -0.07   0.00   0.06   0.18   179 1.01 #> omega_s[20]   0.02    0.01 0.08  -0.15  -0.04   0.02   0.07   0.18   156 1.01 #> omega_s[21]   0.07    0.01 0.08  -0.07   0.01   0.07   0.13   0.24   163 1.01 #> omega_s[22]  -0.02    0.01 0.10  -0.22  -0.09  -0.02   0.06   0.18   219 1.01 #> omega_s[23]   0.12    0.01 0.09  -0.04   0.06   0.11   0.17   0.30   169 1.02 #> omega_s[24]   0.20    0.01 0.10   0.00   0.13   0.19   0.26   0.41   264 1.01 #> omega_s[25]   0.07    0.01 0.08  -0.10   0.02   0.07   0.12   0.23   146 1.01 #> omega_s[26]  -0.01    0.01 0.10  -0.21  -0.08  -0.01   0.06   0.18   241 1.01 #> omega_s[27]  -0.11    0.01 0.09  -0.28  -0.17  -0.11  -0.05   0.06   224 1.01 #> omega_s[28]   0.11    0.01 0.10  -0.07   0.05   0.11   0.18   0.32   247 1.01 #> omega_s[29]   0.29    0.01 0.09   0.12   0.23   0.29   0.35   0.47   189 1.01 #> omega_s[30]  -0.04    0.01 0.09  -0.21  -0.10  -0.04   0.01   0.13   202 1.01 #> omega_s[31]   0.09    0.01 0.08  -0.06   0.04   0.09   0.15   0.25   180 1.01 #> omega_s[32]   0.05    0.01 0.11  -0.17  -0.02   0.05   0.12   0.26   359 1.01 #> omega_s[33]   0.07    0.01 0.10  -0.12   0.01   0.07   0.14   0.28   241 1.00 #> omega_s[34]   0.04    0.01 0.09  -0.13  -0.02   0.04   0.10   0.22   223 1.01 #> omega_s[35]   0.07    0.01 0.09  -0.11   0.01   0.07   0.13   0.24   219 1.01 #> omega_s[36]   0.14    0.01 0.09  -0.04   0.07   0.14   0.20   0.32   240 1.01 #> omega_s[37]   0.16    0.01 0.11  -0.05   0.08   0.16   0.23   0.38   331 1.00 #> omega_s[38]   0.12    0.01 0.09  -0.05   0.05   0.12   0.17   0.30   222 1.01 #> omega_s[39]  -0.22    0.01 0.09  -0.40  -0.28  -0.23  -0.16  -0.03   212 1.01 #> omega_s[40]  -0.03    0.01 0.09  -0.21  -0.09  -0.03   0.04   0.17   163 1.01 #> omega_s[41]   0.18    0.01 0.09   0.01   0.13   0.18   0.24   0.35   149 1.02 #> omega_s[42]   0.20    0.01 0.09   0.03   0.14   0.20   0.26   0.38   198 1.01 #> omega_s[43]   0.14    0.01 0.10  -0.04   0.07   0.14   0.21   0.34   277 1.01 #> omega_s[44]   0.13    0.01 0.09  -0.05   0.07   0.13   0.19   0.33   192 1.01 #> omega_s[45]   0.09    0.01 0.10  -0.12   0.02   0.09   0.16   0.29   272 1.01 #> omega_s[46]   0.06    0.01 0.09  -0.11  -0.01   0.05   0.12   0.24   217 1.01 #> omega_s[47]   0.30    0.01 0.09   0.13   0.24   0.30   0.37   0.48   188 1.01 #> omega_s[48]  -0.25    0.01 0.10  -0.44  -0.31  -0.24  -0.18  -0.07   261 1.00 #> omega_s[49]   0.09    0.01 0.10  -0.11   0.03   0.09   0.16   0.29   251 1.01 #> omega_s[50]  -0.09    0.01 0.08  -0.24  -0.14  -0.09  -0.04   0.07   161 1.01 #> omega_s[51]   0.24    0.01 0.11   0.03   0.17   0.24   0.31   0.47   238 1.00 #> omega_s[52]  -0.22    0.01 0.11  -0.43  -0.29  -0.21  -0.15  -0.02   279 1.00 #> omega_s[53]   0.03    0.01 0.10  -0.14  -0.03   0.04   0.09   0.22   236 1.01 #> omega_s[54]   0.03    0.01 0.09  -0.14  -0.04   0.02   0.09   0.21   179 1.02 #> omega_s[55]  -0.09    0.01 0.11  -0.30  -0.16  -0.09  -0.02   0.13   467 1.00 #> omega_s[56]  -0.42    0.01 0.10  -0.62  -0.49  -0.42  -0.34  -0.22   241 1.01 #> omega_s[57]   0.00    0.01 0.11  -0.21  -0.08   0.01   0.08   0.21   288 1.01 #> omega_s[58]  -0.21    0.01 0.10  -0.40  -0.28  -0.21  -0.16  -0.02   197 1.01 #> omega_s[59]   0.04    0.01 0.23  -0.40  -0.12   0.04   0.19   0.49   859 1.00 #> omega_s[60]  -0.22    0.01 0.26  -0.71  -0.40  -0.21  -0.05   0.31  1225 1.00 #> omega_s[61]  -0.27    0.01 0.24  -0.73  -0.43  -0.27  -0.11   0.20   637 1.00 #> omega_s[62]  -0.27    0.01 0.24  -0.73  -0.42  -0.27  -0.10   0.19   521 1.00 #> omega_s[63]  -0.27    0.01 0.23  -0.70  -0.43  -0.27  -0.13   0.18   645 1.00 #> omega_s[64]   0.07    0.01 0.23  -0.37  -0.09   0.08   0.23   0.51   972 1.00 #> omega_s[65]   0.17    0.01 0.22  -0.25   0.02   0.17   0.33   0.59   808 1.00 #> omega_s[66]   0.16    0.01 0.22  -0.28   0.02   0.16   0.30   0.57   676 1.00 #> omega_s[67]  -0.03    0.01 0.22  -0.45  -0.17  -0.02   0.11   0.39   759 1.00 #> omega_s[68]  -0.01    0.01 0.25  -0.49  -0.19  -0.01   0.16   0.44   927 1.00 #> omega_s[69]   0.00    0.01 0.22  -0.42  -0.14   0.01   0.15   0.41   745 1.00 #> omega_s[70]   0.00    0.01 0.21  -0.44  -0.13   0.00   0.14   0.41   732 1.00 #> omega_s[71]   0.17    0.01 0.22  -0.29   0.03   0.18   0.31   0.57   642 1.00 #> omega_s[72]  -0.11    0.01 0.24  -0.62  -0.27  -0.11   0.05   0.35   859 1.00 #> omega_s[73]  -0.14    0.01 0.22  -0.59  -0.29  -0.14   0.00   0.26   545 1.00 #> omega_s[74]  -0.13    0.01 0.21  -0.55  -0.28  -0.12   0.01   0.26   572 1.00 #> omega_s[75]  -0.38    0.01 0.22  -0.80  -0.52  -0.38  -0.24   0.05   958 1.00 #> omega_s[76]   0.09    0.01 0.19  -0.26  -0.04   0.09   0.21   0.48   912 1.01 #> omega_s[77]   0.09    0.01 0.20  -0.30  -0.04   0.08   0.22   0.49   710 1.00 #> omega_s[78]  -0.06    0.01 0.21  -0.45  -0.20  -0.06   0.08   0.39   998 1.00 #> omega_s[79]   0.04    0.01 0.15  -0.27  -0.06   0.04   0.15   0.34   638 1.00 #> omega_s[80]  -0.18    0.01 0.23  -0.64  -0.33  -0.17  -0.02   0.23  1011 1.00 #> omega_s[81]  -0.07    0.01 0.19  -0.43  -0.20  -0.08   0.06   0.29   844 1.00 #> omega_s[82]  -0.15    0.01 0.20  -0.55  -0.29  -0.14  -0.02   0.26   834 1.00 #> omega_s[83]  -0.02    0.01 0.23  -0.46  -0.17  -0.02   0.14   0.41   978 1.00 #> omega_s[84]   0.11    0.01 0.20  -0.28  -0.02   0.11   0.24   0.50  1071 1.00 #> omega_s[85]  -0.30    0.01 0.21  -0.71  -0.44  -0.30  -0.16   0.12  1112 1.00 #> lp__        136.24    0.54 9.17 118.78 130.29 136.85 142.47 153.21   284 1.00 #>  #> Samples were drawn using NUTS(diag_e) at Sat Nov 22 21:53:05 2025. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1). plot(fit_stan) #> 'pars' not specified. Showing first 10 parameters by default. #> ci_level: 0.8 (80% intervals) #> outer_level: 0.95 (95% intervals) pars_plot <- c(\"b_j[1]\", \"b_j[2]\", \"ln_tau_O\", \"omega_s[1]\")  bayesplot::mcmc_trace(fit_stan, pars = pars_plot) bayesplot::mcmc_pairs(fit_stan, pars = pars_plot)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/bayesian.html","id":"posterior-predictive-checks","dir":"Articles","previous_headings":"","what":"Posterior predictive checks","title":"Bayesian estimation with sdmTMB","text":"can perform posterior predictive checks assess whether model can generate predictive data consistent observations. , can make use simulate.sdmTMB() passing Stan model. simulate.sdmTMB() take draws joint parameter posterior add observation error. need ensure nsim less equal total number post-warmup samples.  See ?bayesplot::pp_check. solid line represents density observed data light blue lines represent density 50 posterior predictive simulations. case, simulated data seem consistent observed data.","code":"set.seed(19292) samps <- sdmTMBextra::extract_mcmc(fit_stan) s <- simulate(fit_mle, mcmc_samples = samps, nsim = 50) bayesplot::pp_check(   sim_dat$observed,   yrep = t(s),   fun = bayesplot::ppc_dens_overlay )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/bayesian.html","id":"plotting-predictions","dir":"Articles","previous_headings":"","what":"Plotting predictions","title":"Bayesian estimation with sdmTMB","text":"can make predictions Bayesian model supplying posterior samples mcmc_samples argument predict.sdmTMB(). output matrix row corresponds row predicted data column corresponds sample. can summarize draws various ways visualize :   predict grid given value a1:","code":"pred <- predict(fit_mle, mcmc_samples = samps) dim(pred) #> [1]  500 1000 sim_dat$post_mean <- apply(pred, 1, mean) sim_dat$post_sd <- apply(pred, 1, sd)  ggplot(sim_dat, aes(X, Y, colour = post_mean)) +   geom_point() +   scale_color_viridis_c() ggplot(sim_dat, aes(X, Y, colour = post_sd)) +   geom_point() +   scale_color_viridis_c() nd <- expand.grid(   X = seq(0, 1, length.out = 70),   Y = seq(0, 1, length.out = 70),   a1 = 0 ) pred <- predict(fit_mle, newdata = nd, mcmc_samples = samps)  nd$post_mean <- apply(pred, 1, mean) nd$post_sd <- apply(pred, 1, sd)  ggplot(nd, aes(X, Y, fill = post_mean)) +   geom_raster() +   scale_fill_viridis_c() +   coord_fixed() ggplot(nd, aes(X, Y, fill = post_sd)) +   geom_raster() +   scale_fill_viridis_c() +   coord_fixed()"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/bayesian.html","id":"extracting-parameter-posterior-samples","dir":"Articles","previous_headings":"","what":"Extracting parameter posterior samples","title":"Bayesian estimation with sdmTMB","text":"can extract posterior samples rstan::extract(), result list element corresponds parameter set parameters:  example calculating derived parameter, calculate marginal spatial random field standard deviation:","code":"post <- rstan::extract(fit_stan) names(post) #> [1] \"b_j\"      \"ln_tau_O\" \"ln_phi\"   \"omega_s\"  \"lp__\" hist(post$b_j[, 1]) ln_kappa <- get_pars(fit_mle)$ln_kappa[1] # 2 elements since 2nd would be for spatiotemporal ln_tau_O <- post$ln_tau_O sigma_O <- 1 / sqrt(4 * pi * exp(2 * ln_tau_O + 2 * ln_kappa)) hist(sigma_O)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/bayesian.html","id":"extracting-the-posterior-of-other-predicted-elements","dir":"Articles","previous_headings":"","what":"Extracting the posterior of other predicted elements","title":"Bayesian estimation with sdmTMB","text":"default predict.sdmTMB() returns overall prediction link space tmbstan model passed . instead want element might find usual data frame returned predict.sdmTMB() applied regular sdmTMB model, can specify sims_var argument. example, let’s extract spatial random field values \"omega_s\". options documented ?predict.sdmTMB().","code":"fit_pred <- predict(   fit_mle,   newdata = nd,   mcmc_samples = samps,   sims_var = \"omega_s\" #< )  nd$spatial_rf_mean <- apply(fit_pred, 1, mean) nd$spatial_rf_sd <- apply(fit_pred, 1, sd)  ggplot(nd, aes(X, Y, fill = spatial_rf_mean)) +   geom_raster() +   scale_fill_gradient2() +   coord_fixed() ggplot(nd, aes(X, Y, fill = spatial_rf_sd)) +   geom_raster() +   scale_fill_viridis_c() +   coord_fixed()"},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/cross-validation.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Cross-validation for model evaluation and comparison","text":"Cross-validation one best approaches can used quantify model performance compare sdmTMB models different structures (unlike AIC, approach also factor uncertainty random effects). Arguably challenging decision implementing cross-validation specify folds (fold representing subset data turn held used test set). Folds may vary number data partitioned, likely slightly different application. goals sdmTMB applications may focused spatial prediction; include making prediction new spatial regions (e.g. unsampled areas areas sampled every year). types models recommend exploring folds using blockCV spatialsample packages (Valavi et al. 2019; Silge 2021). general, spatial sampling approaches assign observations spatially autocorrelated fold. Accounting spatial correlation can lead better estimates covariate effects, well prediction errors. Alternatively, goals analysis sdmTMB may evaluate predictive accuracy model time (e.g. missing survey year, prediction future years). retrospective analyses, points within year may assigned fold (groups years fold). contrast, models forward looking use Leave Future Cross-Validation (LFOCV). LFOCV, data year tt used predict observations t+1t+1, etc.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/cross-validation.html","id":"cross-validation-in-sdmtmb","dir":"Articles","previous_headings":"","what":"Cross validation in sdmTMB","title":"Cross-validation for model evaluation and comparison","text":"Cross validation sdmTMB implemented using sdmTMB_cv() function, k_folds argument specifying number folds (defaults 8). function uses parallelization default future::plan() set, can turned parallel argument. example, folds assigned randomly—can modified specific spatial temporal applications. Without getting complexities blockCV spatialsample packages, simply use kmeans generate spatial clusters, e.g. similarly, clusters assigned time—, year unique fold. Note year included factor spatiotemporal fields turned estimated missing years.","code":"data(pcod) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 25) pcod$fyear <- as.factor(pcod$year) # Set parallel processing if desired: library(future) plan(multisession, workers = 2) m_cv <- sdmTMB::sdmTMB_cv(   density ~ 0 + s(depth_scaled) + fyear,   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   k_folds = 4 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing. clust <- kmeans(pcod[, c(\"X\", \"Y\")], 20)$cluster  m_cv <- sdmTMB::sdmTMB_cv(   density ~ 0 + s(depth_scaled) + fyear,   data = pcod,   mesh = mesh,   fold_ids = clust,   family = tweedie(link = \"log\") ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing. clust <- as.numeric(as.factor(pcod$year))  m_cv <- sdmTMB::sdmTMB_cv(   density ~ 0 + s(depth_scaled),   data = pcod,   mesh = mesh,   fold_ids = clust,   spatiotemporal = \"off\",   family = tweedie(link = \"log\") ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/cross-validation.html","id":"measuring-model-performance","dir":"Articles","previous_headings":"","what":"Measuring model performance","title":"Cross-validation for model evaluation and comparison","text":"Lots measures predictive accuracy can used evaluate model performance. default, sdmTMB_cv() returns list contains sum log likelihoods left-fold total summed across left-folds. roughly equivalent expected log predictive density (ELPD) Bayesian literature can interpreted predictive ability model new observations. can accessed , inspecting quantities across folds may help elucidate whether particular folds difficult predict. fold_loglik values represent sum predictive log-likelihood values across observations fold, sum_loglik value represents sum fold_loglik values, representing sum entire dataset. can also calculate derived statistics based predictive values – , using examples Root Mean Square Error (RMSE) Mean Absolute Error (MAE). Alternatively, might interested calculating RMSE MAE fold,","code":"m_cv <- sdmTMB_cv(   density ~ 0 + s(depth_scaled) + fyear,   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   k_folds = 4 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  m_cv$fold_loglik # fold log-likelihood #> [1] -1640.111 -1732.549 -1722.904 -1507.211 m_cv$sum_loglik # total log-likelihood #> [1] -6602.776 m <- sdmTMB_cv(   density ~ depth_scaled + depth_scaled2,   data = pcod, mesh = make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 25),   family = tweedie(link = \"log\"), k_folds = 3 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  # RMSE across entire dataset: sqrt(mean((m$data$density - m$data$cv_predicted)^2))  #> [1] 194.9289 # MAE across entire dataset: mean(abs(m$data$density - m$data$cv_predicted)) #> [1] 50.53269 # RMSE and MAE by fold: group_by(m$data, cv_fold) |>    summarize(     rmse = sqrt(mean((density - cv_predicted)^2)),     mae = mean(abs(density - cv_predicted))   ) #> # A tibble: 3 × 3 #>   cv_fold  rmse   mae #>     <int> <dbl> <dbl> #> 1       1  281.  58.2 #> 2       2  150.  48.8 #> 3       3  113.  44.6"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/cross-validation.html","id":"single-splits","dir":"Articles","previous_headings":"","what":"Single splits","title":"Cross-validation for model evaluation and comparison","text":"cases single test set evaluated (e.g., 10% data), using sdmTMB_cv() function may overkill two sdmTMB() models fit, using function may worthwhile reduce coding errors (log-likelihood calculations). example, assign two folds, randomly holding 10% observations test set (test set given ID = 1, training set given ID = 2). can ignore total log-likelihood, just focus first element list list:","code":"clust <- sample(1:2, size = nrow(pcod), replace = TRUE, prob = c(0.1, 0.9))  m_cv <- sdmTMB_cv(   density ~ 0 + s(depth_scaled) + fyear,   data = pcod,   mesh = mesh,   fold_ids = clust,   family = tweedie(link = \"log\"),   k_folds = length(unique(clust)) ) m_cv$fold_loglik[[1]] #> [1] -771.5139"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/cross-validation.html","id":"comparing-two-or-more-models","dir":"Articles","previous_headings":"","what":"Comparing two or more models","title":"Cross-validation for model evaluation and comparison","text":"can use output sdmTMB_cv() compare two models. example, wanted evaluate support depth effect , 10-fold cross validation (’s important folds across two models). example, using either predictive log-likelihood ELPD lead one conclude including depth improves predictive accuracy model.","code":"clust <- sample(seq_len(10), size = nrow(pcod), replace = TRUE)  m1 <- sdmTMB::sdmTMB_cv(   density ~ 0 + fyear,   data = pcod,   mesh = mesh,   fold_ids = clust,   family = tweedie(link = \"log\") ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  m2 <- sdmTMB::sdmTMB_cv(   density ~ 0 + fyear + s(depth_scaled),   data = pcod,   mesh = mesh,   fold_ids = clust,   family = tweedie(link = \"log\") ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  # Compare log-likelihoods -- higher is better! m1$sum_loglik #> [1] -6728.762 m2$sum_loglik #> [1] -6554.709"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/cross-validation.html","id":"model-ensembling","dir":"Articles","previous_headings":"","what":"Model ensembling","title":"Cross-validation for model evaluation and comparison","text":"Finally, instead identifying single “best” models, may interested model averaging. sdmTMB package, ’ve implemented model stacking procedure described (Yao et al. 2018) sdmTMB_stacking() function. procedure uses optimization find normalized weights maximize total log-likelihood across models (metrics may also used). Inputs function list models (fictitious model_list), list element output call sdmTMB_cv(): default calculation uses data fold. instead, split data 10/90 split (example ), wouldn’t want use 2nd model fit generate weights. just wanted use predictions first fold onto 10% test set, specify using include_folds argument.","code":"weights <- sdmTMB_stacking(model_list) weights <- sdmTMB_stacking(model_list, include_folds = 1)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/cross-validation.html","id":"calculating-measures-of-predictive-skill-for-binary-data","dir":"Articles","previous_headings":"","what":"Calculating measures of predictive skill for binary data","title":"Cross-validation for model evaluation and comparison","text":"delta models, models presence-absence data, several measures predictive ability available. applicable cross validation, although demonstrate first non-cross validation context simplicity. first commonly used diagnostic AUC (Area Curve), quantifies ability model discriminate two classes; done Receiver Operating Characteristic (ROC) curve, plots true positive rate vs. false positive rate. several packages calculate AUC R, can done pROC package, inputs vector 0s 1s (factor equivalents) raw data, vector estimated probabilities (generated call predict(), shown ). plogis() function needed convert estimated values logit space probabilities natural (zero one) space. delta model, two estimated values returned, first used. E.g., wanted apply context cross validation, like : AUC may sensitive imbalances data, however, alternative metrics may better approximate skill. highlight example using true skill score (implemented packages SDMtune): Next, can generate predicted probabilities classes using threshold 0.5 example: Next create confusion matrix calculate true skill score: cases, reporting true negative true positive rate might interest addition TSS.","code":"mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 10) fit <- sdmTMB(present ~ s(depth), data = pcod, mesh = mesh) pred <- predict(fit) # presence-absence model roc <- pROC::roc(pcod$present, plogis(pred$est)) #> Setting levels: control = 0, case = 1 #> Setting direction: controls < cases auc <- pROC::auc(roc) auc #> Area under the curve: 0.8831 fit <- sdmTMB(density ~ 1, data = pcod,    mesh = mesh, family = delta_gamma()) pred <- predict(fit)  # the first linear predictor is the binomial component (est1): roc <- pROC::roc(pcod$present, plogis(pred$est1)) #> Setting levels: control = 0, case = 1 #> Setting direction: controls < cases auc <- pROC::auc(roc) auc #> Area under the curve: 0.8604 x <- sdmTMB_cv(   present ~ s(depth), data = pcod, spatial = \"off\",   mesh = mesh, family = binomial(), k_folds = 2 ) roc <- pROC::roc(x$data$present, plogis(x$data$cv_predicted)) auc <- pROC::auc(roc) auc mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 10) fit <- sdmTMB(present ~ 1, data = pcod,    mesh = mesh, family = binomial()) pred <- predict(fit) pred$p <- plogis(pred$est) pred$pred_01 <- ifelse(pred$p < 0.5, 0, 1) conmat <- table(pred$pred_01, pred$present) true_neg <- conmat[1, 1] false_neg <- conmat[1, 2] false_pos <- conmat[2, 1] true_pos <- conmat[2, 2]  # Calculate TSS: true_pos_rate <- true_pos / (true_pos + false_neg) true_neg_rate <- true_neg / (true_neg + false_pos) TSS <- true_pos_rate + true_neg_rate - 1 TSS #> [1] 0.5238745"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/cross-validation.html","id":"multi-scale-spatial-assessment-with-waywiser","dir":"Articles","previous_headings":"","what":"Multi-scale spatial assessment with waywiser","title":"Cross-validation for model evaluation and comparison","text":"waywiser package (Mahoney 2023) provides tools assessing spatial models, including methods evaluate model performance multiple spatial scales. common pattern spatial models predictions individual observation units (e.g., points, pixels) may aggregated arbitrary scales (e.g., management units, grid cells varying sizes). prediction errors can spatially distributed may compound counteract aggregated, ’s useful assess model performance across multiple scales. cv_to_waywiser() function converts sdmTMB_cv objects sf (simple features) format, can passed waywiser functions like ww_multi_scale(). sf object can now used waywiser functions. example, assess model performance multiple spatial scales: results show metrics like RMSE MAE change predictions aggregated coarser spatial scales, can reveal whether model’s performance scale-dependent. See waywiser documentation (?waywiser::ww_multi_scale vignette(\"multi-scale-assessment\", package = \"waywiser\")) details interpreting multi-scale assessment results additional functions spatial model evaluation.","code":"# First run cross-validation set.seed(42) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 10) m_cv <- sdmTMB_cv(   density ~ s(depth_scaled),   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  # Convert to sf format for spatial assessment cv_sf <- cv_to_waywiser(m_cv, ll_names = c(\"lon\", \"lat\")) #> Detected UTM zone 9N; CRS = 32609. #> Visit https://epsg.io/32609 to verify. print(cv_sf) #> Simple feature collection with 2143 features and 2 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 343061.7 ymin: 5635893 xmax: 579368.1 ymax: 5839019 #> Projected CRS: WGS 84 / UTM zone 9N #> First 10 features: #>        truth     estimate                 geometry #> 1  113.13848 37.532270279 POINT (446475.2 5793426) #> 2   41.70492 11.173070839 POINT (446459.4 5800136) #> 3    0.00000  9.561890006 POINT (448598.7 5801687) #> 4   15.70614 98.612458614 POINT (436915.7 5802305) #> 5    0.00000  7.037695083 POINT (420610.1 5771055) #> 6    0.00000  0.891090606   POINT (417713 5772205) #> 7    0.00000  0.033984196 POINT (408208.8 5771287) #> 8    0.00000  0.007256825 POINT (408356.2 5766882) #> 9    0.00000  0.427827876 POINT (414365.6 5760894) #> 10  13.94762  6.558124623 POINT (400474.5 5749034) # Assess performance at different grid resolutions # n controls the number of grid cells in x and y directions multi_scale_results <- waywiser::ww_multi_scale(   cv_sf,   truth,    # column name (unquoted)   estimate, # column name (unquoted)   # 10x10, 5x5, and 2x2 grids:   n = list(c(10, 10), c(5, 5), c(2, 2)) )  multi_scale_results #> # A tibble: 6 × 6 #>   .metric .estimator .estimate .grid_args       .grid          .notes           #>   <chr>   <chr>          <dbl> <list>           <list>         <list>           #> 1 rmse    standard       19.4  <tibble [1 × 1]> <sf [100 × 5]> <tibble [0 × 2]> #> 2 mae     standard       12.2  <tibble [1 × 1]> <sf [100 × 5]> <tibble [0 × 2]> #> 3 rmse    standard        7.23 <tibble [1 × 1]> <sf [25 × 5]>  <tibble [0 × 2]> #> 4 mae     standard        4.80 <tibble [1 × 1]> <sf [25 × 5]>  <tibble [0 × 2]> #> 5 rmse    standard        3.45 <tibble [1 × 1]> <sf [4 × 5]>   <tibble [0 × 2]> #> 6 mae     standard        3.40 <tibble [1 × 1]> <sf [4 × 5]>   <tibble [0 × 2]>"},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/delta-models.html","id":"example-with-built-in-delta-model","dir":"Articles","previous_headings":"","what":"Example with built-in delta model","title":"Fitting delta (hurdle) models with sdmTMB","text":", show example fitting using built-delta functionality, well build model component separately combine. built-approach convenient, allows parameters shared across components, allows calculation derived quantities standardized indexes (get_index()) internally calculated standard errors. use dataset built sdmTMB package: trawl survey data Pacific Cod Queen Charlotte Sound, British Columbia, Canada. density units kg/km2. , X Y coordinates UTM zone 9. first create mesh use models. can fit model Pacific cod density using delta-gamma model, including smoothed effect depth. default built-delta models formula, spatial spatiotemporal structure, anisotropy shared two model components. However, elements (formula, spatial, spatiotemporal, share_range) can also specified independently model using list format within function argument (see examples ). first element list binomial component second element positive component (e.g., Gamma). elements must shared now (e.g., smoothers, spatially varying coefficients, time-varying coefficients). specify settings spatial spatiotemporal effects model component, create list settings within spatial spatiotemporal arguments. example, spatial = list(\"\", \"\"), spatiotemporal = list(\"\", \"rw\"). similarly specify different formula component model, using list(y ~ x1, y ~ x2) instance, include effect depth positive model, remove presence-absence model. However, currently limitations specifying separate formulas model component. two formulas : smoothers threshold effects random intercepts now, must specified single formula shared across two models. model component can similarly separate settings share_range, determines whether shared spatial spatiotemporal range parameter (TRUE) independent range parameters (FALSE), using list. Lastly, whether anisotropy included model determined logical argument anisotropy (.e., TRUE FALSE), separately specified model. anisotropy included, default shared across two model components. However can made unique model component using sdmTMBcontrol(map = ...) adding argument control fitting model. ‘maps’ anisotropy parameters unique across model components. fit delta model, can evaluate plot output, diagnostics, predictions similar sdmTMB models. printed model output show estimates standard errors parameters model separately. Using tidy() function turn sdmTMB model output data frame, argument model=1 model=2 specify model component extract dataframe. See tidy.sdmTMB() additional arguments options. built-delta models, default function return estimated response parameters grid cell model separately, notated 1 (presence/absence model) 2 (positive catch model) column name. See predict.sdmTMB() description values data frame. can use predictions built-delta model (making sure return_tmb_object=TRUE) get index values using get_index() function. can used predictions include first second models (.e., using default specifying model argument) predictions generated using model=NA. get_index() function automatically combine predictions first second model calculating index values. modelling purposes creating index see vignette Index standardization sdmTMB. can plot conditional effects covariates (depth example model) using package visreg specifying model component model=1 presence-absence model model=2 positive catch model. Currently, plotting effects built-delta models ggeffects supported. See vignette using visreg sdmTMB information.  built-delta models can also evaluated residuals() functions sdmTMB. Similarly generating predictions, can specify model components want return residuals using model argument specifying =1 =2. See residuals.sdmTMB() additional options evaluating residuals sdmTMB models. can also simulate new observations fitted delta model. functions, can specify model simulate using argument model=1 presence/absence, model=2 positive catches, model=NA combined predictions. See simulate.sdmTMB() details simulation options.","code":"pcod_mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 15) fit_dg <- sdmTMB(density ~ 1 + s(depth),   data = pcod,   mesh = pcod_mesh,   time = \"year\",   family = delta_gamma() ) print(fit_dg) #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ 1 + s(depth) #> Mesh: pcod_mesh (isotropic covariance) #> Time column: year #> Data: pcod #> Family: delta_gamma(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #> Conditional model: #>             coef.est coef.se #> (Intercept)    -0.34    0.61 #> sdepth          1.28    2.91 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)     14.38 #>  #> Matérn range: 61.41 #> Spatial SD: 1.71 #> Spatiotemporal IID SD: 0.81 #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: Gamma(link = 'log')  #> Conditional model: #>             coef.est coef.se #> (Intercept)     3.67    0.12 #> sdepth          0.31    1.29 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)      5.41 #>  #> Dispersion parameter: 1.03 #> Matérn range: 14.80 #> Spatial SD: 0.69 #> Spatiotemporal IID SD: 1.45 #>  #> ML criterion at convergence: 6126.400 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. tidy(fit_dg) # model = 1 is default #> # A tibble: 2 × 5 #>   term        estimate std.error conf.low conf.high #>   <chr>          <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)   -0.343     0.614    -1.55     0.860 #> 2 sdepth         1.28      2.91     -4.42     6.98 tidy(fit_dg, model = 1) #> # A tibble: 2 × 5 #>   term        estimate std.error conf.low conf.high #>   <chr>          <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)   -0.343     0.614    -1.55     0.860 #> 2 sdepth         1.28      2.91     -4.42     6.98 tidy(fit_dg, model = 1, \"ran_pars\", conf.int = TRUE) #> # A tibble: 4 × 6 #>   model term         estimate std.error conf.low conf.high #>   <dbl> <chr>           <dbl>     <dbl>    <dbl>     <dbl> #> 1     1 range          61.4      14.1     39.2       96.3  #> 2     1 sigma_O         1.71      0.265    1.26       2.32 #> 3     1 sigma_E         0.806     0.142    0.570      1.14 #> 4     1 sd__s(depth)   14.4      NA        7.93      26.1 tidy(fit_dg, model = 2) #> # A tibble: 2 × 5 #>   term        estimate std.error conf.low conf.high #>   <chr>          <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)     3.67     0.120     3.44      3.91 #> 2 sdepth          0.31     1.29     -2.22      2.84 tidy(fit_dg, model = 2, \"ran_pars\", conf.int = TRUE) #> # A tibble: 5 × 6 #>   model term         estimate std.error conf.low conf.high #>   <dbl> <chr>           <dbl>     <dbl>    <dbl>     <dbl> #> 1     2 range          14.8      5.02      7.62      28.8  #> 2     2 phi             1.03     0.0502    0.939      1.14 #> 3     2 sigma_O         0.691    0.228     0.361      1.32 #> 4     2 sigma_E         1.45     0.336     0.919      2.28 #> 5     2 sd__s(depth)    5.41    NA         2.43      12.1 grid_yrs <- replicate_df(qcs_grid, \"year\", unique(pcod$year)) p <- predict(fit_dg, newdata = grid_yrs) str(p) #> 'data.frame':    65826 obs. of  16 variables: #>  $ X            : num  456 458 460 462 464 466 468 470 472 474 ... #>  $ Y            : num  5636 5636 5636 5636 5636 ... #>  $ depth        : num  347 223 204 183 183 ... #>  $ depth_scaled : num  1.561 0.57 0.363 0.126 0.122 ... #>  $ depth_scaled2: num  2.4361 0.3246 0.132 0.0158 0.0149 ... #>  $ year         : int  2003 2003 2003 2003 2003 2003 2003 2003 2003 2003 ... #>  $ est1         : num  -5.804 -0.796 0.021 0.87 0.98 ... #>  $ est2         : num  3.2 3.71 4.02 4.39 4.43 ... #>  $ est_non_rf1  : num  -5.508 -0.598 0.12 0.871 0.882 ... #>  $ est_non_rf2  : num  2.83 3.31 3.59 3.94 3.94 ... #>  $ est_rf1      : num  -0.296138 -0.197484 -0.09883 -0.000177 0.098477 ... #>  $ est_rf2      : num  0.368 0.398 0.428 0.459 0.489 ... #>  $ omega_s1     : num  -0.00543 0.09317 0.19178 0.29039 0.38899 ... #>  $ omega_s2     : num  0.108 0.119 0.129 0.139 0.15 ... #>  $ epsilon_st1  : num  -0.291 -0.291 -0.291 -0.291 -0.291 ... #>  $ epsilon_st2  : num  0.26 0.28 0.299 0.319 0.339 ... p2 <- predict(fit_dg, newdata = grid_yrs, return_tmb_object = TRUE) ind_dg <- get_index(p2, bias_correct = FALSE) visreg_delta(fit_dg, xvar = \"depth\", model = 1, gg = TRUE) #> These are residuals for delta model component 1. Use the `model` argument to #> select the other component. #> Warning: `aes_string()` was deprecated in ggplot2 3.0.0. #> ℹ Please use tidy evaluation idioms with `aes()`. #> ℹ See also `vignette(\"ggplot2-in-packages\")` for more information. #> ℹ The deprecated feature was likely used in the visreg package. #>   Please report the issue at <https://github.com/pbreheny/visreg/issues>. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead. #> ℹ The deprecated feature was likely used in the ggplot2 package. #>   Please report the issue at <https://github.com/tidyverse/ggplot2/issues>. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. visreg_delta(fit_dg, xvar = \"depth\", model = 2, gg = TRUE) simulations <- simulate(fit_dg, nsim = 5, seed = 5090, model = NA)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/delta-models.html","id":"delta-models-by-fitting-two-components-separately-and-combining-predictions","dir":"Articles","previous_headings":"","what":"Delta models by fitting two components separately and combining predictions","title":"Fitting delta (hurdle) models with sdmTMB","text":"Next, show example implement delta-gamma model sdmTMB, component fit separately combined. approach gives maximum flexibility model lets develop time. limitations calculating index abundance want share parameters. necessary use mesh models, one can updating first mesh match reduced data frame shown : delta-gamma model similar Tweedie model Intro modelling sdmTMB vignette, except use s() depth effect. One can use different covariates model, case just let depth effect wiggly specifying k = 3. Next, need way combining predictions across two models. need point predictions, can just multiply predictions two models applying inverse link: measure uncertainty required, can simulate joint parameter precision matrix using predict() function number simulations selected (e.g., sims = 500). predictions come simulated draws parameter covariance matrix, predictions become consistent larger number draws. However, greater number draws takes longer calculate use memory (larger matrix), fewer draws (~100) may fine experimentation. larger number (say ~1000) may appropriate final model runs. p_combined_sim matrix row row data predicted width nsim. can process matrix however like. can save median predictions upper lower 95% confidence intervals:   can calculate spatial uncertainty:","code":"glimpse(pcod) #> Rows: 2,143 #> Columns: 12 #> $ year          <int> 2003, 2003, 2003, 2003, 2003, 2003, 2003, 2003, 2003, 20… #> $ X             <dbl> 446.4752, 446.4594, 448.5987, 436.9157, 420.6101, 417.71… #> $ Y             <dbl> 5793.426, 5800.136, 5801.687, 5802.305, 5771.055, 5772.2… #> $ depth         <dbl> 201, 212, 220, 197, 256, 293, 410, 387, 285, 270, 381, 1… #> $ density       <dbl> 113.138476, 41.704922, 0.000000, 15.706138, 0.000000, 0.… #> $ present       <dbl> 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #> $ lat           <dbl> 52.28858, 52.34890, 52.36305, 52.36738, 52.08437, 52.094… #> $ lon           <dbl> -129.7847, -129.7860, -129.7549, -129.9265, -130.1586, -… #> $ depth_mean    <dbl> 5.155194, 5.155194, 5.155194, 5.155194, 5.155194, 5.1551… #> $ depth_sd      <dbl> 0.4448783, 0.4448783, 0.4448783, 0.4448783, 0.4448783, 0… #> $ depth_scaled  <dbl> 0.3329252, 0.4526914, 0.5359529, 0.2877417, 0.8766077, 1… #> $ depth_scaled2 <dbl> 0.11083919, 0.20492947, 0.28724555, 0.08279527, 0.768440… mesh1 <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 20) # coarse for vignette speed dat2 <- subset(pcod, density > 0) mesh2 <- make_mesh(dat2,   xy_cols = c(\"X\", \"Y\"),   mesh = mesh1$mesh ) m1 <- sdmTMB(   formula = present ~ 0 + as.factor(year) + s(depth, k = 3),   data = pcod,   mesh = mesh1,   time = \"year\", family = binomial(link = \"logit\"),   spatiotemporal = \"iid\",   spatial = \"on\" ) m1 #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: present ~ 0 + as.factor(year) + s(depth, k = 3) #> Mesh: mesh1 (isotropic covariance) #> Time column: year #> Data: pcod #> Family: binomial(link = 'logit') #>   #> Conditional model: #>                     coef.est coef.se #> as.factor(year)2003    -0.76    0.42 #> as.factor(year)2004    -0.40    0.42 #> as.factor(year)2005    -0.42    0.42 #> as.factor(year)2007    -1.40    0.42 #> as.factor(year)2009    -1.16    0.42 #> as.factor(year)2011    -1.56    0.42 #> as.factor(year)2013    -0.38    0.42 #> as.factor(year)2015    -0.65    0.42 #> as.factor(year)2017    -1.56    0.42 #> sdepth                 -5.66    0.50 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)      85.9 #>  #> Matérn range: 28.70 #> Spatial SD: 1.89 #> Spatiotemporal IID SD: 0.90 #> ML criterion at convergence: 1054.414 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. m2 <- sdmTMB(   formula = density ~ 0 + as.factor(year) + s(depth),   data = dat2,   mesh = mesh2,   time = \"year\",   family = Gamma(link = \"log\"),   spatiotemporal = \"iid\",   spatial = \"on\" ) m2 #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ 0 + as.factor(year) + s(depth) #> Mesh: mesh2 (isotropic covariance) #> Time column: year #> Data: dat2 #> Family: Gamma(link = 'log') #>   #> Conditional model: #>                     coef.est coef.se #> as.factor(year)2003     4.06    0.20 #> as.factor(year)2004     4.22    0.20 #> as.factor(year)2005     4.19    0.20 #> as.factor(year)2007     3.38    0.20 #> as.factor(year)2009     3.71    0.21 #> as.factor(year)2011     4.51    0.21 #> as.factor(year)2013     4.02    0.19 #> as.factor(year)2015     4.13    0.20 #> as.factor(year)2017     3.84    0.22 #> sdepth                 -0.28    0.36 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)      1.89 #>  #> Dispersion parameter: 0.94 #> Matérn range: 0.01 #> Spatial SD: 727.41 #> Spatiotemporal IID SD: 2065.26 #> ML criterion at convergence: 5102.136 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. #>  #> **Possible issues detected! Check output of sanity().** pred <- grid_yrs # use the grid as template for saving our predictions p_bin <- predict(m1, newdata = grid_yrs) p_pos <- predict(m2, newdata = grid_yrs) p_bin_prob <- m1$family$linkinv(p_bin$est) p_pos_exp <- m2$family$linkinv(p_pos$est) pred$est_exp <- p_bin_prob * p_pos_exp set.seed(28239) p_bin_sim <- predict(m1, newdata = grid_yrs, nsim = 100) p_pos_sim <- predict(m2, newdata = grid_yrs, nsim = 100) p_bin_prob_sim <- m1$family$linkinv(p_bin_sim) p_pos_exp_sim <- m2$family$linkinv(p_pos_sim) p_combined_sim <- p_bin_prob_sim * p_pos_exp_sim pred$median <- apply(p_combined_sim, 1, median) plot(pred$est_exp, pred$median) ggplot(subset(pred, year == 2017), aes(X, Y, fill = median)) +   geom_raster() +   coord_fixed() +   scale_fill_viridis_c(trans = \"sqrt\") pred$cv <- apply(p_combined_sim, 1, function(x) sd(x) / mean(x)) ggplot(subset(pred, year == 2017), aes(X, Y, fill = cv)) + # 2017 as an example   geom_raster() +   coord_fixed() +   scale_fill_viridis_c(trans = \"log10\")"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/forecasting.html","id":"forecasting-predicting-for-future-time-and-interpolating-over-missed-time-slices","dir":"Articles","previous_headings":"","what":"Forecasting: predicting for future time and interpolating over missed time slices","title":"Forecasting with sdmTMB","text":"Predicting future time interpolating missed time requires similar method, cover . forecast time, either future missed time, need model time. example, can’t predict years factors model won’t know value assign years without data. options including time model include: AR(1) random walk random fields Random walk intercepts Smoothers time variable (e.g., s(year)) Ignoring time (fixed) combination use Pacific cod data show implement options. First, need make mesh. Next, need create list years want forecast interpolate. DFO survey region includes years 2003, 2004, 2005, 2007, 2009, 2011, 2013, 2015, 2017. use model fill Pacific cod density unsampled years, create list years want added fill 2003–2017. predict future years, also add years observed data (.e., 2017) however many years want forecast future. example, predict years 2018–2025. name vector extra years extra_years. , fit model Pacific cod density includes depth variables. argument extra_time sdmTMB() function add interpolation forecasting. also need set argument time time = \"year\". example, choose turn spatial random fields (spatial = \"\"), including spatiotemporal random fields. different options including time model.","code":"mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 20) data <- pcod years <- unique(data$year) extra_years <- c(   2006, 2008, 2010, 2012, 2014, 2016, # missing years   2018:2025 # predicted future years )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/forecasting.html","id":"ar1-spatiotemporal-field","dir":"Articles","previous_headings":"Forecasting: predicting for future time and interpolating over missed time slices","what":"AR(1) spatiotemporal field","title":"Forecasting with sdmTMB","text":"include spatiotemporal variation AR(1) process, can specify spatiotemporal = \"AR1\":","code":"fit_ar1 <- sdmTMB(   density ~ depth_scaled + depth_scaled2,   time = \"year\",   extra_time = extra_years, #<< our list of extra years to be included   spatiotemporal = \"AR1\", #<< setting an AR(1) spatiotemporal process   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   spatial = \"off\",   silent = FALSE #< monitor progress )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/forecasting.html","id":"random-walk-spatiotemporal-field","dir":"Articles","previous_headings":"Forecasting: predicting for future time and interpolating over missed time slices","what":"Random walk spatiotemporal field","title":"Forecasting with sdmTMB","text":", can set spatiotemporal variation random walk spatiotemporal = \"RW\":","code":"fit_rw <- sdmTMB(   density ~ depth_scaled + depth_scaled2,   time = \"year\",   extra_time = extra_years, #<<   spatiotemporal = \"RW\", #<<   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   spatial = \"off\",   silent = FALSE )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/forecasting.html","id":"random-walk-intercept-ar1-fields","dir":"Articles","previous_headings":"Forecasting: predicting for future time and interpolating over missed time slices","what":"Random walk intercept + AR(1) fields","title":"Forecasting with sdmTMB","text":"can also model intercept random walk removing intercept main formula (adding 0 model equation) including argument time_varying = ~1:","code":"fit_rw_ar1 <- sdmTMB(   density ~ 0 + depth_scaled + depth_scaled2, #<< remove intercept with 0   time = \"year\",   time_varying = ~1, #<< instead include the intercept here as a random walk   extra_time = extra_years,   spatiotemporal = \"AR1\", #<<   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   spatial = \"off\",   silent = FALSE )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/forecasting.html","id":"smoother-on-year-ar1-fields","dir":"Articles","previous_headings":"Forecasting: predicting for future time and interpolating over missed time slices","what":"Smoother on year + AR(1) fields","title":"Forecasting with sdmTMB","text":"can also add smoother year variable model equation s(year) model equation keeping spatiotemporal=\"AR1\":","code":"fit_sm <- sdmTMB(   density ~ s(year, k = 5) + depth_scaled + depth_scaled2, #<< add smoother on year   time = \"year\",   extra_time = extra_years, #<<   spatiotemporal = \"AR1\", #<<   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   spatial = \"off\",   silent = FALSE )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/forecasting.html","id":"deciding-between-methods","dir":"Articles","previous_headings":"Forecasting: predicting for future time and interpolating over missed time slices","what":"Deciding between methods","title":"Forecasting with sdmTMB","text":"deciding method (AR(1), RW, etc) use including time model, important know AR(1) field processes revert towards mean Random walk processes (mean time varying parameters) revert towards mean Smoothers used caution, continue whatever basis functions Uncertainties prediction random walks, AR(1) processes, smoothers (, p-splines) increase away get data","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/forecasting.html","id":"project-function-for-faster-long-term-forecasting","dir":"Articles","previous_headings":"","what":"`project()`` function for faster long-term forecasting","title":"Forecasting with sdmTMB","text":"forecasting can slow—especially large datasets projections far future, sdmTMB also includes project() function projections via simulations. Using built-dogfish dataset, ’ll first define years historical (fitting) projection period. based approach first developed project_model() function VAST. Next, ’ll fit model. ’ll use AR(1) spatiotemporal field responsible future forecasts. Finally, ’ll projections. ’ll use 20 draws speed simplicity, increase real-world applications stable results. object now contains two objects: $est $epsilon_est, dimensions number rows prediction data (proj_grid) (rows) number draws example (n = 20) (columns). first (est) predictions (link space) second (epsilon_est) spatiotemporal random effects. can summarized visualized several ways show trends mean, well confidence intervals. example, projections:  See help file ?sdmTMB::project additional examples.","code":"mesh <- make_mesh(dogfish, c(\"X\", \"Y\"), cutoff = 30) historical_years <- 2004:2022 to_project <- 5 future_years <- seq(max(historical_years) + 1, max(historical_years) + to_project) all_years <- c(historical_years, future_years) proj_grid <- replicate_df(wcvi_grid, \"year\", all_years) fit <- sdmTMB(   catch_weight ~ 1,   time = \"year\",   offset = log(dogfish$area_swept),   extra_time = historical_years, #< does *not* include projection years   spatial = \"on\",   spatiotemporal = \"ar1\",   data = dogfish,   mesh = mesh,   family = tweedie(link = \"log\") ) set.seed(1) out <- project(fit, newdata = proj_grid, nsim = 20) proj_grid$est_mean <- apply(out$est, 1, mean) ggplot(subset(proj_grid, year > 2022), aes(X, Y, fill = est_mean)) +   geom_raster() +   facet_wrap(~year) +   coord_fixed() +   scale_fill_viridis_c() +   ggtitle(\"Projection simulation (mean)\")"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/forecasting.html","id":"interpolating-in-space-to-unsampled-areas","dir":"Articles","previous_headings":"","what":"Interpolating in space to unsampled areas","title":"Forecasting with sdmTMB","text":"can also interpolate predicted values unsampled areas within geographic extent data. example, use data locations 3605 trees 1000 500 m rectangular sampling region spatst.data package First create data frame x y coordinates tree dataset, can map locations:  first re-format data create density observations. re-scale x y coordinates, using size scale value control resolution (.e., increasing scale value decrease resolution). can add column data frame tree density adding number trees location created scale function. , create mesh can visualize plotting.  , can fit model tree density, intercept one time slice Next, can predict unsampled areas within geographic extent data. first expand grid adding x y coordinates existing coordinates dataset. , add points intervals 5 x y. value controls resolution predicted data. Increasing value decrease resolution spatial predictions. example, include se_fit = TRUE predict function generate standard errors, though can slow computation time. can map predicted tree density interpolated points compared locations data see increased resolution forecasting method  can also use add argument nsim = 200 predicting summarize predicted densities simulations matrix  can also visualize uncertainty forecasts mapping standard error predicted densities point space. see uncertainty higher vertices. fewer neighbors, e.g. tutorial","code":"dat <- data.frame(   x = spatstat.data::bei$x,   y = spatstat.data::bei$y ) ggplot(dat, aes(x, y)) +   geom_point(col = \"darkblue\", alpha = 0.1) +   coord_cartesian(expand = FALSE) # scale controls resolution scale <- 50 dat$x <- scale * floor(dat$x / scale) dat$y <- scale * floor(dat$y / scale)  dat <- dplyr::group_by(dat, x, y) %>%   dplyr::summarise(n = n())  mesh <- make_mesh(   dat,   xy_cols = c(\"x\", \"y\"),   cutoff = 80 # min. distance between knots in X-Y units ) plot(mesh) fit <- sdmTMB(n ~ 1,   data = dat,   mesh = mesh,   family = truncated_nbinom2(link = \"log\"), ) # makes all combinations of x and y: newdf <- expand.grid(   x = seq(min(dat$x), max(dat$x), 5),   y = seq(min(dat$y), max(dat$y), 5) ) p <- predict(fit, newdata = newdf)  ggplot(p, aes(x, y)) +   geom_raster(data = p, aes(x, y, fill = est)) +   geom_point(data = dat, aes(x, y)) +   labs(fill = \"tree density\") +   scale_fill_viridis_c() p2 <- predict(fit, newdata = newdf, nsim = 200) newdf$p2 <- apply(p2, 1, mean) ggplot(newdf, aes(x, y)) +   geom_raster(data = newdf, aes(x, y, fill = p2)) +   geom_point(data = dat, aes(x, y)) +   labs(fill = \"tree density\") +   scale_fill_viridis_c() newdf$est_se <- apply(p2, 1, sd) ggplot() +   geom_raster(data = newdf, aes(x = x, y = y, fill = est_se)) +   coord_equal() +   labs(col = \"Standard error\\nof spatiotemporal field\") +   scale_fill_viridis_c(option = \"D\") #> Ignoring unknown labels: #> • colour : \"Standard error of spatiotemporal field\""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/forecasting.html","id":"extrapolating-outside-the-survey-domain","dir":"Articles","previous_headings":"Interpolating in space to unsampled areas","what":"Extrapolating outside the survey domain","title":"Forecasting with sdmTMB","text":"can also extrapolate spatially outside geographic extent data (ensuring extrapolating outside extent mesh!) instance, can predict border area. , expand x y coordinates values extent coordinates data. , expand geographic domain 100 directions, keep resolution 5. , can use model fit predict expanded geographic domain.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/ggeffects.html","id":"example-with-pacific-cod-presence","dir":"Articles","previous_headings":"","what":"Example with Pacific cod presence","title":"Visualizing marginal effects in sdmTMB models with ggeffects","text":"start, use Pacific cod example data. fit model fish presence/absence covariates depth fixed effect year using Tweedie distribution. can use ggeffects::ggeffect() see effect depth probability Pacific cod present. can control range interval depths predicted within function (e.g. [0:500 =1]).  can also plot effects year.  can add data points  can also use ggeffect plot multiple variables listing terms = c(), first term listed indicating variable plotted x-axis, remaining listed terms (four total) indicating groups. Adding facet = TRUE show year separate plot, instead overlain one plot.  Adding facet = TRUE show year separate plot, instead overlain one plot.  can also use make ggplot plot calling ggeffects object dat data frame.  Plotting using continuous response (density) rather presence-similar. instance: can fit model interaction two continuous variables: plotting two continuous variables, ggeffect() make non-target (2nd) variable discrete selecting different levels.   specify levels rather letting ggeffect() choose , use brackets selected values within term list, instance","code":"pcod$fyear <- as.factor(pcod$year) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 20) fit <- sdmTMB(present ~ poly(depth, 2) + fyear,   data = pcod,   mesh = mesh,   spatial = \"on\",   family = binomial() ) g <- ggeffect(fit, \"depth [0:500 by=1]\") plot(g) g2 <- ggeffect(fit, \"fyear\") plot(g2) plot(g, show_data = TRUE) #> Data points may overlap. Use the `jitter` argument to add some amount of #>   random variation to the location of data points and avoid overplotting. dat <- ggeffect(fit, terms = c(\"depth [0:350 by=5]\", \"fyear\")) plot(dat) plot(dat, facet = TRUE) ggplot(dat, aes(x, predicted, colour = group)) +   geom_line() g5 <- ggeffect(fit3, terms = c(\"depth_scaled [-3:2.7 by=0.01]\", \"numeric_year\")) plot(g5) plot(g5, facet = TRUE) g6 <- ggeffect(fit3, terms = c(\"depth_scaled [-3:2.7 by=0.01]\", \"numeric_year [1,7,15]\")) plot(g6)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/ggeffects.html","id":"ggpredict","dir":"Articles","previous_headings":"","what":"ggpredict()","title":"Visualizing marginal effects in sdmTMB models with ggeffects","text":"ggeffects::ggpredict() can used make conditional effects plots sdmTMB models, including models smoothers (currently including delta models due recent change ggeffects). ’s example:    can extract data make plot:","code":"pcod$fyear <- as.factor(pcod$year) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 20) fit <- sdmTMB(present ~ s(depth) + fyear,   data = pcod,   mesh = mesh,   spatial = \"on\",   family = binomial() ) g <- ggpredict(fit, \"depth [0:400 by=2]\") #> Model contains splines or polynomial terms. Consider using `terms=\"depth #>   [all]\"` to get smooth plots. See also package-vignette 'Adjusted #>   Predictions at Specific Values'. plot(g) g <- ggpredict(fit, terms = c(\"depth [0:350 by=5]\", \"fyear\")) #> Model contains splines or polynomial terms. Consider using `terms=\"depth #>   [all]\"` to get smooth plots. See also package-vignette 'Adjusted #>   Predictions at Specific Values'. plot(g) plot(g, facet = TRUE) df <- as.data.frame(g) glimpse(df) #> Rows: 639 #> Columns: 6 #> $ x         <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 10… #> $ predicted <dbl> 0.007356842, 0.011520076, 0.011879286, 0.004558189, 0.006096… #> $ std.error <dbl> 1.385601, 1.380047, 1.381375, 1.384950, 1.382717, 1.381915, … #> $ conf.low  <dbl> 0.0004900719, 0.0007788444, 0.0008013158, 0.0003032307, 0.00… #> $ conf.high <dbl> 0.10074152, 0.14839641, 0.15270207, 0.06465746, 0.08441030, … #> $ group     <fct> 2003, 2004, 2005, 2007, 2009, 2011, 2013, 2015, 2017, 2003, … ggplot(df, aes(   x, predicted,   ymin = conf.low,   ymax = conf.high,   colour = group, fill = group )) +   geom_ribbon(alpha = 0.4, colour = NA) +   geom_line() +   facet_wrap(vars(group)) +   labs(x = \"Depth (m)\", y = \"Predicted\", colour = \"Year\", fill = \"Year\")"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"sdmTMB model description","text":"vignette describes statistical model underlying sdmTMB. details available sdmTMB paper (Anderson et al. 2024), referenced cited using sdmTMB publication.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"other-vignettes-available","dir":"Articles","previous_headings":"","what":"Other vignettes available","title":"sdmTMB model description","text":"vignette viewed CRAN, note many vignettes describing use sdmTMB available documentation site Articles.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"notation-conventions","dir":"Articles","previous_headings":"","what":"Notation conventions","title":"sdmTMB model description","text":"appendix uses following notation conventions, generally follow guidance Edwards & Auger-Méthé (2019): Greek symbols parameters, Latin/Roman alphabet data except cases another symbol used convention, bold symbols vectors matrices (e.g., 𝛚\\boldsymbol{\\omega} vector ω𝐬\\omega_{\\mathbf{s}} value 𝛚\\boldsymbol{\\omega} point space 𝐬\\mathbf{s}), Latin/Roman symbols non-italics (e.g., 𝐗\\mathbf{X}, 𝐐\\mathbf{Q}), ϕ\\phi distribution dispersion parameters consistency code, 𝔼[y]\\mathbb{E}[y] define expected value (mean) variable yy, Var[y]\\mathrm{Var}[y] define expected variance variable yy, *^* superscript represents interpolated projected values opposed values knot locations (e.g., 𝛚\\boldsymbol{\\omega} vs. 𝛚*\\boldsymbol{\\omega}^*), possible, notation chosen match VAST (Thorson 2019) maintain consistency (e.g., 𝛚\\boldsymbol{\\omega} spatial fields 𝛜t\\boldsymbol{\\epsilon}_t spatiotemporal fields). Tables indices symbols summarized notation reference tables end vignette.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"sdmtmb-model-structure","dir":"Articles","previous_headings":"","what":"sdmTMB model structure","title":"sdmTMB model description","text":"complete sdmTMB model can written η𝐬,t=𝐗𝐬,tmain𝛃+O𝐬,t+𝐙g𝐛g+𝐗𝐬,ttvc𝛄t+𝐗𝐬,tsvc𝛇𝐬+ω𝐬+ϵ𝐬,t,μ𝐬,t=f−1(η𝐬,t),𝔼[y𝐬,t]=μ𝐬,t, \\begin{aligned} \\eta_{\\mathbf{s},t} &= \\mathbf{X}^{\\mathrm{main}}_{\\mathbf{s},t} \\boldsymbol{\\beta}+ O_{\\mathbf{s},t} + \\mathbf{Z}_{g} \\mathbf{b}_{g} + \\mathbf{X}^{\\mathrm{tvc}}_{\\mathbf{s},t} \\boldsymbol{\\gamma}_{t} + \\mathbf{X}^{\\mathrm{svc}}_{\\mathbf{s},t} \\boldsymbol{\\zeta}_{\\mathbf{s}} + \\omega_{\\mathbf{s}} + \\epsilon_{\\mathbf{s},t},\\\\ \\mu_{\\mathbf{s},t} &= f^{-1} \\left( \\eta_{\\mathbf{s},t} \\right),\\\\ \\mathbb{E}[y_{\\mathbf{s},t}] &= \\mu_{\\mathbf{s},t}, \\end{aligned} y𝐬,ty_{\\mathbf{s},t} represents response data point 𝐬\\mathbf{s} time tt; η\\eta represents linear predictor (.e., link space) μ\\mu represents conditional mean response/data scale (applying inverse link); ff represents link function (e.g., log logit) f−1f^{-1} represents inverse, η\\eta represents linear predictor applying f−1f^{-1}; 𝐗main\\mathbf{X}^{\\mathrm{main}}, 𝐗tvc\\mathbf{X}^{\\mathrm{tvc}}, 𝐗svc\\mathbf{X}^{\\mathrm{svc}} represent design matrices (superscript identifiers ‘main’ = main effects, ‘tvc’ = time varying coefficients, ‘svc’ = spatially varying coefficients); 𝛃\\boldsymbol{\\beta} represents vector fixed-effect coefficients; O𝐬,tO_{\\mathbf{s},t} represents offset: covariate (usually log transformed) coefficient fixed one enters linear predictor scale (inverse link); 𝐙g\\mathbf{Z}_{g} represents random-effect design row(s) group gg (subset matrix 𝐙\\mathbf{Z}) corresponding 𝐛g\\mathbf{b}_{g}; random effects enter linear predictor scale; scalar special case random intercept αg∼N(0,σα2)\\alpha_{g}\\sim \\mathrm{N}(0,\\sigma_\\alpha^2), generally random slopes intercepts vector-valued full covariance described ; 𝛄t\\boldsymbol{\\gamma}_{t} represents vector time-varying coefficients, coefficient γp,t\\gamma_{p,t} can follow random walk AR(1) process; 𝛇𝐬\\boldsymbol{\\zeta}_{\\mathbf{s}} represents vector spatially varying coefficients (random fields), coefficient ζl,𝐬∼MVN(𝟎,𝚺ζ,l)\\zeta_{l,\\mathbf{s}} \\sim \\mathrm{MVN}(\\boldsymbol{0},\\boldsymbol{\\Sigma}_{\\zeta,l}); ω𝐬\\omega_{\\mathbf{s}} represents spatial component (Gaussian Markov random field, GMRF), ω𝐬∼MVN(𝟎,𝚺ω)\\omega_{\\mathbf{s}} \\sim \\mathrm{MVN}(\\boldsymbol{0},\\boldsymbol{\\Sigma}_\\omega) Matérn covariance built mesh; ϵ𝐬,t\\epsilon_{\\mathbf{s},t} represents spatiotemporal component (GMRF), ϵ𝐬,t∼MVN(𝟎,𝚺ϵ)\\epsilon_{\\mathbf{s},t} \\sim \\mathrm{MVN}(\\boldsymbol{0},\\boldsymbol{\\Sigma}_{\\epsilon}) Matérn covariance space temporal evolution specified. single sdmTMB model rarely, ever, contain components. Next, split model describe various parts detail using ‘…\\ldots’ represent optional components.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"main-effects","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Main effects","title":"sdmTMB model description","text":"μ𝐬,t=f−1(𝐗𝐬,tmain𝛃+…) \\begin{aligned} \\mu_{\\mathbf{s},t} &= f^{-1} \\left( \\mathbf{X}^{\\mathrm{main}}_{\\mathbf{s},t} \\boldsymbol{\\beta}+ \\ldots \\right) \\end{aligned} Within sdmTMB(), 𝐗𝐬,tmain𝛃\\mathbf{X}^{\\mathrm{main}}_{\\mathbf{s},t} \\boldsymbol{\\beta} defined formula argument represents main-effect model matrix corresponding vector coefficients. main effect formula can contain optional penalized smoothers non-linear functions defined .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"smoothers","dir":"Articles","previous_headings":"sdmTMB model structure > Main effects","what":"Smoothers","title":"sdmTMB model description","text":"Smoothers sdmTMB implemented formula syntax familiar mgcv (Wood 2017) users fitting GAMs (generalized additive models). Smooths implemented formula using + s(x), implements smooth mgcv::s(). Within smooths, syntax commonly used mgcv::s() can applied, e.g. 2-dimensional smooths may constructed + s(x, y); smooths can specific various factor levels, + s(x, = group); smooths can vary according continuous variable, + s(x, = x2); basis function dimensions may specified, e.g. + s(x, k = 4) (see ?mgcv::choose.k); various types splines may constructed cyclic splines model seasonality, e.g. + s(month, bs = \"cc\", k = 12). mgcv can fit unpenalized (e.g., B-splines) penalized splines (P-splines), sdmTMB implements penalized splines. penalized splines constructed sdmTMB using function mgcv::smooth2random(), transforms splines random effects (associated design matrices) estimable mixed-effects modelling framework. approach implemented R packages gamm4 (Wood & Scheipl 2020) brms (Bürkner 2017).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"linear-break-point-threshold-models","dir":"Articles","previous_headings":"sdmTMB model structure > Main effects","what":"Linear break-point threshold models","title":"sdmTMB model description","text":"linear break-point “hockey stick” model can used describe threshold asymptotic responses. function consists two pieces, x<b1x < b_{1}, s(x)=x⋅b0s(x) = x \\cdot b_{0}, x>b1x > b_{1}, s(x)=b1⋅b0s(x) = b_{1} \\cdot b_{0}. cases, b0b_{0} represents slope function threshold, product b1⋅b0b_{1} \\cdot b_{0} represents value asymptote. constraints placed parameters b0b_{0} b1b_{1}. models can fit including + breakpt(x) model formula, x covariate. formula can contain single break-point covariate.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"logistic-threshold-models","dir":"Articles","previous_headings":"sdmTMB model structure > Main effects","what":"Logistic threshold models","title":"sdmTMB model description","text":"Models logistic threshold relationships predictor response can fit form s(x)=τ+ψ[1+e−ln(19)⋅(x−s50)/(s95−s50)]−1, s(x)=\\tau + \\psi\\ { \\left[ 1+{ e }^{ -\\ln \\left(19\\right) \\cdot \\left( x-s50 \\right)      / \\left(s95 - s50 \\right) } \\right] }^{-1}, ss represents logistic function, ψ\\psi scaling parameter (controlling height y-axis response; unconstrained), τ\\tau intercept, s50s50 parameter controlling point function reaches 50% maximum (ψ\\psi), s95s95 parameter controlling point function reaches 95% maximum. parameter s50s50 unconstrained s95s95 constrained larger s50s50. models can fit including + logistic(x) model formula, x covariate. formula can contain single logistic covariate.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"spatial-random-fields","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Spatial random fields","title":"sdmTMB model description","text":"Spatial random fields, ω𝐬\\omega_{\\mathbf{s}}, included spatial = '' (TRUE) omitted spatial = '' (FALSE). μ𝐬,t=f−1(…+ω𝐬+…),𝛚∼MVNormal(𝟎,𝚺ω), \\begin{aligned} \\mu_{\\mathbf{s},t} &= f^{-1} \\left( \\ldots + \\omega_{\\mathbf{s}} + \\ldots \\right),\\\\ \\boldsymbol{\\omega}&\\sim \\mathrm{MVNormal} \\left( \\boldsymbol{0}, \\boldsymbol{\\Sigma}_\\omega \\right),\\\\ \\end{aligned}  marginal standard deviation 𝛚\\boldsymbol{\\omega} indicated Spatial SD printed model output sigma_O output sdmTMB::tidy(fit, \"ran_pars\"). ‘O’ ‘omega’ (ω\\omega). Internally, random fields follow Gaussian Markov random field (GMRF) 𝛚∼MVNormal(𝟎,σω2𝐐ω−1), \\boldsymbol{\\omega}\\sim \\mathrm{MVNormal}\\left(\\boldsymbol{0}, \\sigma_\\omega^2 \\mathbf{Q}^{-1}_\\omega\\right),  𝐐ω\\mathbf{Q}_\\omega sparse precision matrix σω2\\sigma_\\omega^2 marginal variance.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"spatiotemporal-random-fields","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Spatiotemporal random fields","title":"sdmTMB model description","text":"Spatiotemporal random fields included default multiple time elements (time argument NULL) can set IID (independent identically distributed, 'iid'; default), AR(1) ('ar1'), random walk ('rw'), ('') via spatiotemporal argument. text values case insensitive. Spatiotemporal random fields represented 𝛜t\\boldsymbol{\\epsilon}_t within sdmTMB. chosen match representation VAST (Thorson 2019). marginal standard deviation 𝛜t\\boldsymbol{\\epsilon}_t indicated Spatiotemporal SD printed model output sigma_E output sdmTMB::tidy(fit, \"ran_pars\"). ‘E’ ‘epsilon’ (ϵ\\epsilon).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"iid-spatiotemporal-random-fields","dir":"Articles","previous_headings":"sdmTMB model structure > Spatiotemporal random fields","what":"IID spatiotemporal random fields","title":"sdmTMB model description","text":"IID spatiotemporal random fields (spatiotemporal = 'iid') can represented μ𝐬,t=f−1(…+ϵ𝐬,t+…),𝛜t∼MVNormal(𝟎,𝚺ϵ). \\begin{aligned} \\mu_{\\mathbf{s},t} &= f^{-1} \\left( \\ldots + \\epsilon_{\\mathbf{s},t} + \\ldots \\right),\\\\ \\boldsymbol{\\epsilon}_{t} &\\sim \\mathrm{MVNormal} \\left( \\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\epsilon} \\right). \\end{aligned} ϵ𝐬,t\\epsilon_{\\mathbf{s},t} represent random field deviations point 𝐬\\mathbf{s} time tt. random fields assumed independent across time steps. Similarly spatial random fields, spatiotemporal random fields (including versions described ) parameterized internally sparse precision matrix (𝐐ϵ\\mathbf{Q}_\\epsilon) 𝛜t∼MVNormal(𝟎,σϵ2𝐐ϵ−1). \\boldsymbol{\\epsilon}_{t} \\sim \\mathrm{MVNormal}\\left(\\boldsymbol{0}, \\sigma_\\epsilon^2 \\mathbf{Q}^{-1}_\\epsilon\\right).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"ar1-spatiotemporal-random-fields","dir":"Articles","previous_headings":"sdmTMB model structure > Spatiotemporal random fields","what":"AR(1) spatiotemporal random fields","title":"sdmTMB model description","text":"First-order auto regressive, AR(1), spatiotemporal random fields (spatiotemporal = 'ar1') add parameter defining correlation random field deviations one time step next. defined μ𝐬,t=f−1(…+δ𝐬,t+…),𝛅t=1∼MVNormal(𝟎,𝚺ϵ),𝛅t>1=ρ𝛅t−1+1−ρ2𝛜t,𝛜t∼MVNormal(𝟎,𝚺ϵ), \\begin{aligned} \\mu_{\\mathbf{s},t} &= f^{-1} \\left( \\ldots + \\delta_{\\mathbf{s},t} + \\ldots \\right),\\\\ \\boldsymbol{\\delta}_{t=1} &\\sim \\mathrm{MVNormal} (\\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\epsilon}),\\\\ \\boldsymbol{\\delta}_{t>1} &= \\rho \\boldsymbol{\\delta}_{t-1} + \\sqrt{1 - \\rho^2} \\boldsymbol{\\epsilon}_{t},  \\: \\boldsymbol{\\epsilon}_{t} \\sim \\mathrm{MVNormal} \\left(\\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\epsilon} \\right), \\end{aligned}  ρ\\rho correlation subsequent spatiotemporal random fields. ρ𝛅t−1+1−ρ2\\rho \\boldsymbol{\\delta}_{t-1} + \\sqrt{1 - \\rho^2} term scales spatiotemporal variance correlation represents steady-state marginal variance. correlation ρ\\rho allows mean-reverting spatiotemporal fields, constrained −1<ρ<1-1 < \\rho < 1. Internally, parameter estimated ar1_phi, unconstrained. parameter ar1_phi transformed ρ\\rho ρ=2(logit−1(𝚊𝚛𝟷_𝚙𝚑𝚒))−1\\rho = 2 \\left( \\mathrm{logit}^{-1}(\\texttt{ar1\\_phi}) \\right) - 1, mapping ar1_phi range (−1,1)(-1, 1).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"random-walk-spatiotemporal-random-fields-rw","dir":"Articles","previous_headings":"sdmTMB model structure > Spatiotemporal random fields","what":"Random walk spatiotemporal random fields (RW)","title":"sdmTMB model description","text":"Random walk spatiotemporal random fields (spatiotemporal = 'rw') represent model difference spatiotemporal deviations one time step next IID. defined μ𝐬,t=f−1(…+δ𝐬,t+…),𝛅t=1∼MVNormal(𝟎,𝚺ϵ),𝛅t>1=𝛅t−1+𝛜t,𝛜t∼MVNormal(𝟎,𝚺ϵ), \\begin{aligned} \\mu_{\\mathbf{s},t} &= f^{-1} \\left( \\ldots + \\delta_{\\mathbf{s},t} + \\ldots \\right),\\\\ \\boldsymbol{\\delta}_{t=1} &\\sim \\mathrm{MVNormal} (\\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\epsilon}),\\\\ \\boldsymbol{\\delta}_{t>1} &= \\boldsymbol{\\delta}_{t-1} +  \\boldsymbol{\\epsilon}_{t},  \\: \\boldsymbol{\\epsilon}_{t} \\sim \\mathrm{MVNormal} \\left(\\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\epsilon} \\right), \\end{aligned} distribution spatiotemporal field initial time step AR(1) model, absence ρ\\rho parameter allows spatiotemporal field non-stationary time. Note , contrast AR(1) parametrization, variance longer steady-state marginal variance.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"time-varying-regression-parameters","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Time-varying regression parameters","title":"sdmTMB model description","text":"Parameters can modelled time-varying according random walk first-order autoregressive, AR(1), process. time-series model defined time_varying_type. types: μ𝐬,t=f−1(…+𝐗𝐬,ttvc𝛄t+…), \\begin{aligned}   \\mu_{\\mathbf{s},t} &= f^{-1} \\left( \\ldots +  \\mathbf{X}^{\\mathrm{tvc}}_{\\mathbf{s},t} \\boldsymbol{\\gamma}_{t} + \\ldots \\right), \\end{aligned}  𝛄t\\boldsymbol{\\gamma}_{t} optional vector time-varying regression parameters 𝐗𝐬,ttvc\\mathbf{X}^{\\mathrm{tvc}}_{\\mathbf{s},t} corresponding model matrix covariate values. defined via time_varying argument, assuming time argument also supplied column name. time_varying takes one-sided formula. ~ 1 implies time-varying intercept. following equations describe time-series process single time-varying coefficient γp,t\\gamma_{p,t}, pp indexes time-varying coefficient. multiple time-varying coefficients specified, follows time-series process independently variance σγ,p2\\sigma_{\\gamma,p}^2 (AR1) correlation parameter ργ,p\\rho_{\\gamma,p}. time_varying_type = 'rw', first time step estimated independently: γp,t=1∼Uniform(−∞,∞) (treated unconstrained parameter),γp,t>1∼Normal(γp,t−1,σγ,p2). \\begin{aligned}   \\gamma_{p,t=1} &\\sim \\mathrm{Uniform} \\left(-\\infty, \\infty \\right) \\text{ (treated unconstrained parameter)},\\\\   \\gamma_{p,t>1} &\\sim \\mathrm{Normal} \\left(\\gamma_{p,t-1}, \\sigma_{\\gamma,p}^2 \\right). \\end{aligned} case, first time-step value given implicit uniform prior. .e., variable appear fixed effect formula since initial value estimated part time-varying formula. formula time_varying = ~ 1 implicitly represents time-varying intercept (assuming time argument supplied) , case, intercept omitted main effects (formula ~ + 0 + ... formula ~ -1 + ...). time_varying_type = 'rw0', first time step estimated mean-zero prior: γp,t=1∼Normal(0,σγ,p2),γp,t>1∼Normal(γp,t−1,σγ,p2). \\begin{aligned}   \\gamma_{p,t=1} &\\sim \\mathrm{Normal} \\left(0, \\sigma_{\\gamma,p}^2 \\right),\\\\   \\gamma_{p,t>1} &\\sim \\mathrm{Normal} \\left(\\gamma_{p,t-1}, \\sigma_{\\gamma,p}^2 \\right). \\end{aligned}  case, time-varying variable (including intercept) included main effects. time_varying_type = 'ar1': γp,t=1∼Normal(0,σγ,p2),γp,t>1∼Normal(ργ,pγp,t−1,(1−ργ,p2)σγ,p2), \\begin{aligned}   \\gamma_{p,t=1} &\\sim \\mathrm{Normal} \\left(0, \\sigma_{\\gamma,p}^2 \\right),\\\\   \\gamma_{p,t>1} &\\sim \\mathrm{Normal} \\left(\\rho_{\\gamma,p}\\gamma_{p,t-1}, (1 - \\rho_{\\gamma,p}^2) \\sigma_{\\gamma,p}^2 \\right), \\end{aligned}  ργ,p\\rho_{\\gamma,p} correlation subsequent time steps. first time step given mean-zero prior.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"spatially-varying-coefficients-svc","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Spatially varying coefficients (SVC)","title":"sdmTMB model description","text":"Spatially varying coefficient models defined μ𝐬,t=f−1(…+𝐗𝐬,tsvc𝛇𝐬+…),ζl,𝐬∼MVNormal(𝟎,𝚺ζ,l), \\begin{aligned}   \\mu_{\\mathbf{s},t} &= f^{-1} \\left( \\ldots + \\mathbf{X}^{\\mathrm{svc}}_{\\mathbf{s}, t} \\boldsymbol{\\zeta}_{\\mathbf{s}} + \\ldots \\right),\\\\   \\zeta_{l,\\mathbf{s}} &\\sim \\mathrm{MVNormal} \\left( \\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\zeta,l} \\right), \\end{aligned} ζl,𝐬\\zeta_{l,\\mathbf{s}} represents ll-th spatially varying coefficient field location 𝐬\\mathbf{s}. multiple spatially varying coefficients specified, estimated independent spatial random field marginal variance σζ,l2\\sigma_{\\zeta,l}^2. Usually, 𝐗𝐬,tsvc\\mathbf{X}^{\\mathrm{svc}}_{\\mathbf{s}, t} represent prediction matrix constant spatially given time tt defined one-sided formula supplied spatial_varying. example spatial_varying = ~ 0 + x, 0 omits intercept. random fields parameterized internally sparse precision matrix (𝐐ζ\\mathbf{Q}_\\zeta) ζl,𝐬∼MVNormal(𝟎,σζ,l2𝐐ζ−1). \\zeta_{l,\\mathbf{s}} \\sim \\mathrm{MVNormal}\\left(\\boldsymbol{0}, \\sigma_{\\zeta,l}^2 \\mathbf{Q}^{-1}_\\zeta\\right).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"random-intercepts-and-slopes","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Random intercepts and slopes","title":"sdmTMB model description","text":"Multilevel (hierarchical) intercepts slopes follow familiar lme4/glmmTMB formulation. single grouping factor can carry intercept-term vector random effects (intercept plus slopes) full covariance: μ𝐬,t=f−1(…+𝐙g𝐛g+…),𝐛g∼MVNormal(𝟎,𝚺g), \\begin{aligned}   \\mu_{\\mathbf{s},t} &= f^{-1} \\left( \\ldots + \\mathbf{Z}_{g} \\mathbf{b}_{g} + \\ldots \\right),\\\\   \\mathbf{b}_{g} &\\sim \\mathrm{MVNormal} \\left( \\boldsymbol{0}, \\boldsymbol{\\Sigma}_{g} \\right), \\end{aligned} 𝐙g\\mathbf{Z}_{g} design row(s) group gg (e.g., intercept covariate values) 𝐛g\\mathbf{b}_{g} corresponding vector random effects group. scalar special case (1|g)(1|g) corresponds n=1n=1 αg∼Normal(0,σα2)\\alpha_{g} \\sim \\mathrm{Normal}(0, \\sigma_{\\alpha}^2). Use lme4-style syntax formula, e.g. (1 | g) random intercepts, (1 + x | g) correlated intercepts slopes, (1 | g1) + (1 + x | g2) give grouping factor (co)variance. Internally, standard deviations estimated log scale, correlations represented unconstrained Cholesky parameters (via UNSTRUCTURED_CORR), yielding positive-definite 𝚺g\\boldsymbol{\\Sigma}_{g} per grouping factor.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"offset-terms","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Offset terms","title":"sdmTMB model description","text":"Offset terms can included offset argument sdmTMB(). included linear predictor μ𝐬,t=f−1(…+O𝐬,t+…), \\begin{aligned}   \\mu_{\\mathbf{s},t} &= f^{-1} \\left( \\ldots + O_{\\mathbf{s},t} + \\ldots \\right), \\end{aligned} O𝐬,tO_{\\mathbf{s},t} offset term—log transformed variable without coefficient (assuming log link). offset included prediction. Therefore, offset represents measure effort, example, prediction one unit effort (log(1) = 0).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"observation-model-families","dir":"Articles","previous_headings":"","what":"Observation model families","title":"sdmTMB model description","text":"describe main observation families available sdmTMB comment parametrization, statistical properties, utility, code representation sdmTMB. Families grouped outcome type make easier locate appropriate observation model.","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"binomial","dir":"Articles","previous_headings":"Observation model families > Bounded or binary outcomes (0–1, proportions)","what":"Binomial","title":"sdmTMB model description","text":"Binomial(N,μ) \\operatorname{Binomial} \\left(N, \\mu \\right)  NN size number trials, μ\\mu probability success trial. N=1N = 1, distribution becomes Bernoulli distribution. Internally, distribution parameterized robust version TMB, numerically stable probabilities approach 0 1. Following structure stats::glm(), lme4, glmmTMB, binomial family can specified one 4 ways: response may factor (model classifies first level versus others) response may binomial (0/1) response can matrix form cbind(success, failure), response may observed proportions, weights argument used specify Binomial size (NN) parameter (probability ~ ..., weights = N). Code defined within TMB. Example: family = binomial(link = \"logit\")","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"beta-binomial","dir":"Articles","previous_headings":"Observation model families > Bounded or binary outcomes (0–1, proportions)","what":"Beta-binomial","title":"sdmTMB model description","text":"BetaBinomial(N,μ,ϕ) \\operatorname{BetaBinomial} \\left(N, \\mu, \\phi \\right)  NN number trials, μ\\mu mean success probability, ϕ\\phi precision parameter controls overdispersion relative Binomial. implied Beta parameters α=μϕ\\alpha = \\mu \\phi β=(1−μ)ϕ\\beta = (1 - \\mu)\\phi, variance $ [y] = N (1 - ), , $ exceeds Binomial variance unless ϕ→∞\\phi \\\\infty. Available links logit cloglog. family useful overdispersed counts successes/failures (e.g., aggregated Bernoulli data, proportions extra-binomial variation). Code defined within sdmTMB implemented TMB likelihood src/sdmTMB.cpp (e.g., lines 974–982). Example: family = betabinomial(link = \"logit\")","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"beta","dir":"Articles","previous_headings":"Observation model families > Bounded or binary outcomes (0–1, proportions)","what":"Beta","title":"sdmTMB model description","text":"Beta(μϕ,(1−μ)ϕ) \\operatorname{Beta} \\left(\\mu \\phi, (1 - \\mu) \\phi \\right)  μ\\mu mean ϕ\\phi precision parameter. parametrization follows Ferrari & Cribari-Neto (2004) betareg R package (Cribari-Neto & Zeileis 2010). variance μ(1−μ)/(ϕ+1)\\mu (1 - \\mu) / (\\phi + 1). Code defined within TMB. Example: family = Beta(link = \"logit\")","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"poisson","dir":"Articles","previous_headings":"Observation model families > Count data","what":"Poisson","title":"sdmTMB model description","text":"Poisson(μ) \\operatorname{Poisson} \\left( \\mu \\right)  μ\\mu represents mean Var[y]=μ\\mathrm{Var}[y] = \\mu. Code defined within TMB. Example: family = poisson(link = \"log\")","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"negative-binomial-2-nb2","dir":"Articles","previous_headings":"Observation model families > Count data","what":"Negative Binomial 2 (NB2)","title":"sdmTMB model description","text":"NB2(μ,ϕ) \\operatorname{NB2} \\left( \\mu, \\phi \\right) μ\\mu mean ϕ\\phi dispersion parameter. variance scales quadratically mean Var[y]=μ+μ2/ϕ\\mathrm{Var}[y] = \\mu + \\mu^2 / \\phi(Hilbe 2011). NB2 parametrization commonly seen ecology NB1. Internally, distribution parameterized robust version TMB. Code defined within TMB. Example: family = nbinom2(link = \"log\")","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"negative-binomial-1-nb1","dir":"Articles","previous_headings":"Observation model families > Count data","what":"Negative Binomial 1 (NB1)","title":"sdmTMB model description","text":"NB1(μ,ϕ) \\operatorname{NB1} \\left( \\mu, \\phi \\right) μ\\mu mean ϕ\\phi dispersion parameter. variance scales linearly mean Var[y]=μ+μ/ϕ\\mathrm{Var}[y] = \\mu + \\mu / \\phi(Hilbe 2011). Internally, distribution parameterized robust version TMB. Code defined within sdmTMB based NB2 borrowed glmmTMB. Example: family = nbinom1(link = \"log\")","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"negative-binomial-2-mixture","dir":"Articles","previous_headings":"Observation model families > Count data","what":"Negative binomial 2 mixture","title":"sdmTMB model description","text":"2 component mixture extends NB2 distribution, following mixture-distribution approaches shoaling/aggregation survey data (Thorson et al. 2011). (1−p)⋅NB2(μ1,ϕ)+p⋅NB2(μ2,ϕ) (1 - p) \\cdot \\operatorname{NB2} \\left( \\mu_1, \\phi \\right) + p \\cdot \\operatorname{NB2} \\left( \\mu_2, \\phi \\right) μ1\\mu_1 mean first (smaller component) distribution, μ2\\mu_2 mean larger component, pp controls contribution component mixture. Example: family = nbinom2_mix(link = \"log\")","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"gamma","dir":"Articles","previous_headings":"Observation model families > Positive continuous outcomes","what":"Gamma","title":"sdmTMB model description","text":"Gamma(ϕ,μϕ) \\operatorname{Gamma} \\left( \\phi, \\frac{\\mu}{\\phi}  \\right)  ϕ\\phi represents Gamma shape μ/ϕ\\mu / \\phi represents scale. mean μ\\mu variance μ2/ϕ\\mu^2 / \\phi. Code defined within TMB. Example: family = Gamma(link = \"log\")","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"lognormal","dir":"Articles","previous_headings":"Observation model families > Positive continuous outcomes","what":"Lognormal","title":"sdmTMB model description","text":"sdmTMB uses “bias-corrected” lognormal distribution ϕ\\phi represents standard deviation log-space: Lognormal(logμ−ϕ22,ϕ2). \\operatorname{Lognormal} \\left( \\log \\mu - \\frac{\\phi^2}{2}, \\phi^2 \\right).  bias correction, 𝔼[y]=μ\\mathbb{E}[y] = \\mu Var[logy]=ϕ2\\mathrm{Var}[\\log y] = \\phi^2. Code defined within sdmTMB based TMB dnorm() normal density. Example: family = lognormal(link = \"log\")","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"generalized-gamma","dir":"Articles","previous_headings":"Observation model families > Positive continuous outcomes","what":"Generalized gamma","title":"sdmTMB model description","text":"GenGamma(μ,ϕ,Qgg) \\operatorname{GenGamma} \\left( \\mu, \\phi, Q^{\\mathrm{gg}}\\right) sdmTMB implements Prentice (1974) parameterization introduced spatiotemporal models index standardization Dunic et al. (2025), parameters mean μ\\mu, scale ϕ\\phi (standard deviation log scale), shape parameter QggQ^{\\mathrm{gg}} (reported Generalized gamma Q). , μ\\mu mean data scale, ϕ\\phi log-scale standard deviation, QggQ^{\\mathrm{gg}} controls shape (Qgg→0Q^{\\mathrm{gg}}\\0 yields lognormal; Qgg=ϕQ^{\\mathrm{gg}}= \\phi yields gamma). See Dunic et al. (2025) full PDF Prentice formulation implemented. Links available: identity, log, inverse. flexibility useful right-skewed positive responses tails heavier lighter gamma/lognormal, often paired hurdle/mixture delta_gengamma() zero-inflated biomass catch data (see Dunic et al. (2025)). Code defined within sdmTMB. Example: family = gengamma(link = \"log\"); delta/hurdle: family = delta_gengamma(link1 = \"logit\", link2 = \"log\").","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"tweedie","dir":"Articles","previous_headings":"Observation model families > Positive continuous outcomes","what":"Tweedie","title":"sdmTMB model description","text":"Tweedie(μ,p,ϕ),1<p<2 \\operatorname{Tweedie} \\left(\\mu, p, \\phi \\right), \\: 1 < p < 2 μ\\mu mean, pp power parameter constrained 1 2, ϕ\\phi dispersion parameter. Tweedie distribution can helpful modelling data positive continuous also contain zeros. Internally, pp transformed logit−1(𝚝𝚑𝚎𝚝𝚊𝚏)+1\\mathrm{logit}^{-1} (\\texttt{thetaf}) + 1 constrain 1 2 estimated unconstrained variable. source code implemented cplm package (Zhang 2013) based Dunn & Smyth (2005). TMB version defined . Example: family = tweedie(link = \"log\")","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"gamma-mixture","dir":"Articles","previous_headings":"Observation model families > Positive continuous outcomes","what":"Gamma mixture","title":"sdmTMB model description","text":"2 component mixture extends Gamma distribution, motivated mixture-distribution treatments aggregation survey data (Thorson et al. 2011), (1−p)⋅Gamma(ϕ,μ1ϕ)+p⋅Gamma(ϕ,μ2ϕ), (1 - p) \\cdot \\operatorname{Gamma} \\left( \\phi, \\frac{\\mu_{1}}{\\phi}  \\right) + p \\cdot \\operatorname{Gamma} \\left( \\phi, \\frac{\\mu_{2}}{\\phi}  \\right),  ϕ\\phi represents Gamma shape, μ1/ϕ\\mu_{1} / \\phi represents scale first (smaller component) distribution, μ2/ϕ\\mu_{2} / \\phi represents scale second (larger component) distribution, pp controls contribution component mixture (also interpreted probability larger events). mean (1−p)⋅μ1+p⋅μ2(1-p) \\cdot \\mu_{1} + p \\cdot \\mu_{2}. variance follows usual mixture formula: (1−p)(μ12/ϕ+μ12)+p(μ22/ϕ+μ22)−[(1−p)μ1+pμ2]2(1-p)\\left(\\mu_1^2 / \\phi + \\mu_1^2\\right) + p\\left(\\mu_2^2 / \\phi + \\mu_2^2\\right) - \\left[(1-p)\\mu_1 + p\\mu_2\\right]^2. , mixture distributions, probability larger mean can obtained plogis(fit$model$par[[\"logit_p_extreme\"]]) ratio larger mean smaller mean can obtained 1 + exp(fit$model$par[[\"log_ratio_mix\"]]). standard errors available TMB sdreport: fit$sd_report. wish fix probability large (.e., extreme) mean, can hard estimate, can fix value pass family: See also family = delta_gamma_mix() extension incorporating distribution delta models.","code":"sdmTMB(...,   family = gamma_mix(link = \"log\", p_extreme = 0.01) )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"lognormal-mixture","dir":"Articles","previous_headings":"Observation model families > Positive continuous outcomes","what":"Lognormal mixture","title":"sdmTMB model description","text":"2 component mixture extends lognormal distribution, spirit mixture approaches aggregating/ shoaling data (Thorson et al. 2011), (1−p)⋅Lognormal(logμ1−ϕ22,ϕ2)+p⋅Lognormal(logμ2−ϕ22,ϕ2). (1 - p) \\cdot \\operatorname{Lognormal} \\left( \\log \\mu_{1} - \\frac{\\phi^2}{2}, \\phi^2 \\right) + p \\cdot \\operatorname{Lognormal} \\left( \\log \\mu_{2} - \\frac{\\phi^2}{2}, \\phi^2 \\right). bias correction, 𝔼[y]=(1−p)⋅μ1+p⋅μ2\\mathbb{E}[y] = (1-p) \\cdot \\mu_{1} + p \\cdot \\mu_{2}. log-scale variance mixture simply ϕ2\\phi^2; can obtained standard mixture-variance formula using component log-means logμi−ϕ2/2\\log \\mu_i - \\phi^2/2 log-variance ϕ2\\phi^2. Gamma mixture, pp controls contribution component mixture (also interpreted probability larger events). Example: family = lognormal_mix(link = \"log\"). See also family = delta_lognormal_mix() extension incorporating distribution delta models. Like gamma mixture, fixed probabilities extreme events (pp notation ) can passed , e.g.","code":"sdmTMB(...,   family = delta_lognormal_mix(p_extreme = 0.01) )"},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"gaussian","dir":"Articles","previous_headings":"Observation model families > Continuous real-valued outcomes","what":"Gaussian","title":"sdmTMB model description","text":"Normal(μ,ϕ2) \\operatorname{Normal} \\left( \\mu, \\phi^2 \\right)  μ\\mu mean ϕ\\phi standard deviation. variance ϕ2\\phi^2. Example: family = Gaussian(link = \"identity\") Code defined within TMB.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"student-t","dir":"Articles","previous_headings":"Observation model families > Continuous real-valued outcomes","what":"Student-t","title":"sdmTMB model description","text":"Student-t(μ,ϕ,ν) \\operatorname{Student-t} \\left( \\mu, \\phi, \\nu \\right) ν\\nu, degrees freedom (df), user-supplied fixed parameter. Lower values ν\\nu result heavier tails compared Gaussian distribution. approximately df = 20, distribution becomes similar Gaussian. Student-t distribution low degrees freedom (e.g., ν≤7\\nu \\le 7) can helpful modelling data otherwise suitable Gaussian needs approach robust outliers (e.g., Anderson et al. 2017). Code defined within sdmTMB based dt() distribution TMB. Example: family = student(link = \"log\", df = 7)","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"delta-models","dir":"Articles","previous_headings":"Observation model families > Zero-inflated and hurdle structures","what":"Delta models","title":"sdmTMB model description","text":"sdmTMB allows several different kinds delta (also known hurdle) models. families implemented specifying family delta distribution. example: list supported families included documentation additional families, delta models, Poisson-link delta models. default, delta_* families don’t use Poisson link, structure can specified delta_gamma(type = \"poisson-link\"), follows formulation Thorson (2018). “standard” delta model implementation, sdmTMB constructs two internal models (formally, two “linear predictors”), first model representing presence-absence second model representing positive component (catch rates fisheries applications). Default links associated family can inspected delta_lognormal() equivalent functions. standard delta models, default first linear predictor link logit. Poisson-link type, first linear predictor link log. formula, spatial, spatiotemporal, share_range arguments sdmTMB() can specified independently 2-element list. example, spatial random field might estimated first linear predictor : may want separate main-effects formulas. example: arguments shared linear predictors. Currently delta models contain smoothers, components must main-effects formula.","code":"sdmTMB(   ...,   family = delta_gamma() ) sdmTMB(   ...,   family = delta_gamma(),   spatial = list(\"on\", \"off\") ) sdmTMB(   formula = list(     y ~ depth + I(depth^2),      y ~ 1),   family = delta_gamma() )"},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"matérn-parameterization","dir":"Articles","previous_headings":"Gaussian random fields","what":"Matérn parameterization","title":"sdmTMB model description","text":"Matérn defines covariance Φ(sj,sk)\\Phi \\left( s_j, s_k \\right) spatial locations sjs_j sks_k Φ(sj,sk)=τ2[2ν−1Γ(ν)]−1(κdjk)νKν(κdjk), \\Phi\\left( s_j,s_k \\right) = \\tau^2 \\left[ 2^{\\nu - 1}\\Gamma(\\nu) \\right]^{-1} (\\kappa d_{jk})^\\nu K_\\nu \\left( \\kappa d_{jk} \\right), τ2\\tau^2 scale/precision factor (higher τ\\tau means lower marginal variance), ν\\nu controls smoothness, Γ\\Gamma represents Gamma function, djkd_{jk} represents distance locations sjs_j sks_k, KνK_\\nu represents modified Bessel function second kind, κ\\kappa represents decorrelation rate. parameter ν\\nu set 1 SPDE approach gives us sparse matrices (therefore major computational speedups) requires α=ν+d/2\\alpha = \\nu + d/2 integer working 2D (ν=1\\nu = 1) (Lindgren et al. 2011). Internally, parameters κ\\kappa τ\\tau converted range marginal standard deviation σ\\sigma range=8/κ\\textrm{range} = \\sqrt{8} / \\kappa σ=1/4πexp(2log(τ)+2log(κ))\\sigma = 1 / \\sqrt{4 \\pi \\exp \\left(2 \\log(\\tau) + 2 \\log(\\kappa) \\right) }, increasing κ\\kappa τ\\tau decreases σ\\sigma. case spatiotemporal model spatial spatiotemporal fields, share_range = TRUE sdmTMB() (default), single κ\\kappa range estimated separate σω\\sigma_\\omega σϵ\\sigma_\\epsilon. often makes sense since data often weakly informative κ\\kappa. share_range = FALSE, separate κω\\kappa_\\omega κϵ\\kappa_\\epsilon estimated. spatially varying coefficient field always shares κ\\kappa spatial random field.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"projection-mathbfa-matrix","dir":"Articles","previous_headings":"Gaussian random fields","what":"Projection 𝐀\\mathbf{A} matrix","title":"sdmTMB model description","text":"values spatial variables knots multiplied projection matrix 𝐀\\mathbf{} bilinearly interpolates knot locations values locations observed predicted data (Lindgren & Rue 2015) 𝛚*=𝐀𝛚, \\boldsymbol{\\omega}^* = \\mathbf{}\\boldsymbol{\\omega},  𝛚*\\boldsymbol{\\omega}^* represents values spatial random fields observed locations predicted data locations. matrix 𝐀\\mathbf{} row data point prediction point column knot. Three non-zero elements row define weight neighbouring 3 knot locations location 𝐬\\mathbf{s}. bilinear interpolation happens spatiotemporal random fields 𝛜t*=𝐀𝛜t. \\boldsymbol{\\epsilon}_t^* = \\mathbf{}\\boldsymbol{\\epsilon}_t.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"anisotropy","dir":"Articles","previous_headings":"Gaussian random fields","what":"Anisotropy","title":"sdmTMB model description","text":"TMB allows anisotropy, spatial covariance may asymmetric respect latitude longitude (full details). Anisotropy can turned logical anisotropy argument sdmTMB(). number ways implement anisotropic covariance (Fuglstad et al. 2015), adopt 2-parameter rotation matrix 𝐇\\mathbf{H}. elements 𝐇\\mathbf{H} defined parameter vector 𝐱\\boldsymbol{x} H1,1=x1H_{1,1} = x_{1}, H1,2=H2,1=x2H_{1,2} = H_{2,1} = x_{2} H2,2=(1+x22)/x1H_{2,2} = (1 + x_{2}^2) / x_{1}. model fitted sdmTMB(), anisotropy relationships may plotted using plot_anisotropy() function, takes fitted object argument. barrier mesh used, anisotropy disabled.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"incorporating-physical-barriers-into-the-spde","dir":"Articles","previous_headings":"Gaussian random fields","what":"Incorporating physical barriers into the SPDE","title":"sdmTMB model description","text":"cases spatial domain interest may complex bounded barrier land water (e.g., coastlines, islands, lakes). SPDE models allow physical barriers incorporated modelling (Bakka et al. 2019). sdmTMB() models, mesh construction occurs two steps: user (1) constructs mesh call sdmTMBextra::make_mesh(), (2) passes mesh sdmTMBextra::add_barrier_mesh(). barriers must constructed sf objects (Pebesma 2018) polygons defining barriers. See ?sdmTMBextra::add_barrier_mesh example. barrier implementation requires user select fraction value (range_fraction argument) defines fraction usual spatial range crossing barrier (Bakka et al. 2019). example, range estimated 10 km, range_fraction = 0.2 assign 2 km range triangles marked barrier. makes correlation decay much faster barrier around , effectively discourages spatial smoothing “jumping” across landmasses. experimentation, values around 0.1 0.2 seem work well values much lower 0.1 can result convergence issues. website Francesco Serafini Haakon Bakka provides illustration INLA. implementation within TMB borrowed code written Olav Nikolai Breivik Hans Skaug TMB Case Studies Github site.","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"optimization-details","dir":"Articles","previous_headings":"Optimization","what":"Optimization details","title":"sdmTMB model description","text":"sdmTMB model fit maximum marginal likelihood. Internally, TMB (Kristensen et al. 2016) model template calculates marginal log likelihood gradient, negative log likelihood minimized via non-linear optimization routine stats::nlminb() R (Gay 1990; R Core Team 2021). Random effects represented values maximize log likelihood conditional fixed effects (conditional modes), Laplace approximation integrates evaluating likelihood (Kristensen et al. 2016). Like AD Model Builder (Fournier et al. 2012), TMB allows parameters fit phases include multiphase argument sdmTMB::sdmTMBcontrol() allow . high-dimensional models (many fixed random effects), phased estimation may faster, always case requires extra call TMB::MakeADFun(). sdmTMB, phased estimation proceeds first estimating fixed-effect parameters contributing likelihood (holding random effects constant initial values). second phase, random-effect parameters (variances) also estimated. Fixed-effect parameters also estimated second phase initialized estimates first phase. cases, single call stats::nlminb() may result convergence (e.g., maximum gradient marginal likelihood respect fixed-effect parameters small enough yet), algorithm may need run multiple times. sdmTMB::sdmTMBcontrol() function, include argument nlminb_loops restart optimization previous best values. number nlminb_loops generally small (e.g., 2 3), defaults 1. sdmTMB models, Hessian may also unstable need re-evaluated. optionally stats::optimHess() routine call stats::nlminb(). stats::optimHess() function implements Newton optimization routine find Hessian, include argument newton_loops sdmTMB::sdmTMBcontrol() allow multiple function evaluations (starting previous best value). default, set 1 evaluation. updated parameters accepted result lower negative marginal log likelihood. model already fit, function sdmTMB::run_extra_optimization() can run additional optimization loops either routine reduce maximum gradient.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"assessing-convergence","dir":"Articles","previous_headings":"Optimization","what":"Assessing convergence","title":"sdmTMB model description","text":"Much guidance around diagnostics glmmTMB also applies sdmTMB, e.g. glmmTMB vignette troubleshooting. Optimization stats::nlminb() involves specifying number iterations evaluations (eval.max iter.max) tolerances (abs.tol, rel.tol, x.tol, xf.tol)—greater number iterations smaller tolerance thresholds increase chance optimal solution found, evaluations translates longer computation time. Warnings non-positive-definite Hessian matrices (accompanied parameters NAs standard errors) often mean models improperly specified given data. Standard errors can observed output print.sdmTMB() checking fit$sd_report. maximum gradient marginal likelihood respect fixed-effect parameters can checked inspecting (fit$gradients). Guidance varies, gradients close zero (e.g., order 10−310^{-3} smaller reasonable parameter scaling) assuming fitting routine consistent convergence. maximum gradients already relatively small, can sometimes reduced additional optimization calls beginning previous best parameter vector described sdmTMB::run_extra_optimization().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/model-description.html","id":"notation-reference-tables","dir":"Articles","previous_headings":"","what":"Notation reference tables","title":"sdmTMB model description","text":"Tables major indices (Table 1) symbols (Table 2) provided quick reference. Table 1: Subscript notation Table 2: Symbol notation, code representation (model output model template code), descriptions.","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/multispecies.html","id":"model-1-species-specific-intercepts","dir":"Articles","previous_headings":"","what":"Model 1: species-specific intercepts","title":"Fitting multispecies models with sdmTMB","text":"first model, can include species-specific year effects. can done couple ways. One option estimate species * year interaction, letting year effects species independent. , parameters random effect values (range, spatial field, spatial variance, spatiotemporal fields, spatiotemporal variances) shared.","code":"fit <- sdmTMB(   observed ~ fyear * species,   data = sim_dat,   time = \"year\",   spatiotemporal = \"iid\",   mesh = mesh,   family = gaussian() ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: observed ~ fyear * species #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #> Conditional model: #>                 coef.est coef.se #> (Intercept)         7.59    0.05 #> fyear2              0.36    0.05 #> fyear3              0.02    0.05 #> fyear4             -1.19    0.05 #> fyear5             -1.93    0.05 #> speciesB           -1.49    0.03 #> fyear2:speciesB     0.02    0.04 #> fyear3:speciesB    -0.71    0.04 #> fyear4:speciesB     0.70    0.04 #> fyear5:speciesB     3.45    0.04 #>  #> Dispersion parameter: 0.27 #> Matérn range: 0.19 #> Spatial SD: 0.17 #> Spatiotemporal IID SD: 0.14 #> ML criterion at convergence: 329.263 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/multispecies.html","id":"model-2-species-specific-spatial-fields","dir":"Articles","previous_headings":"","what":"Model 2: species-specific spatial fields","title":"Fitting multispecies models with sdmTMB","text":"may interested fitting model lets spatial patterning differ species. kinds models can expressed using spatially varying coefficients. Note use spatial = represents global spatial intercept—turning akin using -1 0 main formula including factor. species take spatial fields spatial_varying field . ’ll notice two rows entries sigma_Z spatially varying random field standard deviation: means model trying estimate separate species-specific variance terms species-specific spatial fields (say 10 times fast!). , matches simulated data. contexts, especially ran estimation issues, might want share SDs. wanted estimate species-specific spatial fields single shared variance (meaning net magnitude peaks valleys fields similar wiggles species specific), specifying custom map argument passing sdmTMBcontrol(). shared factor levels map gathered ‘mirrored’ shared parameter values. assign ln_tau_Z , internally, parameter gets converted spatially-varying field variances (SDs fields sigma_Z). case pretty simple, complicated cases figure structure needed map vector follows: , need vector length two shared factor values: , can use map list share spatially varying coefficient SDs: Notice spatially varying coefficient SD now shared.","code":"fit <- sdmTMB(   observed ~ fyear * species,   data = sim_dat,   mesh = mesh,   family = gaussian(),   spatial = \"off\",   time = \"year\",   spatiotemporal = \"iid\",   spatial_varying = ~ 0 + factor(species) ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: observed ~ fyear * species #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #> Conditional model: #>                 coef.est coef.se #> (Intercept)         7.60    0.06 #> fyear2              0.36    0.05 #> fyear3              0.04    0.05 #> fyear4             -1.22    0.05 #> fyear5             -1.94    0.05 #> speciesB           -1.51    0.08 #> fyear2:speciesB     0.02    0.03 #> fyear3:speciesB    -0.75    0.03 #> fyear4:speciesB     0.76    0.03 #> fyear5:speciesB     3.48    0.03 #>  #> Dispersion parameter: 0.19 #> Matérn range: 0.18 #> Spatially varying coefficient SD (factor(species)A): 0.25 #> Spatially varying coefficient SD (factor(species)B): 0.30 #> Spatiotemporal IID SD: 0.16 #> ML criterion at convergence: -170.949 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. tidy(fit, \"ran_pars\") #> # A tibble: 5 × 5 #>   term    estimate std.error conf.low conf.high #>   <chr>      <dbl>     <dbl>    <dbl>     <dbl> #> 1 range      0.181   0.0250     0.139     0.238 #> 2 phi        0.189   0.00330    0.183     0.195 #> 3 sigma_E    0.162   0.0129     0.139     0.190 #> 4 sigma_Z    0.250   0.0268     0.203     0.308 #> 5 sigma_Z    0.302   0.0303     0.248     0.367 colnames(model.matrix(~ 0 + factor(species), data = sim_dat)) #> [1] \"factor(species)A\" \"factor(species)B\" map_list <- list(ln_tau_Z = factor(c(1, 1))) fit <- sdmTMB(   observed ~ fyear * factor(species),   data = sim_dat,   mesh = mesh,   family = gaussian(),   spatial = \"off\",   time = \"year\",   spatiotemporal = \"iid\",   spatial_varying = ~ 0 + factor(species),   control = sdmTMBcontrol(map = map_list) ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: observed ~ fyear * factor(species) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #> Conditional model: #>                         coef.est coef.se #> (Intercept)                 7.60    0.06 #> fyear2                      0.35    0.05 #> fyear3                      0.04    0.05 #> fyear4                     -1.23    0.05 #> fyear5                     -1.94    0.05 #> factor(species)B           -1.51    0.08 #> fyear2:factor(species)B     0.02    0.03 #> fyear3:factor(species)B    -0.75    0.03 #> fyear4:factor(species)B     0.76    0.03 #> fyear5:factor(species)B     3.48    0.03 #>  #> Dispersion parameter: 0.19 #> Matérn range: 0.18 #> Spatially varying coefficient SD (factor(species)A): 0.28 #> Spatially varying coefficient SD (factor(species)B): 0.28 #> Spatiotemporal IID SD: 0.16 #> ML criterion at convergence: -170.110 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/multispecies.html","id":"model-3-species-specific-spatiotemporal-fields","dir":"Articles","previous_headings":"","what":"Model 3: species-specific spatiotemporal fields","title":"Fitting multispecies models with sdmTMB","text":"examples , spatiotemporal fields included, shared among species. another example, can extend approaches set model includes spatiotemporal fields unique species. One approach including separate spatiotemporal fields species creating new variable concatenation species year (given time step factor). example, can implement form species-specific spatiotemporal variation changing time argument time = \"species_year\".","code":"sim_dat$species_year <- factor(paste(sim_dat$species, sim_dat$year)) map_list <- list(ln_tau_Z = factor(c(1, 1))) fit <- sdmTMB(   observed ~ fyear * factor(species),   data = sim_dat,   mesh = mesh,   family = gaussian(),   spatial = \"on\",   time = \"species_year\",   spatiotemporal = \"iid\",   spatial_varying = ~ 0 + factor(species),   control = sdmTMBcontrol(map = map_list) ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: observed ~ fyear * factor(species) #> Mesh: mesh (isotropic covariance) #> Time column: species_year #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #> Conditional model: #>                         coef.est coef.se #> (Intercept)                 7.56    0.07 #> fyear2                      0.38    0.08 #> fyear3                      0.06    0.08 #> fyear4                     -1.19    0.08 #> fyear5                     -1.92    0.08 #> factor(species)B           -1.43    0.10 #> fyear2:factor(species)B    -0.03    0.11 #> fyear3:factor(species)B    -0.79    0.11 #> fyear4:factor(species)B     0.67    0.11 #> fyear5:factor(species)B     3.41    0.11 #>  #> Dispersion parameter: 0.10 #> Matérn range: 0.16 #> Spatial SD: 0.06 #> Spatially varying coefficient SD (factor(species)A): 0.24 #> Spatially varying coefficient SD (factor(species)B): 0.24 #> Spatiotemporal IID SD: 0.31 #> ML criterion at convergence: -917.577 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/multispecies.html","id":"model-4-species-specific-spatiotemporal-fields-using-the-spatial_varying-argument","dir":"Articles","previous_headings":"","what":"Model 4: species-specific spatiotemporal fields using the spatial_varying argument","title":"Fitting multispecies models with sdmTMB","text":"can fit model using spatial_varying argument. give us added flexibility letting species’ spatiotemporal field variance wanted expanding model another category independent random fields. E.g., might also age length bins. First, ’ll spatial fields share variance spatiotemporal fields share variance: now exactly model, just specified differently: Say wanted let spatial spatiotemporal variances different species. changing map vector: Now separate SDs spatial spatiotemporal fields across species. case, marginal AIC indicate improvement added flexibility:","code":"# quick hack to force all levels of species and species:factor interactions in formula: mm1 <- model.matrix(~ 0 + factor(species), sim_dat) mm2 <- model.matrix(~ 0 + factor(year):factor(species), sim_dat) mm <- cbind(mm1, mm2) sim_dat2 <- cbind(sim_dat, mm)  # make our map vector: n_sp <- ncol(mm1) n_st <- ncol(mm2) map_list2 <- list(ln_tau_Z = factor(   c(rep(1, n_sp),   rep(2, n_st)) )) map_list2 #> $ln_tau_Z #>  [1] 1 1 2 2 2 2 2 2 2 2 2 2 #> Levels: 1 2  # hack together a model formula based on our hand constructed model matrix: svc_formula <- as.formula(paste0(\"~ `\", paste(colnames(mm), collapse = \"` + `\"), \"`\")) svc_formula #> ~`factor(species)A` + `factor(species)B` + `factor(year)1:factor(species)A` +  #>     `factor(year)2:factor(species)A` + `factor(year)3:factor(species)A` +  #>     `factor(year)4:factor(species)A` + `factor(year)5:factor(species)A` +  #>     `factor(year)1:factor(species)B` + `factor(year)2:factor(species)B` +  #>     `factor(year)3:factor(species)B` + `factor(year)4:factor(species)B` +  #>     `factor(year)5:factor(species)B`  fit_svc <- sdmTMB(   observed ~ fyear * factor(species),   data = sim_dat2,   mesh = mesh,   family = gaussian(),   spatial = \"off\",   time = \"year\",   spatiotemporal = \"off\",   spatial_varying = svc_formula,   control = sdmTMBcontrol(map = map_list2) ) logLik(fit) #> 'log Lik.' 917.5774 (df=15) logLik(fit_svc) #> 'log Lik.' 917.5177 (df=14) colnames(mm) #>  [1] \"factor(species)A\"               \"factor(species)B\"               #>  [3] \"factor(year)1:factor(species)A\" \"factor(year)2:factor(species)A\" #>  [5] \"factor(year)3:factor(species)A\" \"factor(year)4:factor(species)A\" #>  [7] \"factor(year)5:factor(species)A\" \"factor(year)1:factor(species)B\" #>  [9] \"factor(year)2:factor(species)B\" \"factor(year)3:factor(species)B\" #> [11] \"factor(year)4:factor(species)B\" \"factor(year)5:factor(species)B\" map_list3 <- list(ln_tau_Z = factor(   c(c(1, 2),   rep(3, n_st/2),   rep(4, n_st/2) ))) # check: data.frame(map_value = map_list3$ln_tau_Z, svc_term = colnames(mm)) #>    map_value                       svc_term #> 1          1               factor(species)A #> 2          2               factor(species)B #> 3          3 factor(year)1:factor(species)A #> 4          3 factor(year)2:factor(species)A #> 5          3 factor(year)3:factor(species)A #> 6          3 factor(year)4:factor(species)A #> 7          3 factor(year)5:factor(species)A #> 8          4 factor(year)1:factor(species)B #> 9          4 factor(year)2:factor(species)B #> 10         4 factor(year)3:factor(species)B #> 11         4 factor(year)4:factor(species)B #> 12         4 factor(year)5:factor(species)B  fit_svc_separate <- sdmTMB(   observed ~ fyear * factor(species),   data = sim_dat2,   mesh = mesh,   family = gaussian(),   spatial = \"off\",   time = \"year\",   spatiotemporal = \"off\",   spatial_varying = svc_formula,   control = sdmTMBcontrol(map = map_list3) ) fit_svc_separate #> Spatial model fit by ML ['sdmTMB'] #> Formula: observed ~ fyear * factor(species) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: sim_dat2 #> Family: gaussian(link = 'identity') #>   #> Conditional model: #>                         coef.est coef.se #> (Intercept)                 7.56    0.07 #> fyear2                      0.38    0.08 #> fyear3                      0.06    0.08 #> fyear4                     -1.19    0.08 #> fyear5                     -1.92    0.08 #> factor(species)B           -1.43    0.10 #> fyear2:factor(species)B    -0.03    0.11 #> fyear3:factor(species)B    -0.79    0.11 #> fyear4:factor(species)B     0.67    0.11 #> fyear5:factor(species)B     3.42    0.11 #>  #> Dispersion parameter: 0.10 #> Matérn range: 0.16 #> Spatially varying coefficient SD (`factor(species)A`): 0.21 #> Spatially varying coefficient SD (`factor(species)B`): 0.28 #> Spatially varying coefficient SD (`factor(year)1:factor(species)A`): 0.31 #> Spatially varying coefficient SD (`factor(year)2:factor(species)A`): 0.31 #> Spatially varying coefficient SD (`factor(year)3:factor(species)A`): 0.31 #> Spatially varying coefficient SD (`factor(year)4:factor(species)A`): 0.31 #> Spatially varying coefficient SD (`factor(year)5:factor(species)A`): 0.31 #> Spatially varying coefficient SD (`factor(year)1:factor(species)B`): 0.30 #> Spatially varying coefficient SD (`factor(year)2:factor(species)B`): 0.30 #> Spatially varying coefficient SD (`factor(year)3:factor(species)B`): 0.30 #> Spatially varying coefficient SD (`factor(year)4:factor(species)B`): 0.30 #> Spatially varying coefficient SD (`factor(year)5:factor(species)B`): 0.30 #> ML criterion at convergence: -918.900 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. AIC(fit_svc, fit_svc_separate) #>                  df       AIC #> fit_svc          14 -1807.035 #> fit_svc_separate 16 -1805.801"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/multispecies.html","id":"model-5-hack-species-into-the-time-element-for-spatial-models","dir":"Articles","previous_headings":"","what":"Model 5: hack species into the time element for spatial models","title":"Fitting multispecies models with sdmTMB","text":"wanted fit spatial model several species (groups), one approach pretend species (group) time element. just convenience though. instead thing using spatial_varying argument making sure ‘map’ field variances shared match : can prove ’re identical:","code":"sim_dat$numeric_species <- as.numeric(factor(sim_dat$species)) # needs to be numeric fit_fake_time <- sdmTMB(   observed ~ 0 + factor(species),   data = sim_dat,   mesh = mesh,   family = gaussian(),   spatial = \"off\",   time = \"numeric_species\", #< hack   spatiotemporal = \"iid\" #< 'AR1' or 'RW' probably wouldn't make sense here ) fit_fake_time #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: observed ~ 0 + factor(species) #> Mesh: mesh (isotropic covariance) #> Time column: numeric_species #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #> Conditional model: #>                  coef.est coef.se #> factor(species)A     7.01    0.08 #> factor(species)B     6.27    0.08 #>  #> Dispersion parameter: 0.86 #> Matérn range: 0.33 #> Spatiotemporal IID SD: 0.21 #> ML criterion at convergence: 2568.873 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. fit_svc3 <- sdmTMB(   observed ~ 0 + factor(species),   data = sim_dat,   mesh = mesh,   family = gaussian(),   spatial = \"off\",   spatial_varying = ~ 0 + factor(species),   control = sdmTMBcontrol(map = list(ln_tau_Z = factor(c(1, 1)))) ) fit_svc3 #> Spatial model fit by ML ['sdmTMB'] #> Formula: observed ~ 0 + factor(species) #> Mesh: mesh (isotropic covariance) #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #> Conditional model: #>                  coef.est coef.se #> factor(species)A     7.01    0.08 #> factor(species)B     6.27    0.08 #>  #> Dispersion parameter: 0.86 #> Matérn range: 0.33 #> Spatially varying coefficient SD (factor(species)A): 0.21 #> Spatially varying coefficient SD (factor(species)B): 0.21 #> ML criterion at convergence: 2568.873 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. logLik(fit_fake_time) #> 'log Lik.' -2568.873 (df=5) logLik(fit_svc3) #> 'log Lik.' -2568.873 (df=5)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/multispecies.html","id":"putting-it-all-together","dir":"Articles","previous_headings":"","what":"Putting it all together","title":"Fitting multispecies models with sdmTMB","text":"examples illustrate number ways species-specific effects can included sdmTMB models, can extended categories/groups/cohorts within species one wants control amount information shared groups (e.g., age-, size-, stage-specific estimates). brief summary approaches can summarized :","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/multispecies.html","id":"further-extensions","dir":"Articles","previous_headings":"","what":"Further extensions","title":"Fitting multispecies models with sdmTMB","text":"long ’re willing treat spatiotemporal group-level fields (e.g., different species age cohorts) independent, sdmTMB can used fit models data. example, allows sdmTMB used standardization age length composition data Thorson Haltuch (2018) CJFAS. approach similar plan write separate vignette topic.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Poisson-link delta models","text":"Jim Thorson introduced Poisson-link delta model CJFAS paper (Thorson 2018). ’s useful model family dealing positive continuous data zeroes. can used circumstances use Tweedie traditional delta-gamma delta-lognormal model logit log links. Poisson-link delta formulation describes go linear predictors link space expected values entered data likelihood. likelihood first component Bernoulli (.e., binomial single trials) likelihood second component can gamma lognormal. sdmTMB, families specified delta_gamma(type = \"poisson-link\") delta_lognormal(type = \"poisson-link\").","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The model","title":"Poisson-link delta models","text":"Thorson (2018) describes process model : p=1−exp(−n),r=nwp, \\begin{aligned} p &= 1 - \\exp(-n),\\\\ r &= \\frac{n w}{p}, \\end{aligned}  pp represents encounter probability, nn represents group numbers density, rr represents positive catch rate (.e., catch rate given encounter), ww represents weight per group. linear predictors represent log group numbers density (log(n)\\log (n)) log weight per group (log(w)\\log (w)): log(n)=𝐗𝟏𝛃𝟏+…,log(w)=𝐗𝟐𝛃𝟐+…, \\begin{aligned} \\log (n) &= \\boldsymbol{X_1} \\boldsymbol{\\beta_1} + \\ldots,\\\\ \\log (w) &= \\boldsymbol{X_2} \\boldsymbol{\\beta_2} + \\ldots, \\end{aligned} 𝐗\\boldsymbol{X}s represent design matrices, 𝛃\\boldsymbol{\\beta}s represent coefficient vectors, …\\ldots represents possible model components linear link space including random fields. transformed process equations generate pp rr. model evaluates following likelihood components. encounter probability pp Bernoulli(p), \\operatorname{Bernoulli} (p), equivalently Binomial(1,p), \\operatorname{Binomial} (1, p), positive rate rr, either gamma lognormal likelihood Gamma(ϕ,rϕ), \\operatorname{Gamma} \\left( \\phi, \\frac{r}{\\phi}  \\right),  ϕ\\phi represents gamma shape r/ϕr / \\phi represents scale, Lognormal(log(r)−ϕ22,ϕ2), \\operatorname{Lognormal} \\left( \\log (r) - \\frac{\\phi^2}{2}, \\phi^2 \\right), log(r)−ϕ22\\log (r) - \\frac{\\phi^2}{2} represents bias-corrected log mean ϕ\\phi represents standard deviation log-space.","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"data","dir":"Articles","previous_headings":"An example","what":"Data","title":"Poisson-link delta models","text":"work Pacific Spiny Dogfish observations trawl survey west coast Vancouver Island, Canada. dataset dogfish contained within sdmTMB package.","code":"library(ggplot2) theme_set(theme_light()) library(dplyr) library(sdmTMB) dogfish$log_depth <- log(dogfish$depth) head(dogfish) #> # A tibble: 6 × 10 #>    year longitude latitude     X     Y present catch_weight area_swept depth #>   <int>     <dbl>    <dbl> <dbl> <dbl>   <int>        <dbl>      <dbl> <dbl> #> 1  2004     -125.     48.7  780. 5399.       1         22.7     0.103     73 #> 2  2004     -126.     48.2  735. 5346.       0          0       0.103    455 #> 3  2004     -126.     48.3  738. 5355.       0          0       0.116    171 #> 4  2004     -126.     48.3  749. 5354.       1        221.      0.122    137 #> 5  2004     -126.     48.4  744. 5362.       1        440.      0.0964   140 #> 6  2004     -126.     48.4  737. 5362.       1         48.2     0.122    145 #> # ℹ 1 more variable: log_depth <dbl> mesh <- make_mesh(dogfish, c(\"X\", \"Y\"), cutoff = 10)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"a-conventional-delta-gamma-model","dir":"Articles","previous_headings":"An example","what":"A conventional delta-gamma model:","title":"Poisson-link delta models","text":"First, lets fit conventional delta-gamma model logit log links illustrate limitation. can show effect depth catch weight? one curve, two components use different links (logit + log), different catch-weight depth relationship depending expected catch weight coefficients (year also given point space spatial random field). example, curves look different years:  one curve! depends value year every point space different random field value.","code":"fit_dg <- sdmTMB(catch_weight ~ 0 + as.factor(year) + s(log_depth),   family = delta_gamma(),   spatial = \"on\",   mesh = mesh,   data = dogfish,   anisotropy = FALSE,   reml = TRUE,   offset = log(dogfish$area_swept),   silent = FALSE ) sanity(fit_dg) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameters don't look unreasonably large nd <- expand.grid(   log_depth = seq(min(dogfish$log_depth), max(dogfish$log_depth), length.out = 200),   year = as.factor(unique(dogfish$year)) ) p <- predict(fit_dg, newdata = nd, re_form = NA) ggplot(p, aes(log_depth, log(plogis(est1) * exp(est2)), colour = year)) +   geom_line() +   ylab(\"log expected catch weight\")"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"a-poisson-link-delta-gamma-alternative","dir":"Articles","previous_headings":"An example","what":"A Poisson-link-delta-gamma alternative","title":"Poisson-link delta models","text":"Instead, let’s fit Poisson-link delta-gamma model: make plot:  Note lines now parallel. predictors shift curve affect shape combined prediction use log link.","code":"fit_dpg <- sdmTMB(catch_weight ~ 0 + as.factor(year) + s(log_depth),   family = delta_gamma(type = \"poisson-link\"),   spatial = \"on\",   mesh = mesh,   data = dogfish,   anisotropy = TRUE,   reml = TRUE,   offset = log(dogfish$area_swept),   silent = FALSE ) sanity(fit_dpg) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 summary(fit_dpg) #> Spatial model fit by REML ['sdmTMB'] #> Formula: catch_weight ~ 0 + as.factor(year) + s(log_depth) #> Mesh: mesh (anisotropic covariance) #> Data: dogfish #> Family: delta_gamma(link1 = 'log', link2 = 'log', type = 'poisson-link') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'log')  #> Conditional model: #>                     coef.est coef.se #> as.factor(year)2004     1.96    0.77 #> as.factor(year)2006     2.89    0.77 #> as.factor(year)2008     2.57    0.76 #> as.factor(year)2010     2.43    0.77 #> as.factor(year)2012     1.94    0.76 #> as.factor(year)2014     1.93    0.76 #> as.factor(year)2016     2.20    0.76 #> as.factor(year)2018     2.03    0.76 #> as.factor(year)2021     1.18    0.76 #> as.factor(year)2022     1.75    0.76 #> slog_depth              0.15    0.54 #>  #> Smooth terms: #>                  Std. Dev. #> sd__s(log_depth)      2.38 #>  #> Matérn anisotropic range (spatial): 26.1 to 381.1 at 142 deg. #> Spatial SD: 1.18 #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: Gamma(link = 'log')  #> Conditional model: #>                     coef.est coef.se #> as.factor(year)2004     3.59    0.37 #> as.factor(year)2006     2.78    0.33 #> as.factor(year)2008     2.47    0.32 #> as.factor(year)2010     3.50    0.34 #> as.factor(year)2012     2.77    0.33 #> as.factor(year)2014     2.45    0.33 #> as.factor(year)2016     2.09    0.32 #> as.factor(year)2018     2.60    0.32 #> as.factor(year)2021     1.69    0.33 #> as.factor(year)2022     1.98    0.33 #> slog_depth             -0.20    0.82 #>  #> Smooth terms: #>                  Std. Dev. #> sd__s(log_depth)      5.09 #>  #> Dispersion parameter: 0.59 #> Matérn anisotropic range (spatial): 4.2 to 60.8 at 142 deg. #> Spatial SD: 1.97 #>  #> REML criterion at convergence: 5851.613 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. #> See ?plot_anisotropy to plot the anisotropic range. p_dpg <- predict(fit_dpg, newdata = nd, re_form = NA) ggplot(p_dpg, aes(log_depth, est1 + est2, colour = year)) +   geom_line() +   ylab(\"log expected catch weight\")"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"examining-the-model-components-and-how-they-combine","dir":"Articles","previous_headings":"An example","what":"Examining the model components and how they combine","title":"Poisson-link delta models","text":"’ll make predictions across depths single year simplicity: can extract components theoretical deconstruction catch group numbers density, weight per group, encounter probability, positive rate: can come overall predictions two ways: n * w: group numbers ×\\times weight per group. equivalently exp(est1 + est2), est1 est2 linear predictors link space. p * r: encounter probability ×\\times positive catch rate. give identical answers:  Let’s plot components possible combinations:","code":"nd2010 <- dplyr::filter(nd, year == 2010) p_pdg <- predict(fit_dpg, newdata = nd2010, re_form = NA) n <- exp(p_pdg$est1) w <- exp(p_pdg$est2) p <- 1 - exp(-n) r <- (n * w) / p lims <- c(0, max(p * r)) plot(n * w, p * r, xlim = lims, ylim = lims) abline(0, 1) g1 <- ggplot(p_pdg, aes(log_depth, n)) +   geom_line() +   ggtitle(\"Expected group density\") g2 <- ggplot(p_pdg, aes(log_depth, w)) +   geom_line() +   ggtitle(\"Expected weight per group\") g3 <- ggplot(p_pdg, aes(log_depth, p)) +   geom_line() +   ylim(0, 1) +   ggtitle(\"Expected encounter probability\") g4 <- ggplot(p_pdg, aes(log_depth, r)) +   geom_line() +   ggtitle(\"Expected catch given encounter\") g5 <- ggplot(p_pdg, aes(log_depth, n * w)) +   geom_line() +   ggtitle(\"Expected catch\") g6 <- ggplot(p_pdg, aes(log_depth, p * r)) +   geom_line() +   ggtitle(\"Expected catch\")  cowplot::plot_grid(g1, g2, g3, g4, g5, g6, ncol = 2)"},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"what-is-a-group-and-how-does-the-model-know-about-numbers","dir":"Articles","previous_headings":"FAQ","what":"What is a ‘group’ and how does the model know about numbers!?","title":"Poisson-link delta models","text":"model represents process groups fish (observations, course) encountered certain numbers (“group numbers density”) group certain weight (“weight per group”). theoretical construct reflecting model can best parse two components according properties observed data. Since predicted response value n⋅wn \\cdot w, can get value multiplying nn dividing ww amount. numbers less weight per group fewer numbers weight per group get place. However, balance two, given covariates random effects, best fits data entered likelihood pp rr.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"what-is-the-connection-to-the-complementary-log-log-link-cloglog-and-the-poisson","dir":"Articles","previous_headings":"FAQ","what":"What is the connection to the complementary log-log link (‘cloglog’) and the Poisson?","title":"Poisson-link delta models","text":"Wikipedia: “cloglog model corresponds applications observe either zero events (e.g., defects) one , number events assumed follow Poisson distribution.” following based around entry. Poisson assumes probability observing zero given expected number nn exp(−n)\\exp(-n). .e., Pr(0)=exp(−n) \\mathrm{Pr}(0) = \\exp(-n)  pp probability observing non-zero (.e., encounter), exp(−n)=1−p=Pr(0). \\exp(-n) = 1 - p = \\mathrm{Pr}(0). can re-arrange n=−log(1−p). n = -\\log(1 - p). since want linear predictor take values negative positive infinity (therefore keep predicted number densities positive exponentiating ), work log space: log(n)=log(−log(1−p)). \\log (n) = \\log(-\\log(1 - p)). right side known ‘cloglog’ link function. link following inverse link function: p=1−exp(−exp(logn)). p = 1 - \\exp(-\\exp(\\log n)). can check R: can see cloglog inverse link first part Poisson-link delta model. However, ‘trick’ group density nn affects encounter probability pp (shown ) positive catch rates rr: r=nwp. r = \\frac{n w}{p}. , going linear predictors (log links) expected values going data likelihood (binomial + lognormal/gamma), first linear predictor plays double duty appears delta model expected values.","code":"p <- 0.78 log_n <- log(-log(1 - p)) log_n #> [1] 0.4148395 1 - exp(-exp(log_n)) #> [1] 0.78"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"what-are-the-advantages-of-using-such-a-model","dir":"Articles","previous_headings":"FAQ","what":"What are the advantages of using such a model?","title":"Poisson-link delta models","text":"poisson-link families flexibility delta model, practice often helpful better predictions. checked AIC, better yet, cross validation. Like delta models, decomposition process two theoretical parts. can help interpretation (can make things complicated interpret!). , parts can rearranged represent two ways thinking two components (nn ww pp rr). Compared traditional delta-gamma model logit log link, two linear predictors log links, coefficients interpretable multiplicative effects, effects can combined. E.g., coefficients can added log space predictions can added log space generate single response curve given predictor.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"where-does-the-offset-come-in","dir":"Articles","previous_headings":"FAQ","what":"Where does the offset come in?","title":"Poisson-link delta models","text":"offset added linear predictor logn\\log n, .e., exp(offset) * n. example aa represents area swept (measure effort) log area swept entered model ‘offset’, , p=1−exp(−⋅n). p = 1 - \\exp(-\\cdot n). Therefore, encounter probability goes 1 area swept (effort) underlying group numbers density increase towards infinity. gets carried positive rate rr via pp r=nw/pr = nw/p.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"why-call-it-a-poisson-link","dir":"Articles","previous_headings":"FAQ","what":"Why call it a Poisson-link?","title":"Poisson-link delta models","text":"can guess. cloglog function derived theory Poisson although cloglog function appears ‘Poisson-link’ model, interaction two model components makes different pure cloglog assume needed another name.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/poisson-link.html","id":"these-equations-dont-look-anything-like-the-sdmtmb-source-code","dir":"Articles","previous_headings":"FAQ","what":"These equations don’t look anything like the sdmTMB source code!","title":"Poisson-link delta models","text":"’s calculations done log space computational stability calculations fastest stable done slightly differently easily described equations .","code":""},{"path":[]},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/presence-only.html","id":"presence-data","dir":"Articles","previous_headings":"Data","what":"Presence data","title":"Spatial Modeling of Presence-Only Data with sdmTMB","text":"data come spatstat package, consist point locations 3605 trees Barro Colorado Island (Panama). spatstat, data files kindly supplied Rasmus Waagepetersen data stored bei dataframe, distribution trees obviously uniform middle map trees.","code":"dat <- data.frame(   x = spatstat.data::bei$x,   y = spatstat.data::bei$y )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/presence-only.html","id":"generate-pseudo-absences","dir":"Articles","previous_headings":"Data","what":"Generate pseudo-absences","title":"Spatial Modeling of Presence-Only Data with sdmTMB","text":"several approaches generating pseudo-absences data. first use method called quadrature points (Renner et al. 2015). method, decide: Distribution zeroes Regularly spaced (e.g. grid lattice?) Random Higher density environmental variability high (suggestion Renner et al. 2015) many zeroes generate? Large enough predictive performance change added , use uniform grid strategy create ~5000 points. test whether number pseudo-absences sufficient, res can decreased, model performance can compared. instance, increase number pseudo-absences ~20,000 points, change res <- 5. example, increasing number zeroes ~20,000 marginally improves model performance, 5,000 zeroes sufficient. , combine presence pseudo-absence data, use $present separate occurrences pseudo-absences. Next can create mesh. resolution mesh can changed cutoff value, determines minimum distance locations X-Y units. Increasing cutoff decrease resolution mesh. example, higher resolution mesh cutoff=15 marginally improved model performance cutoff=25. dimensions mesh (number vertices knots) can accessed mesh$mesh$n. cutoff distance 15 yields ~ 1399 knots, cutoff distance 25 yields mesh 624 knots. following plot, blue dots data red grid dots quadrature points.","code":"res <- 10 # Determines resolution: lower value will increase number of zeroes generated  # zeros is generated on a grid for this example, but other strategies could be used zeros <- expand.grid(   x = seq(0, 1000, by = res),   y = seq(0, 500, by = res) ) dat$present <- 1 zeros$present <- 0 all_dat <- rbind(dat, zeros) mesh <- make_mesh(   all_dat,   xy_cols = c(\"x\", \"y\"),   cutoff = 15 # min. distance between knots in X-Y units )"},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/articles/presence-only.html","id":"infinitely-weighted-logistic-regression-iwlr-and-sdmtmb","dir":"Articles","previous_headings":"Model Options","what":"1) Infinitely Weighted Logistic Regression (IWLR) and sdmTMB","title":"Spatial Modeling of Presence-Only Data with sdmTMB","text":"Several approaches exist estimating model pseudo-absences. similar, different likelihood models. First, can use Infinitely Weighted Logistic Regression Fithian & Hastie (2013) model. first step calculate weights. Weights 1 true occurrences large number (nW) pseudo-absences. use sdmTMB fit model. can inspect model output. criticism approach intercept log-likelihood can affected nW (Renner et al. 2015)","code":"nW <- 1.0e6 all_dat$wt <- nW^(1 - all_dat$present) fit <- sdmTMB(   present ~ 1,   data = all_dat,   mesh = mesh,   family = binomial(link = \"logit\"),   weights = all_dat$wt ) summary(fit) #> Spatial model fit by ML ['sdmTMB'] #> Formula: present ~ 1 #> Mesh: mesh (isotropic covariance) #> Data: all_dat #> Family: binomial(link = 'logit') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)    -15.5    0.17 #>  #> Matérn range: 57.49 #> Spatial SD: 1.73 #> ML criterion at convergence: 52267.406 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/presence-only.html","id":"downweighted-poisson-regression-dwpr","dir":"Articles","previous_headings":"Model Options","what":"2) Downweighted Poisson Regression (DWPR)","title":"Spatial Modeling of Presence-Only Data with sdmTMB","text":"Another option Downweighted Poisson Regression, similar IWLR uses different weights doesn’t arbitrary effects intercept likelihood First re-calculate weights (note ’re different IWLR): fit model new weights Poisson distribution inspect output can plot random spatial effects  can predict spatial distribution link (log) space:  natural space:  evaluate predictive performance, multiple options binary data. AUC (Area receiver operating characteristic curve) common metric, values near 0.5 essentially random, values close 1 indicate better predictive performance. can use package ROCR.","code":"# small values at presence locations all_dat$wt <- 1e-6  # pseudo-absences: area per quadrature point tot_area <- diff(range(dat$x)) * diff(range(dat$y)) n_zeros <- length(which(all_dat$present == 0))  all_dat$wt <- ifelse(all_dat$present == 1,   1e-6, tot_area / n_zeros ) fit <- sdmTMB(   present / wt ~ 1,   data = all_dat,   mesh = mesh,   family = poisson(link = \"log\"),   weights = all_dat$wt ) summary(fit) #> Spatial model fit by ML ['sdmTMB'] #> Formula: present/wt ~ 1 #> Mesh: mesh (isotropic covariance) #> Data: all_dat #> Family: poisson(link = 'log') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)    -6.26    0.17 #>  #> Matérn range: 57.49 #> Spatial SD: 1.73 #> ML criterion at convergence: 65147.461 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. all_dat$p <- predict(fit)$est # total predictions, logit rocr <- ROCR::prediction(exp(all_dat$p), all_dat$present) ROCR::performance(rocr, measure = \"auc\")@y.values[[1]]"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/range-edges.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Calculating range edges","text":"Range edges useful metrics understanding species distributions change time. get_range_edge() function calculates range edges density-weighted quantiles along spatial axis (e.g., latitude, longitude, depth). approach follows methods used Fredston et al. 2021 VAST. Range edges calculated : Ordering spatial locations along user-specified axis Calculating cumulative proportion total density along axis Finding positions cumulative proportion equals target quantiles Using simulation joint precision matrix quantify uncertainty vignette, ’ll demonstrate calculating range edges Pacific Spiny Dogfish (Squalus suckleyi) along latitude axis west coast Vancouver Island.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/range-edges.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Calculating range edges","text":"’ll use built-dogfish dataset, contains fisheries-independent trawl survey data west coast Vancouver Island. data includes catch weights, presence/absence, depth, area swept. prediction, ’ll use wcvi_grid, provides spatial grid covering survey area:","code":"glimpse(dogfish) #> Rows: 1,458 #> Columns: 9 #> $ year         <int> 2004, 2004, 2004, 2004, 2004, 2004, 2004, 2004, 2004, 200… #> $ longitude    <dbl> -125.1928, -125.8362, -125.7952, -125.6383, -125.7022, -1… #> $ latitude     <dbl> 48.68167, 48.22183, 48.30733, 48.29017, 48.36000, 48.3645… #> $ X            <dbl> 780.2098, 734.9809, 737.6287, 749.3395, 744.2715, 737.449… #> $ Y            <dbl> 5399.066, 5345.797, 5355.425, 5354.015, 5361.570, 5361.78… #> $ present      <int> 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, … #> $ catch_weight <dbl> 22.7, 0.0, 0.0, 221.1, 439.8, 48.2, 13.5, 0.0, 47.9, 68.2… #> $ area_swept   <dbl> 0.10288, 0.10288, 0.11574, 0.12217, 0.09645, 0.12217, 0.1… #> $ depth        <dbl> 73, 455, 171, 137, 140, 145, 320, 279, 117, 70, 61, 77, 9… glimpse(wcvi_grid) #> Rows: 2,689 #> Columns: 3 #> $ X     <dbl> 733.9852, 735.9852, 737.9852, 735.9852, 737.9852, 739.9852, 735.… #> $ Y     <dbl> 5346.334, 5346.334, 5346.334, 5348.334, 5348.334, 5348.334, 5350… #> $ depth <dbl> 447, 442, 433, 312, 295, 400, 287, 233, 352, 449, 402, 390, 382,…"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/range-edges.html","id":"fitting-a-spatiotemporal-model","dir":"Articles","previous_headings":"","what":"Fitting a spatiotemporal model","title":"Calculating range edges","text":"First, ’ll construct mesh spatial random effects: Next, ’ll fit spatiotemporal model dogfish density using delta generalized-gamma family (Dunic et al. 2025). models positive catches generalized gamma distribution works well Pacific Dogfish given occasional giant outlying catch values. simpler Tweedie delta-gamma family used . ’ll include depth predictor using quadratic effect: model shows spatial spatiotemporal variation, depth strong relationship dogfish density.","code":"mesh <- make_mesh(dogfish, c(\"X\", \"Y\"), cutoff = 10) fit <- sdmTMB(   catch_weight ~ poly(log(depth), 2),   data = dogfish,   mesh = mesh,   family = delta_gengamma(type = \"poisson-link\"),   spatial = \"on\",   time = \"year\",   spatiotemporal = \"IID\" ) sanity(fit) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameters don't look unreasonably large fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: catch_weight ~ poly(log(depth), 2) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: dogfish #> Family: delta_gengamma(link1 = 'log', link2 = 'log', type = 'poisson-link') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'log')  #> Conditional model: #>                      coef.est coef.se #> (Intercept)              0.17    0.38 #> poly(log(depth), 2)1    -9.28    4.42 #> poly(log(depth), 2)2   -30.68    3.23 #>  #> Matérn range: 54.35 #> Spatial SD: 0.96 #> Spatiotemporal IID SD: 1.31 #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: gengamma(link = 'log')  #> Conditional model: #>                      coef.est coef.se #> (Intercept)              2.71    0.29 #> poly(log(depth), 2)1    -5.53    3.06 #> poly(log(depth), 2)2    -7.98    2.54 #>  #> Dispersion parameter: 1.08 #> Generalized gamma Q: -0.68 #> Matérn range: 86.75 #> Spatial SD: 0.24 #> Spatiotemporal IID SD: 0.46 #>  #> ML criterion at convergence: 5523.459 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/range-edges.html","id":"making-predictions","dir":"Articles","previous_headings":"","what":"Making predictions","title":"Calculating range edges","text":"calculate range edges, need make predictions spatial grid covers area interest. ’ll replicate wcvi_grid year dataset generate predictions simulation: predict() function nsim > 0 returns matrix column represents one simulation draw joint precision matrix.","code":"# Create prediction grid for each year years <- sort(unique(dogfish$year)) nd <- replicate_df(wcvi_grid, \"year\", years)  # Make predictions with simulations for uncertainty quantification # Using nsim = 200 simulations from the joint precision matrix # larger simulations will be more stable at the expense of speed and memory set.seed(123) pred <- predict(fit, newdata = nd, nsim = 200)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/range-edges.html","id":"calculating-range-edges","dir":"Articles","previous_headings":"","what":"Calculating range edges","title":"Calculating range edges","text":"Now can calculate range edges along latitude axis (Y coordinate). default, get_range_edge() calculates 2.5% 97.5% quantiles, representing lower upper range edges. , ’ll also add median (0.5) find center distribution. output includes: year: time slice quantile: quantile value (0.025 lower edge, 0.500 median, 0.975 upper edge) est: estimated position along axis (latitude case) lwr upr: 95% confidence intervals quantile se: standard error quantile","code":"edges <- get_range_edge(pred, axis = nd$Y, quantiles = c(0.025, 0.50, 0.975)) head(edges) #>   year quantile      est      lwr      upr        se #> 1 2004    0.025 5360.334 5356.334 5366.334  2.847127 #> 2 2004    0.500 5392.334 5384.334 5416.334  8.386996 #> 3 2004    0.975 5570.334 5510.334 5590.334 22.087935 #> 4 2006    0.025 5358.334 5354.334 5362.334  1.853287 #> 5 2006    0.500 5436.334 5414.334 5458.334 10.086017 #> 6 2006    0.975 5582.334 5559.884 5590.384  9.733245"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/range-edges.html","id":"visualizing-range-edges","dir":"Articles","previous_headings":"","what":"Visualizing range edges","title":"Calculating range edges","text":"can plot range edges change time:  plot shows northern southern range edges dogfish shifted time, uncertainty bands reflecting sampling estimation uncertainty. median line represents center distribution.","code":"ggplot(edges, aes(year, est, colour = as.factor(quantile))) +   geom_line(linewidth = 1) +   geom_ribbon(     aes(ymin = lwr, ymax = upr, fill = as.factor(quantile)),     alpha = 0.2,     colour = NA   ) +   labs(     x = \"Year\",     y = \"Latitude (UTM km)\",     colour = \"Quantile\",     fill = \"Quantile\"   ) +   scale_colour_discrete(labels = c(\"5%\", \"50%\", \"95%\")) +   scale_fill_discrete(labels = c(\"5%\", \"50%\", \"95%\")) +   theme_light()"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/range-edges.html","id":"accessing-simulation-draws","dir":"Articles","previous_headings":"","what":"Accessing simulation draws","title":"Calculating range edges","text":"custom analyses, can access raw simulation draws: returns simulation draws long format, can useful : Custom uncertainty quantification Calculating probabilities range shifts Comparing range edges models scenarios example, calculate probability upper range edge (northern edge) shifted northward two time periods: can plot distibution:  anything, northern range contracted , consistent previous research stock (Ward et al. 2024).","code":"edges_sims <- get_range_edge(pred, axis = nd$Y, return_sims = TRUE) head(edges_sims) #>   year quantile   .value .iteration #> 1 2004    0.025 5362.334          1 #> 2 2004    0.025 5358.334          2 #> 3 2004    0.025 5358.334          3 #> 4 2004    0.025 5358.334          4 #> 5 2004    0.025 5356.334          5 #> 6 2004    0.025 5362.334          6 # Extract simulations for upper edge in first and last year upper_first <- edges_sims |>   filter(quantile == 0.975, year == min(year))  upper_last <- edges_sims |>   filter(quantile == 0.975, year == max(year))  # Calculate shift for each simulation shifts <- upper_last$.value - upper_first$.value[match(upper_last$.iteration, upper_first$.iteration)]  # Probability of northward shift prob_north <- mean(shifts > 0) cat(\"Probability of northward shift:\", round(prob_north * 100, 1), \"%\\n\") #> Probability of northward shift: 41 % ggplot(data.frame(shifts = shifts), aes(shifts)) + geom_histogram() #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/range-edges.html","id":"other-axes","dir":"Articles","previous_headings":"","what":"Other axes","title":"Calculating range edges","text":"’ve demonstrated using latitude (Y), range edges can calculated along spatial axis. Common choices include: Longitude (X): east-west range shifts Depth: depth range edges (e.g., shallow vs. deep distribution limits) Coastal distance: offshore/onshore distribution patterns Temperature: environmental covariates prediction grid Simply provide appropriate vector axis argument.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/range-edges.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Calculating range edges","text":"Dunic, J.C., Conner, J., Anderson, S.C., Thorson, J.T. 2025. generalized gamma flexible distribution outperforms alternatives modelling catch rate data. ICES Journal Marine Science 82(4): fsaf040. https://doi.org/10.1093/icesjms/fsaf040 Fredston, . L., Pinsky, M., Selden, R. L., Szuwalski, C., Thorson, J. T., Gaines, S. D., & Halpern, B. S. (2021). Range edges North American marine species tracking temperature decades. Global Change Biology, 27(13), 3145-3156. https://doi.org/10.1111/gcb.15614 Ward, E.J., Anderson, S.C., Barnett, L..K., English, P.., Berger, H.M., Commander, C.J.C., Essington, T.E., Harvey, C.J., Hunsicker, M.E., Jacox, M.G., Johnson, K.F., Large, S., Liu, O.R., Richerson, K.E., Samhouri, J.F., Siedlecki, S.., Shelton, .O., Somers, K.., Watson, J.T. 2024. Win, lose, draw: Evaluating dynamic thermal niches northeast Pacific groundfish. PLOS Climate 3(11): e0000454. Public Library Science. https://doi.org/10.1371/journal.pclm.0000454","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html","id":"residual-checking-with-worked-examples","dir":"Articles","previous_headings":"","what":"Residual checking with worked examples","title":"Residual checking with sdmTMB","text":"start data simulated scratch. simulate NB2 negative binomial observation model, spatial random field, intercept, one predictor named ‘a1’ linear effect observed data. Next, fit model configurations various families predictors. first model use Poisson instead NB2. 2nd model match simulated data. third model missing ‘a1’ predictor. ’ll use penalized complexity (PC) prior Matérn parameters aid estimation. can see just looking fits Poisson model inflates spatial random field standard deviation (SD) compared truth. model missing ‘a1’ predictor lesser degree.","code":"library(sdmTMB) set.seed(1) predictor_dat <- data.frame(X = runif(1000), Y = runif(1000), a1 = rnorm(1000)) mesh <- make_mesh(predictor_dat, xy_cols = c(\"X\", \"Y\"), cutoff = 0.1) dat <- sdmTMB_simulate(   formula = ~ 1 + a1,   data = predictor_dat,   mesh = mesh,   family = nbinom2(link = \"log\"),   phi = 0.4,   range = 0.4,   sigma_O = 0.4,   seed = 1,   B = c(0.2, 0.8) # B0 = intercept, B1 = a1 slope ) pc <- pc_matern(range_gt = 0.1, sigma_lt = 1)  fit_pois <- sdmTMB(observed ~ 1 + a1, data = dat, family = poisson(), mesh = mesh,   priors = sdmTMBpriors(matern_s = pc)) fit_pois #> Spatial model fit by ML ['sdmTMB'] #> Formula: observed ~ 1 + a1 #> Mesh: mesh (isotropic covariance) #> Data: dat #> Family: poisson(link = 'log') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)     0.27    0.17 #> a1              0.82    0.02 #>  #> Matérn range: 0.12 #> Spatial SD: 1.20 #> ML criterion at convergence: 2887.957 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  fit_nb2 <- update(fit_pois, family = nbinom2()) fit_nb2 #> Spatial model fit by ML ['sdmTMB'] #> Formula: observed ~ 1 + a1 #> Family: nbinom2(link = 'log') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)     0.52    0.14 #> a1              0.75    0.06 #>  #> Dispersion parameter: 0.41 #> Matérn range: 0.29 #> Spatial SD: 0.42 #> ML criterion at convergence: 1735.452 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  fit_nb2_miss <- update(fit_nb2, formula. = observed ~ 1) fit_nb2_miss #> Spatial model fit by ML ['sdmTMB'] #> Formula: observed ~ 1 #> Family: nbinom2(link = 'log') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)     0.77    0.14 #>  #> Dispersion parameter: 0.30 #> Matérn range: 0.21 #> Spatial SD: 0.56 #> ML criterion at convergence: 1817.332 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html","id":"analytical-randomized-quantile-residuals","dir":"Articles","previous_headings":"Residual checking with worked examples","what":"Analytical randomized-quantile residuals","title":"Residual checking with sdmTMB","text":"randomized quantile residuals fixed effect MLEs (Maximum Likelihood Estimates) random effects taken single sample approximate distribution (details ):   use randomized quantile approach Dunn Smyth (1996). also known PIT (probability-integral-transform) residuals. apply randomization integer response values, transform residuals using distribution function (e.g., pnorm()) reflect uniform(0, 1) distribution, transform values normal(0, 1) consistent model. can see source code https://github.com/sdmTMB/sdmTMB/blob/master/R/residuals.R can see likely issues Poisson model tails.","code":"set.seed(123) rq_res <- residuals(fit_pois, type = \"mle-mvn\") rq_res <- rq_res[is.finite(rq_res)] # some Inf qqnorm(rq_res);abline(0, 1) set.seed(123) rq_res <- residuals(fit_nb2, type = \"mle-mvn\") qqnorm(rq_res);abline(0, 1)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html","id":"mcmc-based-randomized-quantile-residuals","dir":"Articles","previous_headings":"Residual checking with worked examples","what":"MCMC-based randomized-quantile residuals","title":"Residual checking with sdmTMB","text":"approach assumes observation random effects can approximated multivariate normal distribution. want relax assumption, can sample random effects MCMC fixed effects held MLEs. sdmTMBextra::predict_mle_mcmc() function sdmTMBextra.","code":"set.seed(123) samps <- sdmTMBextra::predict_mle_mcmc(fit_nb2, mcmc_iter = 800, mcmc_warmup = 400) #>  #> SAMPLING FOR MODEL 'tmb_generic' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.0011 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 11 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:   1 / 800 [  0%]  (Warmup) #> Chain 1: Iteration:  80 / 800 [ 10%]  (Warmup) #> Chain 1: Iteration: 160 / 800 [ 20%]  (Warmup) #> Chain 1: Iteration: 240 / 800 [ 30%]  (Warmup) #> Chain 1: Iteration: 320 / 800 [ 40%]  (Warmup) #> Chain 1: Iteration: 400 / 800 [ 50%]  (Warmup) #> Chain 1: Iteration: 401 / 800 [ 50%]  (Sampling) #> Chain 1: Iteration: 480 / 800 [ 60%]  (Sampling) #> Chain 1: Iteration: 560 / 800 [ 70%]  (Sampling) #> Chain 1: Iteration: 640 / 800 [ 80%]  (Sampling) #> Chain 1: Iteration: 720 / 800 [ 90%]  (Sampling) #> Chain 1: Iteration: 800 / 800 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 6.777 seconds (Warm-up) #> Chain 1:                4.906 seconds (Sampling) #> Chain 1:                11.683 seconds (Total) #> Chain 1: mcmc_res <- residuals(fit_nb2, type = \"mle-mcmc\", mcmc_samples = samps) qqnorm(mcmc_res) abline(0, 1)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html","id":"simulation-based-randomized-quantile-residuals","dir":"Articles","previous_headings":"Residual checking with worked examples","what":"Simulation-based randomized-quantile residuals","title":"Residual checking with sdmTMB","text":"can also take simulations fitted model use simulation-based randomized quantile residuals: return matrix row represents row data column simulation draw: can look whether fitted models consistent observed number zeros: obviously zeros data simulated Poisson model NB2 model seems reasonable. Plot DHARMa residuals:  also return DHARMa object, lets us use DHARMa tools:     QQ residual plots clearly see evidence overdispersion compared Poisson. Note values clumping near 1.0 observed axis deviating downwards towards 0.0 observed. indicative many zeros variance scaling rapidly mean (resulting large outlying value) Poisson distribution. Lets try correct model:   Everything looks fine. model missing predictor?  plot right represents simulated residuals prediction without random effects, just intercept. Lets try plotting residuals missing predictor:  can see trend residuals ‘a1’ since missed including model. can also see difference log likelihood AIC: AIC also supports including ‘a1’ predictor. help interpreting DHARMa residual plots, see vignette(\"DHARMa\", package=\"DHARMa\").","code":"s_pois <- simulate(fit_pois, nsim = 500, type = \"mle-mvn\") s_nb2_miss <- simulate(fit_nb2_miss, nsim = 500, type = \"mle-mvn\") s_nb2 <- simulate(fit_nb2, nsim = 500, type = \"mle-mvn\") dim(s_pois) #> [1] 1000  500 sum(dat$observed == 0) / length(dat$observed) #> [1] 0.527 sum(s_pois == 0)/length(s_pois) #> [1] 0.292788 sum(s_nb2 == 0)/length(s_nb2) #> [1] 0.524644 dharma_residuals(s_pois, fit_pois) r_pois <- dharma_residuals(s_pois, fit_pois, return_DHARMa = TRUE) plot(r_pois) DHARMa::testResiduals(r_pois) #> $uniformity #>  #>  Asymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  simulationOutput$scaledResiduals #> D = 0.23338, p-value < 2.2e-16 #> alternative hypothesis: two-sided #>  #>  #> $dispersion #>  #>  DHARMa nonparametric dispersion test via sd of residuals fitted vs. #>  simulated #>  #> data:  simulationOutput #> dispersion = 8.6989, p-value < 2.2e-16 #> alternative hypothesis: two.sided #>  #>  #> $outliers #>  #>  DHARMa outlier test based on exact binomial test with approximate #>  expectations #>  #> data:  simulationOutput #> outliers at both margin(s) = 111, observations = 1000, p-value < #> 2.2e-16 #> alternative hypothesis: true probability of success is not equal to 0.003992016 #> 95 percent confidence interval: #>  0.09219791 0.13212606 #> sample estimates: #> frequency of outliers (expected: 0.00399201596806387 )  #>                                                  0.111 DHARMa::testSpatialAutocorrelation(r_pois, x = dat$X, y = dat$Y) #>  #>  DHARMa Moran's I test for distance-based autocorrelation #>  #> data:  r_pois #> observed = -0.0022978, expected = -0.0010010, sd = 0.0026264, p-value = #> 0.6215 #> alternative hypothesis: Distance-based autocorrelation DHARMa::testZeroInflation(r_pois) #>  #>  DHARMa zero-inflation test via comparison to expected zeros with #>  simulation under H0 = fitted model #>  #> data:  simulationOutput #> ratioObsSim = 1.7999, p-value < 2.2e-16 #> alternative hypothesis: two.sided r_nb2 <- dharma_residuals(s_nb2, fit_nb2, return_DHARMa = TRUE) plot(r_nb2) DHARMa::testZeroInflation(r_nb2) #>  #>  DHARMa zero-inflation test via comparison to expected zeros with #>  simulation under H0 = fitted model #>  #> data:  simulationOutput #> ratioObsSim = 1.0045, p-value = 0.908 #> alternative hypothesis: two.sided r_nb2_miss <- dharma_residuals(s_nb2_miss, fit_nb2_miss, return_DHARMa = TRUE) plot(r_nb2_miss) DHARMa::plotResiduals(r_nb2_miss, form = dat$a1) AIC(fit_nb2_miss, fit_nb2) #>              df      AIC #> fit_nb2_miss  4 3642.665 #> fit_nb2       5 3480.904"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html","id":"the-need-for-one-sample-residuals","dir":"Articles","previous_headings":"","what":"The need for one-sample residuals","title":"Residual checking with sdmTMB","text":"used random effects drawn observed . approach described Waagepetersen (2006) summarized nicely unexported function oneSamplePosterior within TMB. Thygesen et al. (2017) also describes context one-sample MCMC residuals. show necessary. ’ll start simulating data Gaussian observation error spatial spatiotemporal random effects. use empirical Bayes (EB) random effect values (values random effects maximize log likelihood conditional estimated fixed effects), residuals look even though model perfectly matched simulated data:  Indeed, test (incorrectly) rejects null hypothesis r1∼N(0,1)r_1 \\sim \\operatorname{N}(0, 1), calculated correctly know come N(0,1)\\operatorname{N}(0, 1) instead returned single sample assumed MVN random effect distribution, get ‘correct’ residuals:  , (correctly) fail reject hypothesis r2∼N(0,1)r_2 \\sim \\operatorname{N}(0, 1). also sample observation random effects using MCMC (fixed effects still held MLEs), relaxes assumptions, much time intensive large models.  gets us something similar (correctly) fail reject hypothesis r3∼N(0,1)r_3 \\sim \\operatorname{N}(0, 1). similar issue applies simulation-based quantile residuals, implemented DHARMa package.  Instead can use draw random effects ‘posterior’ assuming MVN distribution.  now looks correct. However, happens sample random effects simulation?  get back something incorrect distribution comparison! , need single random effects sample per set simulations.","code":"set.seed(123) predictor_dat <- data.frame(   X = runif(1000), Y = runif(1000),   year = rep(1:5, each = 200) ) mesh <- make_mesh(predictor_dat, xy_cols = c(\"X\", \"Y\"), cutoff = 0.1) sim_dat <- sdmTMB_simulate(   formula = ~ 1,   data = predictor_dat,   time = \"year\",   mesh = mesh,   family = gaussian(),   range = 0.3,   sigma_E = 0.3,   phi = 0.1,   sigma_O = 0.4,   seed = 1,   B = 0.2 # intercept ) fit <- sdmTMB(observed ~ 1, data = sim_dat, time = \"year\", mesh = mesh) set.seed(1) r1 <- residuals(fit, type = \"mle-eb\") qqnorm(r1);abline(0, 1) ks.test(r1, pnorm) #>  #>  Asymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  r1 #> D = 0.058629, p-value = 0.002067 #> alternative hypothesis: two-sided set.seed(1) r2 <- residuals(fit, type = \"mle-mvn\") qqnorm(r2);abline(0, 1) ks.test(r2, pnorm) #>  #>  Asymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  r2 #> D = 0.020639, p-value = 0.7879 #> alternative hypothesis: two-sided samp <- sdmTMBextra::predict_mle_mcmc(fit, mcmc_iter = 400, mcmc_warmup = 200) #>  #> SAMPLING FOR MODEL 'tmb_generic' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.002162 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 21.62 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:   1 / 400 [  0%]  (Warmup) #> Chain 1: Iteration:  40 / 400 [ 10%]  (Warmup) #> Chain 1: Iteration:  80 / 400 [ 20%]  (Warmup) #> Chain 1: Iteration: 120 / 400 [ 30%]  (Warmup) #> Chain 1: Iteration: 160 / 400 [ 40%]  (Warmup) #> Chain 1: Iteration: 200 / 400 [ 50%]  (Warmup) #> Chain 1: Iteration: 201 / 400 [ 50%]  (Sampling) #> Chain 1: Iteration: 240 / 400 [ 60%]  (Sampling) #> Chain 1: Iteration: 280 / 400 [ 70%]  (Sampling) #> Chain 1: Iteration: 320 / 400 [ 80%]  (Sampling) #> Chain 1: Iteration: 360 / 400 [ 90%]  (Sampling) #> Chain 1: Iteration: 400 / 400 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 32.987 seconds (Warm-up) #> Chain 1:                32.58 seconds (Sampling) #> Chain 1:                65.567 seconds (Total) #> Chain 1: #> Warning: The largest R-hat is 1.07, indicating chains have not mixed. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#r-hat #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess r3 <- residuals(fit, type = \"mle-mcmc\", mcmc_samples = samp) qqnorm(r3);abline(0, 1) ks.test(r3, pnorm) #>  #>  Asymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  r3 #> D = 0.024973, p-value = 0.561 #> alternative hypothesis: two-sided set.seed(1) simulate(fit, nsim = 500, type = \"mle-eb\") |>   dharma_residuals(fit) #> Warning: It is recommended to use `simulate.sdmTMB(fit, type = 'mle-mvn')` if simulating #> for DHARMa residuals. See the description in ?residuals.sdmTMB under the types #> of residuals section. set.seed(1) simulate(fit, nsim = 500, type = \"mle-mvn\") |>   dharma_residuals(fit) set.seed(1) s <- replicate(200, simulate(fit, nsim = 1, type = \"mle-mvn\"), simplify = \"matrix\") attr(s, \"type\") <- \"mle-mvn\" dharma_residuals(s, fit)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html","id":"how-much-this-matters-depends-on-the-ratio-of-observation-error-variance-vs--random-effect-variance","dir":"Articles","previous_headings":"","what":"How much this matters depends on the ratio of observation error variance vs. random effect variance","title":"Residual checking with sdmTMB","text":"Lets simulate data large observation error (phi , Gaussian error SD case) smaller levels random field variance (sigma_E sigma_O):   Now, doesn’t really matter since ‘incorrect’ random effect distribution swamped observation error effect distribution. Technically, first set ‘wrong’ second set ‘right’, functionally ’d come similar conclusion case.","code":"set.seed(123) sim_dat2 <- sdmTMB_simulate(   formula = ~ 1,   data = predictor_dat,   time = \"year\",   mesh = mesh,   family = gaussian(),   range = 0.3,   sigma_E = 0.1, # smaller than before   sigma_O = 0.1, # smaller than before   phi = 0.5, # bigger than before   seed = 1,   B = 0.2  ) fit2 <- sdmTMB(observed ~ 1, data = sim_dat2, time = \"year\", mesh = mesh) sanity(fit2) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameter doesn't look unreasonably large set.seed(1) r1 <- residuals(fit2, type = \"mle-eb\") qqnorm(r1);abline(0, 1) ks.test(r1, pnorm) #>  #>  Asymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  r1 #> D = 0.021085, p-value = 0.7656 #> alternative hypothesis: two-sided r2 <- residuals(fit2, type = \"mle-mvn\") qqnorm(r2);abline(0, 1) ks.test(r2, pnorm) #>  #>  Asymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  r2 #> D = 0.016869, p-value = 0.9385 #> alternative hypothesis: two-sided"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html","id":"notes-on-uniform-vs--normal-quantile-residuals","dir":"Articles","previous_headings":"","what":"Notes on uniform vs. normal quantile residuals","title":"Residual checking with sdmTMB","text":"randomized quantile residuals residuals.sdmTMB() returned normal(0, 1) model consistent data. DHARMa residuals, however, returned uniform(0, 1) circumstances. valid, use preference, ’s important appreciate changes appearance expected residuals. Analytical normal(0, 1):   Analytical uniform(0, 1):   Simulation-based uniform(0, 1):   Simulation-based normal(0, 1):  Conclusions: normal(0, 1) residuals probably familiar people. normal(0, 1) residuals put emphasis tails. good bad: ’s easier examine tail behaviour, can often look ‘’ even model fine (example) observations tails distribution definition rarely observed. Uniform(0, 1) residuals give data points equal visual weight emphasize consistency overall distribution rather tails. Either valid, need switch mindset expect see accordingly. example, poor tail behaviour may look like minor issue uniform residuals; conversely tails normal(0, 1) residuals unlikely ever look ‘perfect’ without large sample sizes.","code":"r2 <- residuals(fit2, type = \"mle-mvn\") hist(r2) qqnorm(r2) abline(0, 1) ks.test(r2, pnorm) #>  #>  Asymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  r2 #> D = 0.025614, p-value = 0.528 #> alternative hypothesis: two-sided u <- pnorm(r2) hist(u) n <- length(u) m <- seq_len(n) / (n + 1) qqplot(m, u) ks.test(u, punif) #>  #>  Asymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  u #> D = 0.025614, p-value = 0.528 #> alternative hypothesis: two-sided abline(0, 1) set.seed(1) s <- simulate(fit2, nsim = 500, type = \"mle-mvn\") |>   dharma_residuals(fit2, return_DHARMa = TRUE) hist(s$scaledResiduals) u <- s$scaledResiduals m <- seq_len(length(u)) / (length(u)+ 1) qqplot(m, u) abline(0, 1) ks.test(u, punif) #>  #>  Asymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  u #> D = 0.026, p-value = 0.5085 #> alternative hypothesis: two-sided set.seed(1) s <- simulate(fit2, nsim = 1500, type = \"mle-mvn\") |>   dharma_residuals(fit2, return_DHARMa = TRUE) u <- s$scaledResiduals r <- qnorm(u) qqnorm(r) abline(0, 1) ks.test(u, punif) #>  #>  Asymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  u #> D = 0.028, p-value = 0.4131 #> alternative hypothesis: two-sided"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html","id":"how-do-those-randomized-quantile-residuals-work","dir":"Articles","previous_headings":"","what":"How do those randomized-quantile residuals work?","title":"Residual checking with sdmTMB","text":"Let’s work simple example gamma distribution: get quantile residuals, transform uniform(0, 1) using pgamma() (optionally) convert normal(0, 1) qnorm():   works distribution can define quantile function. integer values, need add randomization additional step. Let’s work Poisson sample: gamma example illustrated can use distribution function (pgamma()) take gamma-distributed variable turn uniform-distributed variable. Now need Poisson equivalent: ppois(). ppois(y) function gives us cumulative probability density value y. Say Poisson variable mean (lambda) 5 observation value 3. can calculate density value 3 : .e., : , naively apply ppois() observed values ’ll end discrete cumulative probabilities aren’t useful comparing continuous uniform.  Instead, need get probability density value one observed “fill ” values observed value desired uniformly distributed samples. First, get density value observed value:   can add randomization using runif() since expectation uniform distribution stage fill values :  optionally apply qnorm():","code":"set.seed(1) mu <- rep(2, 500) phi <- 0.5 y <- rgamma(length(mu), shape = phi, scale = mu / phi) u <- pgamma(q = y, shape = phi, scale = mu / phi) hist(u) r <- qnorm(u) hist(r) set.seed(1) mu <- rep(2, 500) y <- rpois(length(mu), mu) lambda <- 5 ppois(3, lambda) #> [1] 0.2650259 dpois(0, lambda) + dpois(1, lambda) + dpois(2, lambda) + dpois(3, lambda) #> [1] 0.2650259 hist(ppois(y, mu)) a <- ppois(y - 1, mu) hist(a) b <- ppois(y, mu) hist(b) u <- runif(n = length(y), min = a, max = b) hist(u) r <- qnorm(u) hist(r)"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html","id":"how-do-those-simulation-based-residuals-work","dir":"Articles","previous_headings":"","what":"How do those simulation-based residuals work?","title":"Residual checking with sdmTMB","text":"DHARMa uses simulation-based quantile residuals. result, don’t need define quantile function analytically. , instead line like : simulate model repeatedly, see observation falls within simulated values, get quantile way. example, instead : :","code":"u <- pgamma(q = y, shape = phi, scale = mu / phi) pnorm(2.2, mean = 0.5, sd = 1) #> [1] 0.9554345 set.seed(1) s <- rnorm(1e6, 0.5, 1) # equivalent of simulate()ing from our model mean(s < 2.2) # equivalent of pnorm() #> [1] 0.955308"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Residual checking with sdmTMB","text":"Dunn, P.K., Smyth, G.K. 1996. Randomized Quantile Residuals. Journal Computational Graphical Statistics 5(3): 236–244. Waagepetersen, R. 2006. Simulation-Based Goodness--Fit Test Random Effects Generalized Linear Mixed Models. Scandinavian Journal Statistics 33(4): 721–731. Thygesen, U.H., Albertsen, C.M., Berg, C.W., Kristensen, K., Nielsen, . 2017. Validation ecological state space models using Laplace approximation. Environ Ecol Stat 24(2): 317–339.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/visreg.html","id":"delta-models","dir":"Articles","previous_headings":"","what":"Delta models","title":"Visualizing sdmTMB conditional effects using visreg","text":"visreg() can also used plot output delta models sdmTMB() using similar code previous plots, using sdmTMB wrapper function visreg_delta() specifying model = 1 encounter (0 vs. non-zero) model model = 2 positive component model (e.g., Gamma, lognormal). example:   Note plotting visreg_delta(), categorical variables like year need designated factor data frame, example fyear, rather model formula (e.g., + .factor(year)).","code":"fit_dg <- sdmTMB(   density ~ s(depth_scaled, year, k = 8),   data = pcod_2011,   mesh = pcod_mesh_2011,   spatial = \"off\", # for vignette speed   family = delta_gamma() )  visreg_delta(fit_dg, xvar = \"depth_scaled\", model = 1, gg = TRUE) #> These are residuals for delta model component 1. Use the `model` argument to #> select the other component. visreg_delta(fit_dg, xvar = \"depth_scaled\", model = 2, gg = TRUE) #> These are residuals for delta model component 2. Use the `model` argument to #> select the other component."},{"path":"https://sdmTMB.github.io/sdmTMB/articles/zoib.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Zero-one-inflated beta (ZOIB) models with sdmTMB","text":"Zero-one-inflated beta (ZOIB) models used modeling proportional data (values bounded 0 1) include excess zeros /ones beyond expected standard beta distribution. models useful analyzing data : Species abundance proportion maximum capacity Habitat suitability indices Proportional cover data ecology response variable true proportion potential inflation boundaries ZOIB model consists three components: zero component: models probability zero value (typically using binomial/logit model) one component: models probability one value (typically using binomial/logit model) proportion component: models continuous proportion 0 1 (typically using beta distribution) final prediction combines three components: 𝔼[Y]=(1−p0)×(p1+(1−p1)×μ)\\mathbb{E}[Y] = (1 - p_0) \\times (p_1 + (1 - p_1) \\times \\mu) p0p_0 probability zero, p1p_1 probability one (given zero), μ\\mu expected proportion beta component. Currently, sdmTMB built-ZOIB family. However, ZOIB models can implemented fitting three separate models combining predictions. vignette demonstrates approach.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/articles/zoib.html","id":"simulating-zoib-data","dir":"Articles","previous_headings":"","what":"Simulating ZOIB data","title":"Zero-one-inflated beta (ZOIB) models with sdmTMB","text":"Let’s simulate data ZOIB process illustrate fit models sdmTMB. First, ’ll set parameters simulation: Now ’ll simulate three components: Finally, combine components create ZOIB response:  plot shows characteristic ZOIB pattern: data concentrated 0 1, continuous values .","code":"set.seed(123) N <- 800 x <- rnorm(N)  # Coefficients for the zero component (logit scale) b_0 <- c(-1, -0.4)  # Coefficients for the one component (logit scale) b_1 <- c(-1, 0.6)  # Coefficients for the proportion component (logit scale for mean) b_prop <- c(0.2, 0.5)  # Precision parameter for beta distribution phi <- 30 # Zero component: probability of observing a zero p <- plogis(cbind(rep(1, N), x) %*% b_0) y_p <- rbinom(N, 1, p)  # One component: probability of observing a one (given not zero) q <- plogis(cbind(rep(1, N), x) %*% b_1) y_q <- rbinom(N, 1, q)  # Proportion component: beta-distributed values between 0 and 1 mu <- plogis(cbind(rep(1, N), x) %*% b_prop) a <- phi * mu b <- phi * (1 - mu) y_r <- rbeta(N, a, b) y <- numeric(length = N) y[y_p == 1] <- 0 y[y_p != 1 & y_q == 1] <- 1 y[y_p != 1 & y_q != 1] <- y_r[y_p != 1 & y_q != 1]  dat <- data.frame(x, y) ggplot(dat, aes(x, y)) +   geom_point(alpha = 0.5) +   labs(x = \"Predictor\", y = \"Response (proportion)\")"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/zoib.html","id":"fitting-the-zoib-model-components","dir":"Articles","previous_headings":"","what":"Fitting the ZOIB model components","title":"Zero-one-inflated beta (ZOIB) models with sdmTMB","text":"fit ZOIB model sdmTMB, fit three separate models combine predictions. First, prepare data component: Now fit three models. example, turn spatial effects spatial = \"\", practice include spatial spatiotemporal random fields components: Let’s check well recovered simulation parameters: estimated coefficients close true values used simulation.","code":"# Zero component: 1 if zero, 0 otherwise dat$y_zero <- ifelse(dat$y == 0, 1, 0)  # One component: 1 if one, 0 if between 0 and 1, NA if zero dat$y_one <- ifelse(dat$y == 1, 1, ifelse(dat$y < 1 & dat$y != 0, 0, NA))  # Proportion component: the value itself, but only for values between 0 and 1 dat$y_proportion <- ifelse(dat$y < 1 & dat$y > 0, dat$y, NA) # Model 1: Zero component fit_zero <- sdmTMB(   y_zero ~ x,   data = dat,   family = binomial(link = \"logit\"),   spatial = \"off\" )  # Model 2: One component (excluding zeros) fit_one <- sdmTMB(   y_one ~ x,   data = subset(dat, !is.na(y_one)),   family = binomial(link = \"logit\"),   spatial = \"off\" )  # Model 3: Proportion component (values between 0 and 1) fit_proportion <- sdmTMB(   y_proportion ~ x,   data = subset(dat, !is.na(y_proportion)),   family = Beta(link = \"logit\"),   spatial = \"off\" ) # Zero component coefficients coef(fit_zero) #> (Intercept)           x  #>  -0.8702097  -0.4254690 b_0 #> [1] -1.0 -0.4  # One component coefficients coef(fit_one) #> (Intercept)           x  #>  -1.0390158   0.7738772 b_1 #> [1] -1.0  0.6  # Proportion component coefficients coef(fit_proportion) #> (Intercept)           x  #>   0.2114247   0.4901013 b_prop #> [1] 0.2 0.5  # Precision parameter tidy(fit_proportion, \"ran_pars\") #> # A tibble: 1 × 5 #>   term  estimate std.error conf.low conf.high #>   <chr>    <dbl>     <dbl>    <dbl>     <dbl> #> 1 phi       29.6      2.09     25.8      34.0 phi #> [1] 30"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/zoib.html","id":"making-predictions","dir":"Articles","previous_headings":"","what":"Making predictions","title":"Zero-one-inflated beta (ZOIB) models with sdmTMB","text":"make predictions ZOIB model, need : Generate predictions component Combine using ZOIB formula First, create new data frame prediction:","code":"nd <- data.frame(x = seq(min(x), max(x), length.out = 100))"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/zoib.html","id":"point-predictions","dir":"Articles","previous_headings":"Making predictions","what":"Point predictions","title":"Zero-one-inflated beta (ZOIB) models with sdmTMB","text":"Generate point predictions component combine: Plot predictions:","code":"# Get predictions on the response scale (probabilities/proportions) p0 <- plogis(predict(fit_zero, newdata = nd)$est) p1 <- plogis(predict(fit_one, newdata = nd)$est) pp <- plogis(predict(fit_proportion, newdata = nd)$est)  # Combine using ZOIB formula: E[Y] = (1 - p0) * (p1 + (1 - p1) * pp) nd$est <- (1 - p0) * (p1 + (1 - p1) * pp) ggplot(dat, aes(x, y)) +   geom_point(alpha = 0.5) +   geom_line(aes(x, est), data = nd, colour = \"red\", linewidth = 1) +   labs(     x = \"Predictor\", y = \"Response (proportion)\",     title = \"ZOIB model predictions\"   )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/zoib.html","id":"predictions-with-uncertainty","dir":"Articles","previous_headings":"Making predictions","what":"Predictions with uncertainty","title":"Zero-one-inflated beta (ZOIB) models with sdmTMB","text":"incorporate parameter uncertainty, use can use simulation-based inference. predict() function nsim draw joint precision matrix fixed effects random effects: Plot uncertainty bands:  red line shows median prediction shaded region shows 95% credible interval accounting parameter uncertainty.","code":"# Generate simulation draws from each model p0 <- plogis(predict(fit_zero, newdata = nd, nsim = 500)) p1 <- plogis(predict(fit_one, newdata = nd, nsim = 500)) pp <- plogis(predict(fit_proportion, newdata = nd, nsim = 500))  # Combine the simulations combined <- (1 - p0) * (p1 + (1 - p1) * pp)  # Calculate median and credible intervals nd$est2 <- apply(combined, 1, median) nd$lwr <- apply(combined, 1, quantile, probs = 0.025) nd$upr <- apply(combined, 1, quantile, probs = 0.975) ggplot() +   geom_point(data = dat, aes(x = x, y = y), alpha = 0.3) +   geom_ribbon(     data = nd, aes(x = x, ymin = lwr, ymax = upr),     fill = \"red\", alpha = 0.3   ) +   geom_line(     data = nd, aes(x = x, y = est2),     colour = \"red\", linewidth = 1   ) +   labs(     x = \"Predictor\", y = \"Response (proportion)\",     title = \"ZOIB predictions with 95% credible intervals\"   )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/zoib.html","id":"comparison-with-the-zoib-package","dir":"Articles","previous_headings":"","what":"Comparison with the zoib package","title":"Zero-one-inflated beta (ZOIB) models with sdmTMB","text":"reference, can compare approach dedicated ZOIB implementation zoib package, uses Bayesian methods:","code":"library(zoib) m <- zoib(y ~ x | 1 | x | x,   data = dat,   zero.inflation = TRUE,   one.inflation = TRUE,   joint = FALSE,   n.iter = 600,   n.thin = 1,   n.burn = 100 ) # Extract parameter estimates sample1 <- m$coeff summary(sample1, quantiles = 0.5)  # Compare with our estimates coef(fit_proportion) coef(fit_zero) coef(fit_one) # Generate predictions pred <- pred.zoib(m, xnew = nd) nd2 <- data.frame(x = nd$x, zoib = pred$summary[, \"mean\"])  # Compare predictions ggplot(dat, aes(x, y)) +   geom_point(alpha = 0.3) +   geom_line(aes(x, est), data = nd, colour = \"red\", linewidth = 1) +   geom_line(aes(x, zoib), data = nd2, colour = \"blue\", linewidth = 1, linetype = 2) +   labs(     x = \"Predictor\", y = \"Response (proportion)\",     title = \"Comparison: sdmTMB (red) vs zoib package (blue)\"   )"},{"path":"https://sdmTMB.github.io/sdmTMB/articles/zoib.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Zero-one-inflated beta (ZOIB) models with sdmTMB","text":"sdmTMB currently built-ZOIB family, three-model approach provides flexibility : Include different predictors component Add spatial/spatiotemporal random fields component Use different spatial structures across components Leverage sdmTMB’s modeling features piece main limitation built-function calculate derived quantities like population indices integrated uncertainty across three model components. However, simulation approach shown can extended calculate derived quantities interest.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sean C. Anderson. Author, maintainer. Eric J. Ward. Author. Philina . English. Author. Lewis . K. Barnett. Author. James T. Thorson. Author, copyright holder.            VAST author Joe Watson. Contributor.           Censored Poisson Julia Indivero. Contributor.            Vignette writing Jillian C. Dunic. Contributor. Joseph Barss. Contributor. Cole C. Monnahan. Contributor, copyright holder.            VAST contributor Mollie Brooks. Contributor, copyright holder.            glmmTMB author Ben Bolker. Contributor, copyright holder.            glmmTMB author Kasper Kristensen. Contributor, copyright holder.           TMB/glmmTMB author Martin Maechler. Contributor, copyright holder.            glmmTMB author Arni Magnusson. Contributor, copyright holder.            glmmTMB author Hans J. Skaug. Contributor, copyright holder.           glmmTMB author, SPDE barrier Anders Nielsen. Contributor, copyright holder.            glmmTMB author Casper Berg. Contributor, copyright holder.            glmmTMB author Koen van Bentham. Contributor, copyright holder.           glmmTMB author Olav Nikolai Breivik. Contributor, copyright holder.           SPDE barrier Simon Wood. Contributor, copyright holder.           mgcv: smoother prediction Paul-Christian Bürkner. Contributor, copyright holder.           brms: smoother matrix parsing Majesty King Right Canada, represented Minister Department Fisheries Oceans. Copyright holder.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Anderson SC, Ward EJ, English PA, Barnett LAK, Thorson JT (2024). “sdmTMB: R package fast, flexible, user-friendly generalized linear mixed effects models spatial spatiotemporal random fields.” bioRxiv, 2022.03.24.485545. doi:10.1101/2022.03.24.485545.","code":"@Article{,   title = {sdmTMB: an R package for fast, flexible, and user-friendly generalized linear mixed effects models with spatial and spatiotemporal random fields},   author = {Sean C. Anderson and Eric J. Ward and Philina A. English and Lewis A. K. Barnett and James T. Thorson},   year = {2024},   journal = {bioRxiv},   volume = {2022.03.24.485545},   doi = {10.1101/2022.03.24.485545}, }"},{"path":"https://sdmTMB.github.io/sdmTMB/header.html","id":null,"dir":"","previous_headings":"","what":"sdmTMB ","title":"sdmTMB ","text":"Spatial spatiotemporal GLMMs TMB  sdmTMB R package fits spatial spatiotemporal GLMMs (Generalized Linear Mixed Effects Models) using Template Model Builder (TMB), fmesher, Gaussian Markov random fields. One common application species distribution models (SDMs). See documentation site preprint: Anderson, S.C., E.J. Ward, P.. English, L..K. Barnett, J.T. Thorson. 2024. sdmTMB: R package fast, flexible, user-friendly generalized linear mixed effects models spatial spatiotemporal random fields. bioRxiv 2022.03.24.485545; doi: https://doi.org/10.1101/2022.03.24.485545","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"sdmtmb-","dir":"","previous_headings":"","what":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Spatial spatiotemporal GLMMs TMB sdmTMB R package fits spatial spatiotemporal GLMMs (Generalized Linear Mixed Effects Models) using Template Model Builder (TMB), fmesher, Gaussian Markov random fields. One common application species distribution models (SDMs). See documentation site preprint: Anderson, S.C., E.J. Ward, P.. English, L..K. Barnett, J.T. Thorson. 2024. sdmTMB: R package fast, flexible, user-friendly generalized linear mixed effects models spatial spatiotemporal random fields. bioRxiv 2022.03.24.485545; doi: https://doi.org/10.1101/2022.03.24.485545","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table of contents","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Installation Overview Getting help Citation Basic use Time-varying coefficients Spatially varying coefficients (SVC) Random intercepts Breakpoint threshold effects Simulating data Sampling joint precision matrix Calculating uncertainty spatial predictions Cross validation Priors Bayesian MCMC sampling Stan Turning random fields Using custom fmesher mesh Barrier meshes Related software","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"sdmTMB can installed CRAN: Assuming C++ compiler installed, development version recommended can installed: extra utilities sdmTMBextra package. large models, recommended use optimized BLAS library, result major speed improvements TMB () models R (e.g., often 8-fold speed increases sdmTMB models). Suggested installation instructions Mac users (R 4.5.0) OpenBLAS Mac, Linux users, Windows users, Windows users without admin privileges. check ’ve successfully linked optimized BLAS, start new session run: result (‘elapsed’) take fraction second (e.g., 0.03 s), > 1 second.","code":"install.packages(\"sdmTMB\", dependencies = TRUE) # install.packages(\"pak\") pak::pak(\"sdmTMB/sdmTMB\", dependencies = TRUE) m <- 1e4; n <- 1e3; k <- 3e2 X <- matrix(rnorm(m*k), nrow=m); Y <- matrix(rnorm(n*k), ncol=n) system.time(X %*% Y)"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Analyzing geostatistical data (coordinate-referenced observations underlying spatial process) becoming increasingly common many fields. sdmTMB implements geostatistical spatial spatiotemporal GLMMs using TMB model fitting fmesher set SPDE matrices (stochastic partial differential equation approach; computationally efficient method modeling spatial correlation). One common application species distribution models (SDMs), hence package name. goal sdmTMB provide fast, flexible, user-friendly interface—similar popular R package glmmTMB—focus spatial spatiotemporal models SPDE approach. extend common generalized linear mixed models (GLMMs) include following optional features: spatial random fields spatiotemporal random fields may independent year modelled random walks autoregressive processes smooth terms covariates, using familiar s() notation mgcv breakpoint (hockey-stick) logistic covariates time-varying covariates (coefficients modelled random walks) spatially varying coefficient models (SVCs) interpolation forecasting missing future time slices wide range families: standard R families plus tweedie(), nbinom1(), nbinom2(), lognormal(), student(), gengamma(), plus truncated censored families delta/hurdle models including delta_gamma(), delta_lognormal(), delta_truncated_nbinom2() Estimation via maximum marginal likelihood (random effects integrated ) objective function calculated TMB minimized R via stats::nlminb() random effects integrated via Laplace approximation. sdmTMB package also allows models passed Stan via tmbstan, allowing Bayesian model estimation. See ?sdmTMB ?predict.sdmTMB complete examples. Also see vignettes (‘Articles’) documentation site preprint listed .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"questions use sdmTMB interpret models, please post discussion board. email question, likely respond discussion board anonymized version question (without data) think helpful others. Please let us know don’t want us . bugs feature requests, please post issue tracker. several past sdmTMB workshops. Slides exercises latest workshop available . Recordings older workshop also available.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"cite sdmTMB publications, please use: Anderson, S.C., E.J. Ward, P.. English, L..K. Barnett., J.T. Thorson. 2025. sdmTMB: R package fast, flexible, user-friendly generalized linear mixed effects models spatial spatiotemporal random fields. press Journal Statistical Software. bioRxiv preprint: https://doi.org/10.1101/2022.03.24.485545. list known publications use sdmTMB can found . Please use citation can track publications.","code":"citation(\"sdmTMB\")"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"basic-use","dir":"","previous_headings":"","what":"Basic use","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"sdmTMB model requires data frame contains response column, columns predictors, columns spatial coordinates. usually makes sense convert spatial coordinates equidistant projection UTMs 1 km remains distance throughout study region (unlike latitude/longitude) [e.g., using sf::st_transform()]. , illustrate spatial model fit Pacific cod (Gadus macrocephalus) trawl survey data Queen Charlotte Sound, BC, Canada. model contains main effect depth penalized smoother, spatial random field, Tweedie observation error. data frame pcod (built package) column year year survey, density density Pacific cod given survey tow, present whether density > 0, depth depth meters tow, spatial coordinates X Y, UTM coordinates kilometres. start creating mesh object contains triangular network used approximate spatial field (“finite element mesh”). , cutoff defines minimum allowed distance mesh vertices units X Y (km). Smaller values create finer meshes increase computation time. Alternatively, created mesh via fmesher INLA packages supplied make_mesh(). can inspect mesh object associated plotting method plot(mesh). Fit spatial model smoother depth: Print model fit: output shows model fit maximum marginal likelihood (ML), followed formula, mesh, data, family. main effects section includes linear component depth smoother (sdepth) standard deviation smoother weights (sds(depth)). Tweedie dispersion (phi) power parameters control distribution’s mean-variance relationship. Matérn range distance spatial correlation becomes negligible (~0.13 correlation). marginal spatial field standard deviation (sigma_O) represents unexplained spatial variation. log likelihood represents objective function value convergence. can extract parameters data frame: Run basic sanity checks model: Use ggeffects package plot smoother effect:  depth effect parametric penalized smoother, alternatively used ggeffects::ggeffect() fast marginal effect plot. Next, can predict new data. use data frame qcs_grid package, contains locations (covariates) wish predict. , newdata grid, raster, covering survey. exponentiate predictions exp() transform log-link space back density scale:  switch presence-absence model changing response column family: hurdle/delta model changing family: instead fit spatiotemporal model specifying time column spatiotemporal structure: wanted create area-weighted standardized population index (time series abundance accounting spatial variation sampling), predict grid covering entire survey (qcs_grid) grid cell area 4 km² (2 x 2 km) pass predictions get_index():  center gravity (mean location population, useful detecting distributional shifts):  basic features, see vignettes Intro modelling sdmTMB Index standardization sdmTMB.","code":"library(dplyr) library(ggplot2) library(sdmTMB) head(pcod) #> # A tibble: 3 × 6 #>    year density present depth     X     Y #>   <int>   <dbl>   <dbl> <dbl> <dbl> <dbl> #> 1  2003   113.        1   201  446. 5793. #> 2  2003    41.7       1   212  446. 5800. #> 3  2003     0         0   220  449. 5802. mesh <- make_mesh(pcod, xy_cols = c(\"X\", \"Y\"), cutoff = 10) fit <- sdmTMB(   density ~ s(depth),   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   spatial = \"on\" ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Data: pcod #> Family: tweedie(link = 'log') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)     2.37    0.21 #> sdepth          0.62    2.53 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)     13.93 #>  #> Dispersion parameter: 12.69 #> Tweedie p: 1.58 #> Matérn range: 16.39 #> Spatial SD: 1.86 #> ML criterion at convergence: 6402.136 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. tidy(fit, conf.int = TRUE) #> # A tibble: 2 × 5 #>   term        estimate std.error conf.low conf.high #>   <chr>          <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)     2.37     0.215     1.95      2.79 #> 2 sdepth          0.62     2.53     -4.34      5.58 tidy(fit, effects = \"ran_pars\", conf.int = TRUE) #> # A tibble: 5 × 5 #>   term         estimate std.error conf.low conf.high #>   <chr>           <dbl>     <dbl>    <dbl>     <dbl> #> 1 range           16.4    4.47        9.60     28.0  #> 2 phi             12.7    0.406      11.9      13.5  #> 3 sigma_O          1.86   0.218       1.48      2.34 #> 4 tweedie_p        1.58   0.00998     1.56      1.60 #> 5 sd__s(depth)    13.9   NA           7.54     25.7 sanity(fit) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameter doesn't look unreasonably large ggeffects::ggpredict(fit, \"depth [50:400, by=2]\") |> plot() p <- predict(fit, newdata = qcs_grid) head(p) #> # A tibble: 3 × 7 #>       X     Y depth   est est_non_rf est_rf omega_s #>   <dbl> <dbl> <dbl> <dbl>      <dbl>  <dbl>   <dbl> #> 1   456  5636  347. -3.06      -3.08 0.0172  0.0172 #> 2   458  5636  223.  2.03       1.99 0.0460  0.0460 #> 3   460  5636  204.  2.89       2.82 0.0747  0.0747 ggplot(p, aes(X, Y, fill = exp(est))) + geom_raster() +   scale_fill_viridis_c(trans = \"sqrt\") fit <- sdmTMB(   present ~ s(depth),   data = pcod,    mesh = mesh,   family = binomial(link = \"logit\") ) fit <- sdmTMB(   density ~ s(depth),   data = pcod,   mesh = mesh,   family = delta_gamma(link1 = \"logit\", link2 = \"log\"), ) fit_spatiotemporal <- sdmTMB(   density ~ s(depth, k = 5),    data = pcod,    mesh = mesh,   time = \"year\",   family = tweedie(link = \"log\"),    spatial = \"off\",    spatiotemporal = \"ar1\" ) grid_yrs <- replicate_df(qcs_grid, \"year\", unique(pcod$year)) p_st <- predict(fit_spatiotemporal, newdata = grid_yrs,    return_tmb_object = TRUE) index <- get_index(p_st, area = rep(4, nrow(grid_yrs))) ggplot(index, aes(year, est)) +   geom_ribbon(aes(ymin = lwr, ymax = upr), fill = \"grey90\") +   geom_line(lwd = 1, colour = \"grey30\") +   labs(x = \"Year\", y = \"Biomass (kg)\") cog <- get_cog(p_st, format = \"wide\") ggplot(cog, aes(est_x, est_y, colour = year)) +   geom_pointrange(aes(xmin = lwr_x, xmax = upr_x)) +   geom_pointrange(aes(ymin = lwr_y, ymax = upr_y)) +   scale_colour_viridis_c()"},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"time-varying-coefficients","dir":"","previous_headings":"Advanced functionality","what":"Time-varying coefficients","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Time-varying coefficients allow parameters change time random walks. useful relationships may shift gradually (e.g., due environmental change). Time-varying intercept: Time-varying (random walk) effect depth: See vignette Intro modelling sdmTMB details.","code":"fit <- sdmTMB(   density ~ 0 + s(depth, k = 5),    time_varying = ~ 1,    data = pcod, mesh = mesh,   time = \"year\",     family = tweedie(link = \"log\"),   silent = FALSE # see progress ) fit <- sdmTMB(   density ~ 1,    time_varying = ~ 0 + depth_scaled + depth_scaled2,   data = pcod, mesh = mesh,   time = \"year\",   family = tweedie(link = \"log\"),   spatial = \"off\",   spatiotemporal = \"ar1\",   silent = FALSE )"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"spatially-varying-coefficients-svc","dir":"","previous_headings":"Advanced functionality","what":"Spatially varying coefficients (SVC)","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Spatially varying coefficients allow effect predictor differ across space, revealing spatial heterogeneity relationships (e.g., trends positive areas negative others). Spatially varying effect time: See zeta_s output, represents spatial variation coefficient. Ensure SVC covariate centered (mean ≈ 0) include main formula zeta_s represents deviations average effect.  See vignette Fitting spatial trend models sdmTMB details.","code":"pcod$year_scaled <- as.numeric(scale(pcod$year)) fit <- sdmTMB(   density ~ s(depth, k = 5) + year_scaled,   spatial_varying = ~ year_scaled,    data = pcod, mesh = mesh,    time = \"year\",   family = tweedie(link = \"log\"),   spatiotemporal = \"off\" ) grid_yrs <- replicate_df(qcs_grid, \"year\", unique(pcod$year)) grid_yrs$year_scaled <- (grid_yrs$year - mean(pcod$year)) / sd(pcod$year) p <- predict(fit, newdata = grid_yrs) %>%    subset(year == 2011) # any year ggplot(p, aes(X, Y, fill = zeta_s_year_scaled)) + geom_raster() +   scale_fill_gradient2()"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"random-intercepts","dir":"","previous_headings":"Advanced functionality","what":"Random intercepts","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"can use syntax (1 | group) lme4 glmmTMB fit random intercepts:","code":"pcod$year_factor <- as.factor(pcod$year) fit <- sdmTMB(   density ~ s(depth, k = 5) + (1 | year_factor),   data = pcod, mesh = mesh,   time = \"year\",   family = tweedie(link = \"log\") )"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"breakpoint-and-threshold-effects","dir":"","previous_headings":"Advanced functionality","what":"Breakpoint and threshold effects","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"See vignette Threshold modeling sdmTMB details.","code":"fit <- sdmTMB(   present ~ 1 + breakpt(depth_scaled),    data = pcod, mesh = mesh,   family = binomial(link = \"logit\") ) fit <- sdmTMB(   present ~ 1 + logistic(depth_scaled),    data = pcod, mesh = mesh,   family = binomial(link = \"logit\") )"},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"simulating-data-from-scratch","dir":"","previous_headings":"Advanced functionality > Simulating data","what":"Simulating data from scratch","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Fit simulated data: See ?sdmTMB_simulate details.","code":"predictor_dat <- expand.grid(   X = seq(0, 1, length.out = 100), Y = seq(0, 1, length.out = 100) ) mesh <- make_mesh(predictor_dat, xy_cols = c(\"X\", \"Y\"), cutoff = 0.05) sim_dat <- sdmTMB_simulate(   formula = ~ 1,   data = predictor_dat,   mesh = mesh,   family = poisson(link = \"log\"),   range = 0.3,   sigma_O = 0.4,   seed = 1,   B = 1 # B0 = intercept ) head(sim_dat) #> # A tibble: 6 × 7 #>        X     Y omega_s    mu   eta observed `(Intercept)` #>    <dbl> <dbl>   <dbl> <dbl> <dbl>    <dbl>         <dbl> #> 1 0          0  -0.154  2.33 0.846        1             1 #> 2 0.0101     0  -0.197  2.23 0.803        0             1 #> 3 0.0202     0  -0.240  2.14 0.760        2             1 #> 4 0.0303     0  -0.282  2.05 0.718        2             1 #> 5 0.0404     0  -0.325  1.96 0.675        3             1 #> 6 0.0505     0  -0.367  1.88 0.633        2             1  # sample 200 points for fitting: set.seed(1) sim_dat_obs <- sim_dat[sample(seq_len(nrow(sim_dat)), 200), ] ggplot(sim_dat, aes(X, Y)) +   geom_raster(aes(fill = exp(eta))) + # mean without observation error   geom_point(aes(size = observed), data = sim_dat_obs, pch = 21) +   scale_fill_viridis_c() +   scale_size_area() +   coord_cartesian(expand = FALSE) mesh <- make_mesh(sim_dat_obs, xy_cols = c(\"X\", \"Y\"), cutoff = 0.05) fit <- sdmTMB(   observed ~ 1,   data = sim_dat_obs,   mesh = mesh,   family = poisson() )"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"simulating-from-an-existing-fit","dir":"","previous_headings":"Advanced functionality > Simulating data","what":"Simulating from an existing fit","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"See vignette Residual checking sdmTMB, ?simulate.sdmTMB, ?dharma_residuals details.","code":"s <- simulate(fit, nsim = 500) dim(s) #> [1] 969 500 s[1:3,1:4] #>      [,1]     [,2]     [,3]     [,4] #> [1,]    0 59.40310 83.20888  0.00000 #> [2,]    0 34.56408  0.00000 19.99839 #> [3,]    0  0.00000  0.00000  0.00000"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"sampling-from-the-joint-precision-matrix","dir":"","previous_headings":"Advanced functionality","what":"Sampling from the joint precision matrix","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"can take samples implied parameter distribution assuming MVN covariance matrix internal parameterization:  See ?gather_sims ?get_index_sims details.","code":"samps <- gather_sims(fit, nsim = 1000) ggplot(samps, aes(.value)) + geom_histogram() +   facet_wrap(~.variable, scales = \"free_x\") #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`."},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"calculating-uncertainty-on-spatial-predictions","dir":"","previous_headings":"Advanced functionality","what":"Calculating uncertainty on spatial predictions","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"fastest way get point-wise prediction uncertainty use MVN samples:","code":"p <- predict(fit, newdata = predictor_dat, nsim = 500) predictor_dat$se <- apply(p, 1, sd) ggplot(predictor_dat, aes(X, Y, fill = se)) +   geom_raster() +   scale_fill_viridis_c(option = \"A\") +   coord_cartesian(expand = FALSE)"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"cross-validation","dir":"","previous_headings":"Advanced functionality","what":"Cross validation","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"sdmTMB built-functionality cross-validation. set future::plan(), folds fit parallel: See ?sdmTMB_cv details.","code":"mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 10) ## Set parallel processing if desired: # library(future) # plan(multisession) m_cv <- sdmTMB_cv(   density ~ s(depth, k = 5),   data = pcod, mesh = mesh,   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing. # Sum of log likelihoods of left-out data: m_cv$sum_loglik #> [1] -7219.976"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"priors","dir":"","previous_headings":"Advanced functionality","what":"Priors","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Priors/penalties can placed parameters. example, place PC (penalized complexity) prior Matérn random field parameters, standard normal prior effect depth, Normal(0, 10^2) prior intercept, half-normal prior Tweedie dispersion parameter (phi): can visualize PC Matérn prior:  See ?sdmTMBpriors details.","code":"mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 10) fit <- sdmTMB(   density ~ depth_scaled,   data = pcod, mesh = mesh,   family = tweedie(),   priors = sdmTMBpriors(     matern_s = pc_matern(range_gt = 10, sigma_lt = 5),     b = normal(c(0, 0), c(1, 10)),     phi = halfnormal(0, 15)   ) ) plot_pc_matern(range_gt = 10, sigma_lt = 5)"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"bayesian-mcmc-sampling-with-stan","dir":"","previous_headings":"Advanced functionality","what":"Bayesian MCMC sampling with Stan","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"fitted model can passed tmbstan package sample posterior Stan. See Bayesian vignette.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"turning-off-random-fields","dir":"","previous_headings":"Advanced functionality","what":"Turning off random fields","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"can turn random fields model comparison:","code":"fit_sdmTMB <- sdmTMB(   present ~ poly(depth_scaled, 2),   data = pcod, mesh = mesh,   spatial = \"off\",   family = binomial() ) fit_glm <- glm(   present ~ poly(depth_scaled, 2),   data = pcod,   family = binomial() )  tidy(fit_sdmTMB) #> # A tibble: 3 × 5 #>   term                   estimate std.error conf.low conf.high #>   <chr>                     <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)              -0.426    0.0573   -0.538    -0.314 #> 2 poly(depth_scaled, 2)1  -31.7      3.03    -37.6     -25.8   #> 3 poly(depth_scaled, 2)2  -66.9      4.09    -74.9     -58.9 broom::tidy(fit_glm) #> # A tibble: 3 × 5 #>   term                   estimate std.error statistic  p.value #>   <chr>                     <dbl>     <dbl>     <dbl>    <dbl> #> 1 (Intercept)              -0.426    0.0573     -7.44 1.03e-13 #> 2 poly(depth_scaled, 2)1  -31.7      3.03      -10.5  1.20e-25 #> 3 poly(depth_scaled, 2)2  -66.9      4.09      -16.4  3.50e-60"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"using-a-custom-fmesher-mesh","dir":"","previous_headings":"Advanced functionality","what":"Using a custom fmesher mesh","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Defining mesh directly INLA:","code":"bnd <- INLA::inla.nonconvex.hull(cbind(pcod$X, pcod$Y), convex = -0.1) mesh_inla <- INLA::inla.mesh.2d(   boundary = bnd,   max.edge = c(25, 50) ) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), mesh = mesh_inla) plot(mesh) fit <- sdmTMB(   density ~ s(depth, k = 5),   data = pcod, mesh = mesh,   family = tweedie(link = \"log\") )"},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"barrier-meshes","dir":"","previous_headings":"Advanced functionality","what":"Barrier meshes","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"barrier mesh limits correlation across barriers (e.g., land water). See add_barrier_mesh() sdmTMBextra.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/index.html","id":"related-software","dir":"","previous_headings":"","what":"Related software","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"sdmTMB heavily inspired VAST glmmTMB R packages. newer tinyVAST R package can fit many models VAST sdmTMB can interface similar sdmTMB. Generally, recommend tinyVAST multivariate applications (dynamic) structural equation modelling optional spatial /spatiotemporal components. INLA inlabru can fit many models sdmTMB () approximate Bayesian inference framework. mgcv can fit similar SPDE-based Gaussian Markov random field models code included Miller et al. (2019), slower large spatial datasets. table sdmTMB preprint describes functionality timing comparisons sdmTMB, VAST, INLA/inlabru, mgcv discussion makes suggestions might choose one package another.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/Effect.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate effects — Effect.sdmTMB","title":"Calculate effects — Effect.sdmTMB","text":"Used effects package","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/Effect.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate effects — Effect.sdmTMB","text":"","code":"Effect.sdmTMB(focal.predictors, mod, ...)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/Effect.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate effects — Effect.sdmTMB","text":"focal.predictors character vector one predictors model order. mod regression model object.  specific method exists class mod, Effect.default called. ... arguments passed .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/Effect.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate effects — Effect.sdmTMB","text":"Output effects::effect(). Can plotted associated plot() method.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/Effect.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate effects — Effect.sdmTMB","text":"","code":"fit <- sdmTMB(present ~ depth_scaled, data = pcod_2011, family = binomial(),   spatial = \"off\") effects::effect(\"depth_scaled\", fit) #>  #>  depth_scaled effect #> depth_scaled #>        -3        -2      -0.1         1         3  #> 0.7511661 0.6634557 0.4673280 0.3544365 0.1897228  plot(effects::effect(\"depth_scaled\", fit))"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_barrier_mesh.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"Moved sdmTMBextra package. Make sure load sdmTMBextra sdmTMB.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_barrier_mesh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"","code":"add_barrier_mesh(   spde_obj = deprecated(),   barrier_sf = deprecated(),   range_fraction = 0.2,   proj_scaling = 1,   plot = FALSE )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_barrier_mesh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"spde_obj Output make_mesh(). barrier_sf sf object polygons defining barriers. example, coastline dataset ocean data. Note object must projection data used generate x y columns spde_obj. range_fraction fraction spatial range barrier triangles . proj_scaling spde_obj created scaling coordinates projection (e.g., dividing UTMs 1000 spatial range reasonable scale) x y values spde_obj multiplied scaling factor applying projection barrier_sf. plot Logical.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_barrier_mesh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"Deprecated. See sdmTMBextra package.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_barrier_mesh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"","code":"if (FALSE) { # \\dontrun{ add_barrier_mesh() } # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_utm_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Add UTM coordinates to a data frame — add_utm_columns","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"Add UTM (Universal Transverse Mercator) coordinates data frame. useful since geostatistical modeling generally performed equal-distance projection. can separately sf::st_as_sf(), sf::st_transform(), sf::st_coordinates() functions sf package.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_utm_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"","code":"add_utm_columns(   dat,   ll_names = c(\"longitude\", \"latitude\"),   ll_crs = 4326,   utm_names = c(\"X\", \"Y\"),   utm_crs = get_crs(dat, ll_names),   units = c(\"km\", \"m\") )  get_crs(dat, ll_names = c(\"longitude\", \"latitude\"))"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_utm_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"dat Data frame contains longitude latitude columns. ll_names Longitude latitude column names. Note order. ll_crs Input CRS value ll_names. utm_names Output column names UTM columns. utm_crs Output CRS value UTM zone; tries detect get_crs() can specified manually. units UTM units.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_utm_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"copy input data frame new columns UTM coordinates.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_utm_columns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"Note longitudes west prime meridian encoded running -180 0 degrees. may wish work km's rather standard UTM meters range parameter estimate small, can cause computational issues. depends scale data.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/add_utm_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"","code":"d <- data.frame(lat = c(52.1, 53.4), lon = c(-130.0, -131.4)) get_crs(d, c(\"lon\", \"lat\")) #> Detected UTM zone 9N; CRS = 32609. #> Visit https://epsg.io/32609 to verify. #> [1] 32609 add_utm_columns(d, c(\"lon\", \"lat\")) #> Detected UTM zone 9N; CRS = 32609. #> Visit https://epsg.io/32609 to verify. #>    lat    lon        X        Y #> 1 52.1 -130.0 431.5034 5772.632 #> 2 53.4 -131.4 340.4411 5919.452"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cAIC.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate conditional AIC — cAIC","title":"Calculate conditional AIC — cAIC","text":"Calculates conditional Akaike Information criterion (cAIC).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cAIC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate conditional AIC — cAIC","text":"","code":"cAIC(object, what = c(\"cAIC\", \"EDF\"), ...)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cAIC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate conditional AIC — cAIC","text":"object Output sdmTMB(). Whether return cAIC effective degrees freedom (EDF) group random effects. ... arguments specific methods. used.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cAIC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate conditional AIC — cAIC","text":"Either cAIC effective degrees freedom (EDF) group random effects depending argument .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cAIC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate conditional AIC — cAIC","text":"cAIC designed optimize expected --sample predictive performance new data share random effects -sample (fitted) data, e.g., spatial interpolation.  sense, fast approximation optimizing model structure based k-fold cross-validation. contrast, AIC() calculates marginal Akaike Information Criterion, designed optimize expected predictive performance new data new random effects, e.g., extrapolation, inference generative parameters. cAIC also calculates effective degrees freedom (EDF) byproduct. number fixed effects equivalent impact model flexibility given random effect. cAIC EDF calculated using Eq. 6 Zheng, Cadigan, Thorson (2024). models include profiled fixed effects, profiles turned .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cAIC.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate conditional AIC — cAIC","text":"Deriving general approximation cAIC used : Zheng, N., Cadigan, N., & Thorson, J. T. (2024). note numerical evaluation conditional Akaike information nonlinear mixed-effects models (arXiv:2411.14185). arXiv. doi:10.48550/arXiv.2411.14185 utility EDF diagnose hierarchical model behaviour: Thorson, J. T. (2024). Measuring complexity hierarchical models using effective degrees freedom. Ecology, 105(7), e4327 doi:10.1002/ecy.4327","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cAIC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate conditional AIC — cAIC","text":"","code":"mesh <- make_mesh(dogfish, c(\"X\", \"Y\"), cutoff = 15) fit <- sdmTMB(catch_weight ~ s(log(depth)),   time_varying = ~1,   time_varying_type = \"ar1\",   time = \"year\",   spatiotemporal = \"off\",   mesh = mesh,   family = tweedie(),   data = dogfish,   offset = log(dogfish$area_swept) ) #> Detected irregular time spacing with an AR(1) or random walk process. #> Consider filling in the missing time slices with `extra_time`. #> `extra_time = c(2005, 2007, 2009, 2011, 2013, 2015, 2017, 2019, 2020)` cAIC(fit) #> [1] 12071.43 cAIC(fit, what = \"EDF\") #> __s(log(depth))          b_rw_t         omega_s  #>        6.613376        9.043457       38.730229  AIC(fit) #> [1] 12192.96"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/coef.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Get fixed-effect coefficients — coef.sdmTMB","title":"Get fixed-effect coefficients — coef.sdmTMB","text":"Get fixed-effect coefficients","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/coef.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get fixed-effect coefficients — coef.sdmTMB","text":"","code":"# S3 method for class 'sdmTMB' coef(object, complete = FALSE, model = 1, ...)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/coef.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get fixed-effect coefficients — coef.sdmTMB","text":"object fitted sdmTMB model object complete Currently ignored model Linear predictor delta models. Defaults first linear predictor. ... Currently ignored","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cv_to_waywiser.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert sdmTMB_cv() objects to sf format for spatial assessment with waywiser — cv_to_waywiser","title":"Convert sdmTMB_cv() objects to sf format for spatial assessment with waywiser — cv_to_waywiser","text":"Converts cross-validation results sf::sf() object use spatial model assessment tools waywiser package. enables multi-scale spatial assessment model predictions.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cv_to_waywiser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert sdmTMB_cv() objects to sf format for spatial assessment with waywiser — cv_to_waywiser","text":"","code":"cv_to_waywiser(   object,   ll_names = c(\"longitude\", \"latitude\"),   ll_crs = 4326,   utm_crs = get_crs(object$data, ll_names) )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cv_to_waywiser.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert sdmTMB_cv() objects to sf format for spatial assessment with waywiser — cv_to_waywiser","text":"object object class sdmTMB_cv sdmTMB_cv(). ll_names Column names longitude latitude original data. Note order: longitude first, latitude. ll_crs coordinate reference system (CRS) ll_names columns. Defaults 4326 (WGS84 lon/lat). utm_crs projected coordinate reference system (CRS) output sf object. default (feeling lucky!) automatically detected using get_crs() based ll_names. Can manually specified EPSG code (e.g., 32609) format accepted sf::st_crs().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cv_to_waywiser.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert sdmTMB_cv() objects to sf format for spatial assessment with waywiser — cv_to_waywiser","text":"sf::sf() object POINT geometry containing: truth observed response values estimate cross-validated predictions geometry Spatial point locations","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cv_to_waywiser.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert sdmTMB_cv() objects to sf format for spatial assessment with waywiser — cv_to_waywiser","text":"function particularly useful assessing spatial models multiple scales using waywiser package. converting sf format, can use functions like waywiser::ww_multi_scale() evaluate model performance changes predictions aggregated different spatial scales. delta/hurdle models, combined predictions returned (e.g., product encounter probability positive catch rate).","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/reference/cv_to_waywiser.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert sdmTMB_cv() objects to sf format for spatial assessment with waywiser — cv_to_waywiser","text":"","code":"mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), cutoff = 12)  # Run cross-validation set.seed(123) m_cv <- sdmTMB_cv(   density ~ depth_scaled,   data = pcod_2011,   mesh = mesh,   family = tweedie(),   k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  # Convert with default auto-detected CRS based on lon/lat columns: cv_sf <- cv_to_waywiser(m_cv, ll_names = c(\"lon\", \"lat\")) #> Detected UTM zone 9N; CRS = 32609. #> Visit https://epsg.io/32609 to verify.  # Or manually specify the desired UTM CRS: cv_sf <- cv_to_waywiser(m_cv, ll_names = c(\"lon\", \"lat\"), utm_crs = 32609)  # Use with waywiser for multi-scale assessment waywiser::ww_multi_scale(   cv_sf,   truth,    # column name (unquoted)   estimate, # column name (unquoted)   n = list(c(5, 5), c(2, 2)) # 5x5 and 2x2 grid blocks ) #> # A tibble: 4 × 6 #>   .metric .estimator .estimate .grid_args       .grid         .notes           #>   <chr>   <chr>          <dbl> <list>           <list>        <list>           #> 1 rmse    standard       10.8  <tibble [1 × 1]> <sf [25 × 5]> <tibble [0 × 2]> #> 2 mae     standard        7.87 <tibble [1 × 1]> <sf [25 × 5]> <tibble [0 × 2]> #> 3 rmse    standard        5.70 <tibble [1 × 1]> <sf [4 × 5]>  <tibble [0 × 2]> #> 4 mae     standard        4.93 <tibble [1 × 1]> <sf [4 × 5]>  <tibble [0 × 2]>"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/dharma_residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"DHARMa residuals — dharma_residuals","title":"DHARMa residuals — dharma_residuals","text":"Plot (possibly return) DHARMa residuals. wrapper function around DHARMa::createDHARMa() facilitate use sdmTMB() models. Note: recommended set type = \"mle-mvn\" simulate.sdmTMB() resulting residuals expected distribution. default.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/dharma_residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DHARMa residuals — dharma_residuals","text":"","code":"dharma_residuals(   simulated_response,   object,   plot = TRUE,   return_DHARMa = FALSE,   test_uniformity = FALSE,   test_outliers = FALSE,   test_dispersion = FALSE,   ... )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/dharma_residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DHARMa residuals — dharma_residuals","text":"simulated_response Output simulate.sdmTMB(). recommended set type = \"mle-mvn\" call simulate.sdmTMB() residuals expected distribution. object Output sdmTMB(). plot Logical. Calls DHARMa::plotQQunif(). return_DHARMa Logical. Return object DHARMa::createDHARMa()? test_uniformity Passed testUniformity DHARMa::plotQQunif(). test_outliers Passed testOutliers DHARMa::plotQQunif(). test_dispersion Passed testDispersion DHARMa::plotQQunif(). ... arguments pass DHARMa::createDHARMa().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/dharma_residuals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DHARMa residuals — dharma_residuals","text":"data frame observed expected values invisibly returned can assign output object plot residuals . See examples. return_DHARMa = TRUE, object DHARMa::createDHARMa() returned subsequent DHARMa functions can applied.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/dharma_residuals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DHARMa residuals — dharma_residuals","text":"See residuals vignette. Advantages residuals ones residuals.sdmTMB() method (1) work delta/hurdle models combined predictions, just two parts separately, (2) work families, just families worked analytical quantile function, (3) can used various diagnostic tools plots DHARMa package. Disadvantages (1) slower calculate since one must first simulate model, (2) stability distribution residuals depends sufficient number simulation draws, (3) uniformly distributed residuals put less emphasis tails visually normally distributed residuals (may may desired). Note DHARMa returns residuals uniform(0, 1) data consistent model whereas randomized quantile residuals residuals.sdmTMB() expected normal(0, 1).","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/reference/dharma_residuals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DHARMa residuals — dharma_residuals","text":"","code":"# Try Tweedie family: fit <- sdmTMB(density ~ as.factor(year) + s(depth, k = 3),   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie(link = \"log\"), spatial = \"on\")  # The `simulated_response` argument is first so the output from # simulate() can be piped to `dharma_residuals()`.  # We will work with 100 simulations for fast examples, but you'll # likely want to work with more than this (enough that the results # are stable from run to run).  # not great: set.seed(123) simulate(fit, nsim = 100, type = \"mle-mvn\") |>   dharma_residuals(fit)   # \\donttest{ # delta-lognormal looks better: set.seed(123) fit_dl <- update(fit, family = delta_lognormal()) simulate(fit_dl, nsim = 100, type = \"mle-mvn\") |>   dharma_residuals(fit)   # or skip the pipe: set.seed(123) s <- simulate(fit_dl, nsim = 100, type = \"mle-mvn\") # and manually plot it: r <- dharma_residuals(s, fit_dl, plot = FALSE) head(r) #>       observed    expected #> 1 0.0002512885 0.001030928 #> 2 0.0003998549 0.002061856 #> 3 0.0017916820 0.003092784 #> 4 0.0030243763 0.004123711 #> 5 0.0032777465 0.005154639 #> 6 0.0060709249 0.006185567 plot(r$expected, r$observed) abline(0, 1)   # return the DHARMa object and work with the DHARMa methods ret <- simulate(fit_dl, nsim = 100, type = \"mle-mvn\") |>   dharma_residuals(fit, return_DHARMa = TRUE) plot(ret)  # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/emmeans.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimated marginal means with the emmeans package with sdmTMB — emmeans.sdmTMB","title":"Estimated marginal means with the emmeans package with sdmTMB — emmeans.sdmTMB","text":"Methods using emmeans package sdmTMB. emmeans package computes estimated marginal means fixed effects. delta/hurdle models, can specify component analyze using model argument: model = 1 binomial component (encounter probability) model = 2 positive component (e.g., gamma delta_gamma()). default, model = 1.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/emmeans.sdmTMB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimated marginal means with the emmeans package with sdmTMB — emmeans.sdmTMB","text":"https://aosmith.rbind.io/2019/03/25/getting-started--emmeans/","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/emmeans.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimated marginal means with the emmeans package with sdmTMB — emmeans.sdmTMB","text":"","code":"mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), cutoff = 20) fit <- sdmTMB(   present ~ as.factor(year),   data = pcod_2011, mesh = mesh,   family = binomial() ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: present ~ as.factor(year) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: binomial(link = 'logit') #>   #> Conditional model: #>                     coef.est coef.se #> (Intercept)            -0.61    0.55 #> as.factor(year)2013     0.99    0.22 #> as.factor(year)2015     0.75    0.22 #> as.factor(year)2017     0.01    0.22 #>  #> Matérn range: 48.45 #> Spatial SD: 1.84 #> ML criterion at convergence: 564.495 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. emmeans::emmeans(fit, ~ year) #>  year emmean    SE  df lower.CL upper.CL #>  2011 -0.606 0.551 963   -1.688    0.475 #>  2013  0.384 0.550 963   -0.695    1.463 #>  2015  0.143 0.551 963   -0.937    1.224 #>  2017 -0.594 0.551 963   -1.674    0.487 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  emmeans::emmeans(fit, pairwise ~ year) #> $emmeans #>  year emmean    SE  df lower.CL upper.CL #>  2011 -0.606 0.551 963   -1.688    0.475 #>  2013  0.384 0.550 963   -0.695    1.463 #>  2015  0.143 0.551 963   -0.937    1.224 #>  2017 -0.594 0.551 963   -1.674    0.487 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast            estimate    SE  df t.ratio p.value #>  year2011 - year2013  -0.9901 0.222 963  -4.467  0.0001 #>  year2011 - year2015  -0.7496 0.220 963  -3.404  0.0039 #>  year2011 - year2017  -0.0127 0.221 963  -0.057  0.9999 #>  year2013 - year2015   0.2405 0.217 963   1.110  0.6837 #>  year2013 - year2017   0.9774 0.223 963   4.390  0.0001 #>  year2015 - year2017   0.7369 0.222 963   3.320  0.0052 #>  #> Results are given on the log odds ratio (not the response) scale.  #> P value adjustment: tukey method for comparing a family of 4 estimates  #>  emmeans::emmeans(fit, pairwise ~ year, type = \"response\") #> $emmeans #>  year  prob    SE  df lower.CL upper.CL #>  2011 0.353 0.126 963    0.156    0.617 #>  2013 0.595 0.133 963    0.333    0.812 #>  2015 0.536 0.137 963    0.281    0.773 #>  2017 0.356 0.126 963    0.158    0.619 #>  #> Confidence level used: 0.95  #> Intervals are back-transformed from the logit scale  #>  #> $contrasts #>  contrast            odds.ratio     SE  df null t.ratio p.value #>  year2011 / year2013      0.372 0.0823 963    1  -4.467  0.0001 #>  year2011 / year2015      0.473 0.1040 963    1  -3.404  0.0039 #>  year2011 / year2017      0.987 0.2180 963    1  -0.057  0.9999 #>  year2013 / year2015      1.272 0.2760 963    1   1.110  0.6837 #>  year2013 / year2017      2.658 0.5920 963    1   4.390  0.0001 #>  year2015 / year2017      2.089 0.4640 963    1   3.320  0.0052 #>  #> P value adjustment: tukey method for comparing a family of 4 estimates  #> Tests are performed on the log odds ratio scale  #>  emmeans::emmeans(fit, pairwise ~ year, adjust = \"none\") #> $emmeans #>  year emmean    SE  df lower.CL upper.CL #>  2011 -0.606 0.551 963   -1.688    0.475 #>  2013  0.384 0.550 963   -0.695    1.463 #>  2015  0.143 0.551 963   -0.937    1.224 #>  2017 -0.594 0.551 963   -1.674    0.487 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast            estimate    SE  df t.ratio p.value #>  year2011 - year2013  -0.9901 0.222 963  -4.467  <.0001 #>  year2011 - year2015  -0.7496 0.220 963  -3.404  0.0007 #>  year2011 - year2017  -0.0127 0.221 963  -0.057  0.9543 #>  year2013 - year2015   0.2405 0.217 963   1.110  0.2675 #>  year2013 - year2017   0.9774 0.223 963   4.390  <.0001 #>  year2015 - year2017   0.7369 0.222 963   3.320  0.0009 #>  #> Results are given on the log odds ratio (not the response) scale.  #>   e <- emmeans::emmeans(fit, ~ year) plot(e)   e <- emmeans::emmeans(fit, pairwise ~ year) confint(e) #> $emmeans #>  year emmean    SE  df lower.CL upper.CL #>  2011 -0.606 0.551 963   -1.688    0.475 #>  2013  0.384 0.550 963   -0.695    1.463 #>  2015  0.143 0.551 963   -0.937    1.224 #>  2017 -0.594 0.551 963   -1.674    0.487 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast            estimate    SE  df lower.CL upper.CL #>  year2011 - year2013  -0.9901 0.222 963   -1.560   -0.420 #>  year2011 - year2015  -0.7496 0.220 963   -1.316   -0.183 #>  year2011 - year2017  -0.0127 0.221 963   -0.581    0.556 #>  year2013 - year2015   0.2405 0.217 963   -0.317    0.798 #>  year2013 - year2017   0.9774 0.223 963    0.404    1.550 #>  year2015 - year2017   0.7369 0.222 963    0.166    1.308 #>  #> Results are given on the log odds ratio (not the response) scale.  #> Confidence level used: 0.95  #> Conf-level adjustment: tukey method for comparing a family of 4 estimates  #>  summary(e, infer = TRUE) #> $emmeans #>  year emmean    SE  df lower.CL upper.CL t.ratio p.value #>  2011 -0.606 0.551 963   -1.688    0.475  -1.100  0.2715 #>  2013  0.384 0.550 963   -0.695    1.463   0.698  0.4854 #>  2015  0.143 0.551 963   -0.937    1.224   0.260  0.7948 #>  2017 -0.594 0.551 963   -1.674    0.487  -1.078  0.2812 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast            estimate    SE  df lower.CL upper.CL t.ratio p.value #>  year2011 - year2013  -0.9901 0.222 963   -1.560   -0.420  -4.467  0.0001 #>  year2011 - year2015  -0.7496 0.220 963   -1.316   -0.183  -3.404  0.0039 #>  year2011 - year2017  -0.0127 0.221 963   -0.581    0.556  -0.057  0.9999 #>  year2013 - year2015   0.2405 0.217 963   -0.317    0.798   1.110  0.6837 #>  year2013 - year2017   0.9774 0.223 963    0.404    1.550   4.390  0.0001 #>  year2015 - year2017   0.7369 0.222 963    0.166    1.308   3.320  0.0052 #>  #> Results are given on the log odds ratio (not the response) scale.  #> Confidence level used: 0.95  #> Conf-level adjustment: tukey method for comparing a family of 4 estimates  #> P value adjustment: tukey method for comparing a family of 4 estimates  #>  as.data.frame(e) #> Warning: Note: 'as.data.frame' has combined your 2 sets of results into one object, #> and this affects things like adjusted P values. Refer to the annotations. #>  year contrast                emmean        SE  df   lower.CL   upper.CL #>  2011 .                   -0.6063952 0.5511170 963 -2.1569729  0.9441824 #>  2013 .                    0.3836816 0.5497815 963 -1.1631386  1.9305018 #>  2015 .                    0.1431957 0.5505275 963 -1.4057236  1.6921150 #>  2017 .                   -0.5937169 0.5506319 963 -2.1429298  0.9554960 #>  .    year2011 - year2013 -0.9900768 0.2216228 963 -1.6136166 -0.3665369 #>  .    year2011 - year2015 -0.7495909 0.2201979 963 -1.3691217 -0.1300601 #>  .    year2011 - year2017 -0.0126783 0.2209364 963 -0.6342868  0.6089302 #>  .    year2013 - year2015  0.2404859 0.2167459 963 -0.3693327  0.8503044 #>  .    year2013 - year2017  0.9773985 0.2226493 963  0.3509706  1.6038264 #>  .    year2015 - year2017  0.7369126 0.2219749 963  0.1123823  1.3614430 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  #> Conf-level adjustment: bonferroni method for 10 estimates   # interaction of factor with continuous predictor: fit2 <- sdmTMB(   present ~ depth_scaled * as.factor(year),   data = pcod_2011, mesh = mesh,   family = binomial() ) fit2 #> Spatial model fit by ML ['sdmTMB'] #> Formula: present ~ depth_scaled * as.factor(year) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: binomial(link = 'logit') #>   #> Conditional model: #>                                  coef.est coef.se #> (Intercept)                         -0.75    0.48 #> depth_scaled                        -0.98    0.25 #> as.factor(year)2013                  1.03    0.23 #> as.factor(year)2015                  0.79    0.23 #> as.factor(year)2017                  0.01    0.23 #> depth_scaled:as.factor(year)2013    -0.16    0.26 #> depth_scaled:as.factor(year)2015     0.03    0.26 #> depth_scaled:as.factor(year)2017    -0.01    0.26 #>  #> Matérn range: 33.38 #> Spatial SD: 2.19 #> ML criterion at convergence: 546.074 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. # slopes for each level: emmeans::emtrends(fit2, ~ year, var = \"depth_scaled\") #>  year depth_scaled.trend    SE  df lower.CL upper.CL #>  2011             -0.980 0.250 959    -1.47   -0.490 #>  2013             -1.140 0.247 959    -1.63   -0.655 #>  2015             -0.950 0.238 959    -1.42   -0.483 #>  2017             -0.987 0.244 959    -1.47   -0.507 #>  #> Confidence level used: 0.95  # test difference in slopes: emmeans::emtrends(fit2, pairwise ~ year, var = \"depth_scaled\") #> $emtrends #>  year depth_scaled.trend    SE  df lower.CL upper.CL #>  2011             -0.980 0.250 959    -1.47   -0.490 #>  2013             -1.140 0.247 959    -1.63   -0.655 #>  2015             -0.950 0.238 959    -1.42   -0.483 #>  2017             -0.987 0.244 959    -1.47   -0.507 #>  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast            estimate    SE  df t.ratio p.value #>  year2011 - year2013  0.16009 0.261 959   0.613  0.9281 #>  year2011 - year2015 -0.03052 0.265 959  -0.115  0.9995 #>  year2011 - year2017  0.00651 0.261 959   0.025  1.0000 #>  year2013 - year2015 -0.19061 0.258 959  -0.738  0.8817 #>  year2013 - year2017 -0.15358 0.259 959  -0.593  0.9342 #>  year2015 - year2017  0.03703 0.263 959   0.141  0.9990 #>  #> P value adjustment: tukey method for comparing a family of 4 estimates  #>  emmeans::emmip(fit2, year ~ depth_scaled,   at = list(depth_scaled = seq(-2.5, 2.5, length.out = 50)), CIs = TRUE) #> Warning: `position_dodge()` requires non-overlapping x intervals. #> Warning: `position_dodge()` requires non-overlapping x intervals.   # delta/hurdle models: fit_delta <- sdmTMB(   density ~ as.factor(year),   data = pcod_2011, spatial = \"off\",   family = delta_gamma() ) # binomial component (encounter probability): emmeans::emmeans(fit_delta, ~ year, model = 1) #>  year  emmean    SE  df lower.CL upper.CL #>  2011 -0.4455 0.129 960  -0.6994   -0.192 #>  2013  0.2344 0.130 960  -0.0207    0.489 #>  2015  0.0841 0.130 960  -0.1706    0.339 #>  2017 -0.5108 0.133 960  -0.7725   -0.249 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  # positive component (gamma): emmeans::emmeans(fit_delta, ~ year, model = 2) #>  year emmean    SE  df lower.CL upper.CL #>  2011   4.73 0.126 960     4.48     4.97 #>  2013   4.28 0.108 960     4.06     4.49 #>  2015   4.63 0.112 960     4.41     4.85 #>  2017   4.21 0.132 960     3.95     4.47 #>  #> Results are given on the log (not the response) scale.  #> Confidence level used: 0.95"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/extract_mcmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract MCMC samples from a model fit with tmbstan. — extract_mcmc","title":"Extract MCMC samples from a model fit with tmbstan. — extract_mcmc","text":"Moved sdmTMBextra package","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/extract_mcmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract MCMC samples from a model fit with tmbstan. — extract_mcmc","text":"","code":"extract_mcmc(object = deprecated())"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/extract_mcmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract MCMC samples from a model fit with tmbstan. — extract_mcmc","text":"object Deprecated See sdmTMBextra package. Make sure load sdmTMBextra sdmTMB.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/extract_mcmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract MCMC samples from a model fit with tmbstan. — extract_mcmc","text":"Deprecated. See sdmTMBextra package.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/extract_mcmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract MCMC samples from a model fit with tmbstan. — extract_mcmc","text":"","code":"if (FALSE) { # \\dontrun{ extract_mcmc() } # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/families.html","id":null,"dir":"Reference","previous_headings":"","what":"Additional families — Families","title":"Additional families — Families","text":"Additional families compatible sdmTMB().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/families.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Additional families — Families","text":"","code":"Beta(link = \"logit\")  lognormal(link = \"log\")  gengamma(link = \"log\")  gamma_mix(link = \"log\", p_extreme = NULL)  lognormal_mix(link = \"log\", p_extreme = NULL)  nbinom2_mix(link = \"log\", p_extreme = NULL)  nbinom2(link = \"log\")  nbinom1(link = \"log\")  truncated_nbinom2(link = \"log\")  truncated_nbinom1(link = \"log\")  student(link = \"identity\", df = NULL)  tweedie(link = \"log\")  censored_poisson(link = \"log\")  delta_gamma(link1, link2 = \"log\", type = c(\"standard\", \"poisson-link\"))  delta_gamma_mix(link1 = \"logit\", link2 = \"log\", p_extreme = NULL)  delta_gengamma(link1, link2 = \"log\", type = c(\"standard\", \"poisson-link\"))  delta_lognormal(link1, link2 = \"log\", type = c(\"standard\", \"poisson-link\"))  delta_lognormal_mix(   link1,   link2 = \"log\",   type = c(\"standard\", \"poisson-link\"),   p_extreme = NULL )  delta_truncated_nbinom2(link1 = \"logit\", link2 = \"log\")  delta_truncated_nbinom1(link1 = \"logit\", link2 = \"log\")  delta_poisson_link_gamma(link1 = \"log\", link2 = \"log\")  delta_poisson_link_lognormal(link1 = \"log\", link2 = \"log\")  betabinomial(link = \"logit\")  delta_beta(link1 = \"logit\", link2 = \"logit\")"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/families.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Additional families — Families","text":"link Link. p_extreme Optional fixed probability extreme component. NULL (default), estimated. specified, must proportion 0 1. df Student-t degrees freedom parameter. Can NULL estimate (default) numeric value > 1 fix specific value. link1 Link first part delta/hurdle model. Defaults \"logit\" type = \"standard\" \"log\" type = \"poisson-link\". link2 Link second part delta/hurdle model. type Delta/hurdle family type. \"standard\" classic hurdle model. \"poisson-link\" Poisson-link delta model (Thorson 2018).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/families.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Additional families — Families","text":"list elements common standard R family objects including family, link, linkfun, linkinv. Delta/hurdle model families also elements delta (logical) type (standard vs. Poisson-link).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/families.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Additional families — Families","text":"default link1 delta models type = \"standard\" \"logit\". default link1 delta models type = \"poisson-link\" \"log\". delta_poisson_link_gamma() delta_poisson_link_lognormal() deprecated favour delta_gamma(type = \"poisson-link\") delta_lognormal(type = \"poisson-link\"). gengamma() family implemented J.T. Thorson uses Prentice (1974) parameterization lognormal occurs internal parameter gengamma_Q (reported print() summary() \"Generalized gamma Q\") approaches 0. Q matches phi distribution gamma. families ending _mix() 2-component mixtures distribution mean shared scale parameter. (Thorson et al. 2011). See model-description vignette details. parameter p_extreme = plogis(logit_p_extreme) probability extreme (larger) mean exp(log_ratio_mix) + 1 ratio larger extreme mean \"regular\" mean. can see parameters model$sd_report. parameter p_extreme can fixed priori passed proportion families. nbinom2 negative binomial parameterization NB2 variance grows quadratically mean (Hilbe 2011). nbinom1 negative binomial parameterization lets variance grow linearly mean (Hilbe 2011). student(), degrees freedom parameter estimated default (df = NULL). can fix specific value providing number > 1 (e.g., df = 3).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/families.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Additional families — Families","text":"Generalized gamma family: Prentice, R.L. 1974. log gamma model maximum likelihood estimation. Biometrika 61(3): 539–544. doi:10.1093/biomet/61.3.539 Stacy, E.W. 1962. Generalization Gamma Distribution. Annals Mathematical Statistics 33(3): 1187–1192. Institute Mathematical Statistics. Families ending _mix(): Thorson, J.T., Stewart, .J., Punt, .E. 2011. Accounting fish shoals single- multi-species survey data using mixture distribution models. Can. J. Fish. Aquat. Sci. 68(9): 1681–1693. doi:10.1139/f2011-086 . Negative binomial families: Hilbe, J. M. 2011. Negative binomial regression. Cambridge University Press. Poisson-link delta families: Thorson, J.T. 2018. Three problems conventional delta-model biomass sampling data, computationally efficient alternative. Canadian Journal Fisheries Aquatic Sciences, 75(9), 1369-1382. doi:10.1139/cjfas-2017-0266","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/families.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Additional families — Families","text":"","code":"Beta(link = \"logit\") #>  #> Family: Beta  #> Link function: logit  #>  lognormal(link = \"log\") #>  #> Family: lognormal  #> Link function: log  #>  gengamma(link = \"log\") #>  #> Family: gengamma  #> Link function: log  #>  gamma_mix(link = \"log\") #>  #> Family: gamma_mix  #> Link function: log  #>  lognormal_mix(link = \"log\") #>  #> Family: lognormal_mix  #> Link function: log  #>  nbinom2_mix(link = \"log\") #>  #> Family: nbinom2_mix  #> Link function: log  #>  nbinom2(link = \"log\") #>  #> Family: nbinom2  #> Link function: log  #>  nbinom1(link = \"log\") #>  #> Family: nbinom1  #> Link function: log  #>  truncated_nbinom2(link = \"log\") #>  #> Family: truncated_nbinom2  #> Link function: log  #>  truncated_nbinom1(link = \"log\") #>  #> Family: truncated_nbinom1  #> Link function: log  #>  student(link = \"identity\") # estimate df #> Student-t degrees of freedom parameter will be estimated. This used to be fixed #> at 3 by default. To fix it, supply a value to `df` (e.g., `df = 3`). #>  #> Family: student  #> Link function: identity  #>  student(link = \"identity\", df = 3) # fix df at 3 #> Student-t degrees of freedom parameter fixed at 3. To estimate it, set `df = #> NULL`. #>  #> Family: student  #> Link function: identity  #>  tweedie(link = \"log\") #>  #> Family: tweedie  #> Link function: log  #>  censored_poisson(link = \"log\") #>  #> Family: censored_poisson  #> Link function: log  #>  delta_gamma() #>  #> Family: binomial Gamma  #> Link function: logit log  #>  delta_gamma_mix() #>  #> Family: binomial gamma_mix  #> Link function: logit log  #>  delta_gengamma() #>  #> Family: binomial gengamma  #> Link function: logit log  #>  delta_lognormal() #>  #> Family: binomial lognormal  #> Link function: logit log  #>  delta_lognormal_mix() #>  #> Family: binomial lognormal_mix  #> Link function: logit log  #>  delta_truncated_nbinom2() #>  #> Family: binomial truncated_nbinom2  #> Link function: logit log  #>  delta_truncated_nbinom1() #>  #> Family: binomial truncated_nbinom1  #> Link function: logit log  #>  betabinomial(link = \"logit\") #>  #> Family: betabinomial  #> Link function: logit  #>  delta_beta() #>  #> Family: binomial Beta  #> Link function: logit logit  #>"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/gather_sims.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract parameter simulations from the joint precision matrix — spread_sims","title":"Extract parameter simulations from the joint precision matrix — spread_sims","text":"spread_sims() returns wide-format data frame. gather_sims() returns long-format data frame. format matches format tidybayes spread_draws() gather_draws() functions.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/gather_sims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract parameter simulations from the joint precision matrix — spread_sims","text":"","code":"spread_sims(object, nsim = 200)  gather_sims(object, nsim = 200)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/gather_sims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract parameter simulations from the joint precision matrix — spread_sims","text":"object Output sdmTMB(). nsim number simulation draws.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/gather_sims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract parameter simulations from the joint precision matrix — spread_sims","text":"data frame. gather_sims() returns long-format data frame: .iteration: sample ID .variable: parameter name .value: parameter sample value spread_sims() returns wide-format data frame: .iteration: sample ID columns parameter sample per row","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/gather_sims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract parameter simulations from the joint precision matrix — spread_sims","text":"","code":"m <- sdmTMB(density ~ depth_scaled,   data = pcod_2011, mesh = pcod_mesh_2011, family = tweedie()) head(spread_sims(m, nsim = 10)) #>   .iteration X.Intercept. depth_scaled    range      phi tweedie_p  sigma_O #> 1          1     2.191667   -0.5901819 31.85191 16.15949  1.566081 2.430088 #> 2          2     2.602605   -0.7367376 16.97427 16.47078  1.598116 3.120594 #> 3          3     2.690644   -1.0831837 42.99310 15.04725  1.607441 1.835503 #> 4          4     2.810274   -0.6135098 28.87011 15.27632  1.600637 2.412999 #> 5          5     2.943655   -0.6800500 37.60646 15.80146  1.595988 2.410816 #> 6          6     3.214597   -0.7106337 48.36184 15.35741  1.613159 1.748936 head(gather_sims(m, nsim = 10)) #>   .iteration    .variable   .value #> 1          1 X.Intercept. 3.428553 #> 2          2 X.Intercept. 2.842100 #> 3          3 X.Intercept. 2.931986 #> 4          4 X.Intercept. 2.816825 #> 5          5 X.Intercept. 2.101858 #> 6          6 X.Intercept. 2.805431 samps <- gather_sims(m, nsim = 1000)  if (require(\"ggplot2\", quietly = TRUE)) {   ggplot(samps, aes(.value)) + geom_histogram() +     facet_wrap(~.variable, scales = \"free_x\") } #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`."},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a relative biomass/abundance index, center of gravity, effective area occupied, or weighted average — get_index","title":"Extract a relative biomass/abundance index, center of gravity, effective area occupied, or weighted average — get_index","text":"Extract relative biomass/abundance index, center gravity, effective area occupied, weighted average","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a relative biomass/abundance index, center of gravity, effective area occupied, or weighted average — get_index","text":"","code":"get_index(obj, bias_correct = TRUE, level = 0.95, area = 1, silent = TRUE, ...)  get_index_split(   obj,   newdata,   bias_correct = FALSE,   nsplit = 1,   level = 0.95,   area = 1,   silent = FALSE,   predict_args = list(),   ... )  get_cog(   obj,   bias_correct = FALSE,   level = 0.95,   format = c(\"long\", \"wide\"),   area = 1,   silent = TRUE,   ... )  get_weighted_average(   obj,   vector,   bias_correct = FALSE,   level = 0.95,   area = 1,   silent = TRUE,   ... )  get_eao(obj, bias_correct = FALSE, level = 0.95, area = 1, silent = TRUE, ...)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a relative biomass/abundance index, center of gravity, effective area occupied, or weighted average — get_index","text":"obj Output predict.sdmTMB() return_tmb_object = TRUE (usual case). Alternatively, sdmTMB() called do_index = TRUE, using get_index_split(), object sdmTMB(). bias_correct bias correction implemented via TMB::sdreport()? Bias correction accounts non-linear transformation random effects calculating index. Recommended TRUE final analyses, can set FALSE faster calculation experimenting models. See Thorson Kristensen (2016) References. level confidence level. area Grid cell area area weighting index. Can : (1) numeric vector length nrow(newdata) area grid cell, (2) single numeric value apply grid cells, (3) character value giving column name newdata containing areas. silent Silent? ... Passed TMB::sdreport(). newdata New data (e.g., prediction grid year) pass predict.sdmTMB() case get_index_split(). nsplit number splits calculation . memory intensive operations (large grids /models), can helpful prediction, area integration, bias correction subsets time slices (e.g., years) instead . nsplit > 1, usually slower reduced memory use. predict_args list arguments pass predict.sdmTMB() case get_index_split(). format Long wide. vector numeric vector length prediction data, containing values averaged (e.g., depth, temperature).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a relative biomass/abundance index, center of gravity, effective area occupied, or weighted average — get_index","text":"get_index(): data frame columns time, estimate (area-weighted total abundance biomass), lower upper confidence intervals, log estimate, standard error log estimate. get_cog(): data frame columns time, estimate (center gravity: abundance-weighted mean x y coordinates), lower upper confidence intervals, standard error center gravity coordinates. get_eao(): data frame columns time, estimate (effective area occupied: area required population spread evenly arithmetic mean density), lower upper confidence intervals, log EAO, standard error log EAO estimates. get_weighted_average(): data frame columns time, estimate (weighted average provided vector, weighted predicted density), lower upper confidence intervals, standard error estimates.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract a relative biomass/abundance index, center of gravity, effective area occupied, or weighted average — get_index","text":"Geostatistical model-based indices abundance (along many newer papers): Shelton, .O., Thorson, J.T., Ward, E.J., Feist, B.E. 2014. Spatial semiparametric models improve estimates species abundance distribution. Canadian Journal Fisheries Aquatic Sciences 71(11): 1655–1666. doi:10.1139/cjfas-2013-0508 Thorson, J.T., Shelton, .O., Ward, E.J., Skaug, H.J. 2015. Geostatistical delta-generalized linear mixed models improve precision estimated abundance indices West Coast groundfishes. ICES J. Mar. Sci. 72(5): 1297–1310. doi:10.1093/icesjms/fsu243 Geostatistical model-based centre gravity: Thorson, J.T., Pinsky, M.L., Ward, E.J. 2016. Model-based inference estimating shifts species distribution, area occupied centre gravity. Methods Ecol Evol 7(8): 990–1002. doi:10.1111/2041-210X.12567 Geostatistical model-based effective area occupied: Thorson, J.T., Rindorf, ., Gao, J., Hanselman, D.H., Winker, H. 2016. Density-dependent changes effective area occupied sea-bottom-associated marine fishes. Proceedings Royal Society B: Biological Sciences 283(1840): 20161853. doi:10.1098/rspb.2016.1853 Bias correction: Thorson, J.T., Kristensen, K. 2016. Implementing generic method bias correction statistical models using random effects, spatial population dynamics examples. Fisheries Research 175: 66–74. doi:10.1016/j.fishres.2015.11.016","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a relative biomass/abundance index, center of gravity, effective area occupied, or weighted average — get_index","text":"","code":"# \\donttest{ library(ggplot2)  # use a small number of knots for this example to make it fast: mesh <- make_mesh(pcod, c(\"X\", \"Y\"), n_knots = 60)  # fit a spatiotemporal model: m <- sdmTMB(  data = pcod,  formula = density ~ 0 + as.factor(year),  time = \"year\", mesh = mesh, family = tweedie(link = \"log\") )  # prepare a prediction grid: nd <- replicate_df(qcs_grid, \"year\", unique(pcod$year))  # Note `return_tmb_object = TRUE` and the prediction grid: predictions <- predict(m, newdata = nd, return_tmb_object = TRUE)  # biomass index: ind <- get_index(predictions, bias_correct = TRUE) ind #>   year      est       lwr      upr  log_est        se se_natural  type #> 1 2003 277556.6 198537.77 388025.4 12.53378 0.1709448  213396.64 index #> 2 2004 399682.6 311373.58 513036.9 12.89843 0.1273887  328514.13 index #> 3 2005 430225.5 327502.38 565168.4 12.97206 0.1391935  349502.73 index #> 4 2007 119509.7  86514.07 165089.6 11.69115 0.1648452   92900.11 index #> 5 2009 210258.6 151807.71 291215.1 12.25609 0.1661887  161751.50 index #> 6 2011 339420.7 262199.67 439384.3 12.73500 0.1317035  276264.20 index #> 7 2013 351455.2 258755.05 477365.7 12.76984 0.1562276  276664.42 index #> 8 2015 383241.4 285819.07 513870.4 12.85642 0.1496487  306744.07 index #> 9 2017 192367.9 136764.93 270576.6 12.16716 0.1740572  148187.40 index ggplot(ind, aes(year, est)) + geom_line() +   geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) +   ylim(0, NA)   # do that in 2 chunks # only necessary for very large grids to save memory # will be slower but save memory # note the first argument is the model fit object: ind <- get_index_split(m, newdata = nd, nsplit = 2, bias_correct = TRUE) #> Calculating index in 2 chunks ■■■■■■■■■■■■■■■■                  50% | ETA:  0s #> Calculating index in 2 chunks ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■  100% | ETA:  0s  # center of gravity: cog <- get_cog(predictions, format = \"wide\") #> Bias correction is turned off. #> It is recommended to turn this on for final inference. cog #>   year    est_x    lwr_x    upr_x     se_x    est_y    lwr_y    upr_y      se_y #> 1 2003 463.5260 446.4142 480.6378 8.730670 5757.861 5739.855 5775.867  9.187109 #> 2 2004 476.7402 466.4506 487.0297 5.249871 5732.504 5720.879 5744.129  5.931164 #> 3 2005 470.6887 457.7494 483.6280 6.601796 5763.031 5750.153 5775.910  6.570990 #> 4 2007 480.8948 464.5560 497.2336 8.336280 5738.231 5716.843 5759.620 10.912733 #> 5 2009 477.2029 457.9185 496.4872 9.839144 5734.029 5713.361 5754.697 10.545101 #> 6 2011 470.5112 457.6004 483.4221 6.587284 5747.104 5733.628 5760.579  6.875389 #> 7 2013 471.9877 455.6078 488.3676 8.357252 5747.645 5728.969 5766.320  9.528488 #> 8 2015 463.0289 449.6443 476.4136 6.829028 5753.970 5736.844 5771.096  8.737855 #> 9 2017 470.5219 455.4189 485.6249 7.705734 5755.973 5739.644 5772.301  8.331045 #>   type #> 1  cog #> 2  cog #> 3  cog #> 4  cog #> 5  cog #> 6  cog #> 7  cog #> 8  cog #> 9  cog ggplot(cog, aes(est_x, est_y, colour = year)) +   geom_point() +   geom_linerange(aes(xmin = lwr_x, xmax = upr_x)) +   geom_linerange(aes(ymin = lwr_y, ymax = upr_y)) +   scale_colour_viridis_c()   # effective area occupied: eao <- get_eao(predictions) eao #>   year      est       lwr      upr  log_est        se type #> 1 2003 2408.074 1407.0230 4121.340 7.786583 0.2741638  eoa #> 2 2004 1807.151  849.4148 3844.759 7.499507 0.3851904  eoa #> 3 2005 1660.807  943.6930 2922.859 7.415059 0.2884024  eoa #> 4 2007 1854.122  793.7681 4330.947 7.525166 0.4328524  eoa #> 5 2009 3227.459 2437.0094 4274.293 8.079450 0.1433310  eoa #> 6 2011 3056.811 2192.3985 4262.042 8.025128 0.1695827  eoa #> 7 2013 2887.839 1895.2602 4400.246 7.968264 0.2148775  eoa #> 8 2015 1739.803  801.6399 3775.904 7.461527 0.3953480  eoa #> 9 2017 1975.478  703.8844 5544.253 7.588566 0.5265156  eoa ggplot(eao, aes(year, est)) + geom_line() +   geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) +   ylim(0, NA)   # weighted average (e.g., depth-weighted by biomass): wa <- get_weighted_average(predictions, vector = nd$depth) #> Bias correction is turned off. #> It is recommended to turn this on for final inference. wa #>   year      est      lwr      upr       se             type #> 1 2003 143.0966 131.6188 154.5745 5.856165 weighted_average #> 2 2004 167.9096 153.5499 182.2693 7.326531 weighted_average #> 3 2005 149.2031 139.8667 158.5395 4.763568 weighted_average #> 4 2007 130.2034 116.7758 143.6311 6.850989 weighted_average #> 5 2009 139.5020 127.7901 151.2139 5.975573 weighted_average #> 6 2011 155.3026 144.6900 165.9151 5.414662 weighted_average #> 7 2013 148.8824 137.4326 160.3322 5.841828 weighted_average #> 8 2015 150.9538 139.2211 162.6866 5.986200 weighted_average #> 9 2017 150.7800 140.0110 161.5491 5.494516 weighted_average ggplot(wa, aes(year, est)) + geom_line() +   geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4)  # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index_sims.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"Calculate population index via simulation joint precision matrix. Compared get_index(), version can faster bias correction turned get_index() approximately equivalent. experimental function. function usually works reasonably well, make guarantees. recommended use get_index() bias_correct = TRUE final inference.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index_sims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"","code":"get_index_sims(   obj,   level = 0.95,   return_sims = FALSE,   area = rep(1, nrow(obj)),   est_function = stats::median,   area_function = function(x, area) x + log(area),   agg_function = function(x) sum(exp(x)) )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index_sims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"obj predict.sdmTMB() output nsim > 0. level confidence level. return_sims Logical. Return simulation draws? default (FALSE) quantile summary simulation draws. area vector grid cell/polyon areas year-grid cell (row data) obj. Adjust cells unit area area (e.g., cells partially land/water). Note area vector added log(area) raw values obj. words, function assumes log link, typically makes sense. est_function Function summarize estimate (expected value). mean() alternative median(). area_function Function apply area weighting. Assuming log link, function(x, area) x + log(area) default makes sense. natural space, function(x, area) x * area makes sense. agg_function Function aggregate samples within time slice. Assuming log link, function(x) sum(exp(x)) default makes sense. natural space, function(x) sum(x) makes sense.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index_sims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"data frame. return_sims = FALSE: name column (e.g. year) supplied sdmTMB() time argument est: estimate lwr: lower confidence interval value upr: upper confidence interval value log_est: log estimate se: standard error log estimate return_sims = TRUE, samples index values long-format data frame: name column (e.g. year) supplied sdmTMB() time argument .value: sample value .iteration: sample number","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index_sims.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"Can also used produce index model fit tmbstan. function nothing summarize reshape matrix simulation draws data frame.","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_index_sims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"","code":"# \\donttest{ m <- sdmTMB(density ~ 0 + as.factor(year),   data = pcod_2011, mesh = pcod_mesh_2011, family = tweedie(link = \"log\"),   time = \"year\" ) qcs_grid_2011 <- replicate_df(qcs_grid, \"year\", unique(pcod_2011$year)) p <- predict(m, newdata = qcs_grid_2011, nsim = 100) x <- get_index_sims(p) #> We generally recommend using `get_index(..., bias_correct = TRUE)` #> rather than `get_index_sims()`. x_sims <- get_index_sims(p, return_sims = TRUE) #> We generally recommend using `get_index(..., bias_correct = TRUE)` #> rather than `get_index_sims()`.  if (require(\"ggplot2\", quietly = TRUE)) {   ggplot(x, aes(year, est, ymin = lwr, ymax = upr)) +     geom_line() +     geom_ribbon(alpha = 0.4)   ggplot(x_sims, aes(as.factor(year), .value)) +     geom_violin() }   # Demo custom functions if working in natural space: ind <- get_index_sims(   exp(p),   agg_function = function(x) sum(x),   area_function = function(x, area) x * area ) #> We generally recommend using `get_index(..., bias_correct = TRUE)` #> rather than `get_index_sims()`. # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_pars.html","id":null,"dir":"Reference","previous_headings":"","what":"Get TMB parameter list — get_pars","title":"Get TMB parameter list — get_pars","text":"Get TMB parameter list","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_pars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get TMB parameter list — get_pars","text":"","code":"get_pars(object)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_pars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get TMB parameter list — get_pars","text":"object Fit sdmTMB()","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_pars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get TMB parameter list — get_pars","text":"named list parameter values","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_pars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get TMB parameter list — get_pars","text":"","code":"fit <- sdmTMB(present ~ 1, data = pcod_2011, family = binomial(), spatial = \"off\") pars <- get_pars(fit) names(pars) #>  [1] \"ln_H_input\"          \"b_j\"                 \"b_j2\"                #>  [4] \"bs\"                  \"ln_tau_O\"            \"ln_tau_Z\"            #>  [7] \"ln_tau_E\"            \"ln_kappa\"            \"thetaf\"              #> [10] \"ln_student_df\"       \"gengamma_Q\"          \"logit_p_extreme\"     #> [13] \"log_ratio_mix\"       \"ln_phi\"              \"ln_tau_V\"            #> [16] \"rho_time_unscaled\"   \"ar1_phi\"             \"re_cov_pars\"         #> [19] \"re_b_pars\"           \"b_rw_t\"              \"omega_s\"             #> [22] \"zeta_s\"              \"epsilon_st\"          \"b_threshold\"         #> [25] \"b_epsilon\"           \"ln_epsilon_re_sigma\" \"epsilon_re\"          #> [28] \"b_smooth\"            \"ln_smooth_sigma\""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_range_edge.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate range edges via simulation from the joint precision matrix — get_range_edge","title":"Calculate range edges via simulation from the joint precision matrix — get_range_edge","text":"Calculate range edges density-weighted quantiles along spatial axis. Range edges calculated positions along user-supplied spatial axis (e.g., latitude, coastal distance) cumulative proportion density equals specified quantiles (e.g., 0.01 0.99 lower upper 1% range edges). Uncertainty calculated via simulation joint precision matrix.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_range_edge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate range edges via simulation from the joint precision matrix — get_range_edge","text":"","code":"get_range_edge(   obj,   axis,   quantiles = c(0.025, 0.975),   level = 0.95,   return_sims = FALSE )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_range_edge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate range edges via simulation from the joint precision matrix — get_range_edge","text":"obj predict.sdmTMB() output nsim > 0. prediction object include predictions spatial grid covers area interest. axis Numeric vector length prediction data, representing spatial axis along calculate range edges (e.g., latitude, coastal distance values). align rows prediction matrix. quantiles Numeric vector quantiles calculate. Default c(0.025, 0.975) lower upper 1% range edges. Common alternatives include c(0.01, 0.99) 1% edges c(0.05, 0.5, 0.95) include median. level confidence level uncertainty intervals. return_sims Logical. Return simulation draws? default (FALSE) returns quantile summary simulation draws.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_range_edge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate range edges via simulation from the joint precision matrix — get_range_edge","text":"data frame. return_sims = FALSE: name time column (e.g., year) supplied sdmTMB() time argument quantile: quantile value (quantiles argument) est: estimated range edge position lwr: lower confidence interval upr: upper confidence interval se: standard error return_sims = TRUE, simulation draws range edge positions long format: name time column (e.g., year) quantile: quantile value .value: simulated range edge position .iteration: simulation number","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_range_edge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate range edges via simulation from the joint precision matrix — get_range_edge","text":"function implements similar approach VAST's range edge calculations, following methods Fredston et al. (2021) similar studies. method: Orders spatial locations position along specified axis Calculates cumulative proportion total density along axis Finds positions cumulative proportion equals target quantiles Uses simulation joint precision quantify uncertainty find exact position cumulative proportion equals target quantile, function uses linear interpolation adjacent grid points. provides accurate range edge estimates selecting closest grid point, especially coarser grids extreme quantiles (e.g., 0.01, 0.99).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_range_edge.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate range edges via simulation from the joint precision matrix — get_range_edge","text":"Fredston, . L., Pinsky, M., Selden, R. L., Szuwalski, C., Thorson, J. T., Gaines, S. D., & Halpern, B. S. (2021). Range edges North American marine species tracking temperature decades. Global Change Biology, 27(13), 3145-3156. doi:10.1111/gcb.15614","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/get_range_edge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate range edges via simulation from the joint precision matrix — get_range_edge","text":"","code":"# \\donttest{ # Fit a spatiotemporal model mesh <- make_mesh(pcod, c(\"X\", \"Y\"), n_knots = 100) m <- sdmTMB(   density ~ 0 + as.factor(year),   data = pcod, mesh = mesh, family = tweedie(link = \"log\"),   time = \"year\", spatiotemporal = \"iid\", spatial = \"on\" )  # Create prediction grid nd <- replicate_df(qcs_grid, \"year\", unique(pcod$year))  # Get predictions with simulations p <- predict(m, newdata = nd, nsim = 100)  # Calculate range edges along latitude (Y coordinate) edges <- get_range_edge(p, axis = nd$Y) edges #>    year quantile      est     lwr     upr       se #> 1  2003    0.025 5640.000 5636.00 5646.00 3.053840 #> 2  2003    0.975 5834.000 5832.00 5836.00 1.249849 #> 3  2004    0.025 5640.000 5636.00 5647.05 3.092228 #> 4  2004    0.975 5832.000 5826.00 5836.00 2.714172 #> 5  2005    0.025 5644.000 5638.00 5657.05 5.723988 #> 6  2005    0.975 5834.000 5832.00 5836.00 1.462175 #> 7  2007    0.025 5640.000 5636.00 5643.05 2.045542 #> 8  2007    0.975 5834.000 5832.00 5836.00 1.328268 #> 9  2009    0.025 5638.000 5636.00 5642.00 2.058832 #> 10 2009    0.975 5832.000 5828.00 5836.00 2.378243 #> 11 2011    0.025 5640.000 5636.00 5647.05 3.151000 #> 12 2011    0.975 5832.932 5830.00 5836.00 1.603341 #> 13 2013    0.025 5640.000 5636.00 5654.00 4.218813 #> 14 2013    0.975 5834.000 5830.00 5836.00 1.575239 #> 15 2015    0.025 5640.000 5636.00 5651.05 4.092417 #> 16 2015    0.975 5832.000 5828.95 5836.00 1.873009 #> 17 2017    0.025 5641.000 5636.00 5652.10 4.652098 #> 18 2017    0.975 5834.000 5832.00 5836.00 1.311238  # Plot range edges over time if (require(\"ggplot2\", quietly = TRUE)) {   ggplot(edges, aes(year, est, colour = as.factor(quantile))) +     geom_line() +     geom_ribbon(aes(ymin = lwr, ymax = upr, fill = as.factor(quantile)),                 alpha = 0.2) +     labs(y = \"Latitude\", colour = \"Quantile\", fill = \"Quantile\") }   # Get simulation draws for further analysis edges_sims <- get_range_edge(p, axis = nd$Y, return_sims = TRUE) # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/ggplot2_installed.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if ggplot2 installed — ggplot2_installed","title":"Check if ggplot2 installed — ggplot2_installed","text":"Check ggplot2 installed","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/ggplot2_installed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if ggplot2 installed — ggplot2_installed","text":"","code":"ggplot2_installed()"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/ggplot2_installed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if ggplot2 installed — ggplot2_installed","text":"Returns TRUE FALSE.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_category_svc.html","id":null,"dir":"Reference","previous_headings":"","what":"Set up spatially varying coefficients for category composition models — make_category_svc","title":"Set up spatially varying coefficients for category composition models — make_category_svc","text":"function helps set data structure, formula, mapping needed fitting spatially varying coefficient models categories (e.g., ages, length bins, species) spatial spatiotemporal random fields. particularly useful age length composition standardization models.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_category_svc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set up spatially varying coefficients for category composition models — make_category_svc","text":"","code":"make_category_svc(   data,   category_column,   time_column,   share_spatial_sd = TRUE,   share_spatiotemporal_sd = TRUE )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_category_svc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set up spatially varying coefficients for category composition models — make_category_svc","text":"data Data frame containing composition data. category_column Character. Name category column (e.g., \"Age\", \"length_bin\", \"species\"). time_column Character. Name time column (e.g., \"Year\"). share_spatial_sd Logical. TRUE, categories share spatial SD. FALSE, category gets spatial SD. share_spatiotemporal_sd Logical. TRUE, category-time combinations share spatiotemporal SD. FALSE, gets .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_category_svc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set up spatially varying coefficients for category composition models — make_category_svc","text":"list containing: data_expanded: Data frame added model matrix columns use sdmTMB(). svc_formula: Formula spatial_varying argument sdmTMB(). svc_map: Map list map argument sdmTMBcontrol(). info: List summary information model structure.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_category_svc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set up spatially varying coefficients for category composition models — make_category_svc","text":"function creates spatially varying coefficient structures composition models setting : Spatial fields: One field per category (e.g., age-specific spatial fields) 2. Spatiotemporal fields: One field per category-time combination (e.g., age-year fields) sharing variance parameters controlled share_spatial_sd share_spatiotemporal_sd. TRUE, fields type share variance parameter, parsimonious assumes similar variance magnitudes across categories. resulting model structure allows category spatial pattern temporal variation controlling parameter sharing identifiability computational efficiency.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_category_svc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set up spatially varying coefficients for category composition models — make_category_svc","text":"","code":"set.seed(123) data <- data.frame(   age = factor(rep(1:3, each = 20)),   year = rep(2020:2022, 20),   abundance = rnorm(60),   x = runif(60), y = runif(60) )  # Set up model components setup <- make_category_svc(   data = data,   category_column = \"age\",   time_column = \"year\",   share_spatial_sd = TRUE,   share_spatiotemporal_sd = TRUE )  # Check the setup setup$info #> $n_categories #> [1] 3 #>  #> $n_times #> [1] 3 #>  #> $n_spatial_terms #> [1] 3 #>  #> $n_spatiotemporal_terms #> [1] 9 #>  #> $n_variance_parameters #> [1] 2 #>  #> $spatial_terms #> [1] \"age1\" \"age2\" \"age3\" #>  #> $spatiotemporal_terms #> [1] \"factor(year)2020:age1\" \"factor(year)2021:age1\" \"factor(year)2022:age1\" #> [4] \"factor(year)2020:age2\" \"factor(year)2021:age2\" \"factor(year)2022:age2\" #> [7] \"factor(year)2020:age3\" \"factor(year)2021:age3\" \"factor(year)2022:age3\" #>  #> $share_spatial_sd #> [1] TRUE #>  #> $share_spatiotemporal_sd #> [1] TRUE #>   # See the age composition standardization vignette for more details"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_mesh.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct an SPDE mesh for sdmTMB — make_mesh","title":"Construct an SPDE mesh for sdmTMB — make_mesh","text":"Construct SPDE mesh use sdmTMB.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_mesh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct an SPDE mesh for sdmTMB — make_mesh","text":"","code":"make_mesh(   data,   xy_cols,   type = c(\"kmeans\", \"cutoff\", \"cutoff_search\"),   cutoff,   n_knots,   seed = 42,   mesh = NULL,   fmesher_func = fmesher::fm_rcdt_2d_inla,   convex = NULL,   concave = convex,   ... )  # S3 method for class 'sdmTMBmesh' plot(x, ...)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_mesh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct an SPDE mesh for sdmTMB — make_mesh","text":"data data frame. xy_cols character vector x y column names contained data. likely equal distance projection. helper function convert UTMs, see add_utm_columns(). type Method create mesh. Also see mesh argument supply mesh. cutoff optional cutoff type \"cutoff\". minimum allowed triangle edge length. n_knots number desired knots type \"cutoff\". seed Random seed. Affects stats::kmeans() determination knot locations type = \"kmeans\". mesh optional mesh created via fmesher instead using convenience options. fmesher_func fmesher function use. Options include fmesher::fm_rcdt_2d_inla() fmesher::fm_mesh_2d_inla() along version without _inla end. convex specified, passed fmesher::fm_nonconvex_hull(). Distance extend non-convex hull data. concave specified, passed fmesher::fm_nonconvex_hull(). \"Minimum allowed reentrant curvature\". Defaults convex. ... Passed graphics::plot(). x Output make_mesh().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_mesh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct an SPDE mesh for sdmTMB — make_mesh","text":"make_mesh(): list class sdmTMBmesh. element mesh output fmesher_func (default fmesher::fm_mesh_2d_inla()). See mesh$mesh$n number vertices. plot.sdmTMBmesh(): plot mesh data points. make ggplot2 version, pass your_mesh$mesh inlabru::gg().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/make_mesh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct an SPDE mesh for sdmTMB — make_mesh","text":"","code":"# Extremely simple cutoff: mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 5, type = \"cutoff\") plot(mesh)   # Using a k-means algorithm to assign vertices: mesh <- make_mesh(pcod, c(\"X\", \"Y\"), n_knots = 50, type = \"kmeans\") plot(mesh)   # \\donttest{ # But, it's better to develop more tailored meshes:  # Pass arguments via '...' to fmesher::fm_mesh_2d_inla(): mesh <- make_mesh(   pcod, c(\"X\", \"Y\"),   fmesher_func = fmesher::fm_mesh_2d_inla,   cutoff = 8, # minimum triangle edge length   max.edge = c(20, 40), # inner and outer max triangle lengths   offset = c(5, 40) # inner and outer border widths ) plot(mesh)   # Or define a mesh directly with fmesher (formerly in INLA): inla_mesh <- fmesher::fm_mesh_2d_inla(   loc = cbind(pcod$X, pcod$Y), # coordinates   max.edge = c(25, 50), # max triangle edge length; inner and outer meshes   offset = c(5, 25),  # inner and outer border widths   cutoff = 5 # minimum triangle edge length ) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), mesh = inla_mesh) plot(mesh)  # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_anisotropy.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot anisotropy from an sdmTMB model — plot_anisotropy","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"Anisotropy spatial correlation directionally dependent. sdmTMB(), default spatial correlation isotropic, anisotropy can enabled anisotropy = TRUE. plotting functions help visualize estimated anisotropy.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_anisotropy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"","code":"plot_anisotropy(object, return_data = FALSE)  plot_anisotropy2(object, model = 1)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_anisotropy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"object object sdmTMB(). return_data Logical. Return data frame? plot_anisotropy() . model model delta model (plot_anisotropy2(); plot_anisotropy() always plots ).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_anisotropy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"plot_anisotropy(): One ellipses illustrating estimated anisotropy. ellipses centered coordinates zero space X-Y coordinates modeled. ellipses show spatial /spatiotemporal range (distance correlation effectively independent) direction zero. Uses ggplot2. anisotropy turned fitting model, NULL returned instead ggplot2 object. plot_anisotropy2(): plot eigenvectors illustrating estimated anisotropy. list plotted data invisibly returned. Uses base graphics. anisotropy turned fitting model, NULL returned instead plot object.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_anisotropy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"Code adapted VAST R package","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_anisotropy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"","code":"mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), n_knots = 80, type = \"kmeans\") fit <- sdmTMB(   data = pcod_2011,   formula = density ~ 1,   mesh = mesh,   family = tweedie(),   share_range = FALSE,   anisotropy = TRUE #< ) plot_anisotropy(fit)  plot_anisotropy2(fit)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_pc_matern.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot PC Matérn priors — plot_pc_matern","title":"Plot PC Matérn priors — plot_pc_matern","text":"Plot PC Matérn priors","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_pc_matern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot PC Matérn priors — plot_pc_matern","text":"","code":"plot_pc_matern(   range_gt,   sigma_lt,   range_prob = 0.05,   sigma_prob = 0.05,   range_lims = c(range_gt * 0.1, range_gt * 10),   sigma_lims = c(0, sigma_lt * 2),   plot = TRUE )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_pc_matern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot PC Matérn priors — plot_pc_matern","text":"range_gt value one expects spatial spatiotemporal range greater 1 - range_prob probability. sigma_lt value one expects spatial spatiotemporal marginal standard deviation (sigma_O sigma_E internally) less 1 - sigma_prob probability. range_prob Probability. See description range_gt. sigma_prob Probability. See description sigma_lt. range_lims Plot range variable limits. sigma_lims Plot sigma variable limits. plot Logical controlling whether plot drawn (defaults TRUE).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_pc_matern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot PC Matérn priors — plot_pc_matern","text":"plot image(). Invisibly returns underlying matrix data. rows sigmas. columns ranges. Column row names provided.","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_pc_matern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot PC Matérn priors — plot_pc_matern","text":"","code":"plot_pc_matern(range_gt = 5, sigma_lt = 1)  plot_pc_matern(range_gt = 5, sigma_lt = 10)  plot_pc_matern(range_gt = 5, sigma_lt = 1, sigma_prob = 0.2)  plot_pc_matern(range_gt = 5, sigma_lt = 1, range_prob = 0.2)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_smooth.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a smooth term from an sdmTMB model — plot_smooth","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"Deprecated: use visreg::visreg(). See visreg_delta() examples.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_smooth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"","code":"plot_smooth(   object,   select = 1,   n = 100,   level = 0.95,   ggplot = FALSE,   rug = TRUE,   return_data = FALSE )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_smooth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"object sdmTMB() model. select smoother term plot. n number equally spaced points evaluate smoother along. level confidence level. ggplot Logical: use ggplot2 package? rug Logical: add rug lines along lower axis? return_data Logical: return predicted data instead making plot?","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_smooth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"plot smoother term.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_smooth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"Note: numeric predictor set mean factor predictor set first-level value time element (present) set minimum value x y coordinates set mean values","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/plot_smooth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"","code":"d <- subset(pcod, year >= 2000 & density > 0)   pcod_spde <- make_mesh(d, c(\"X\", \"Y\"), cutoff = 30)   m <- sdmTMB(     data = d,     formula = log(density) ~ s(depth_scaled) + s(year, k = 5),     mesh = pcod_spde   )   plot_smooth(m) #> This function may be deprecated. #> Consider using `visreg::visreg()` or `visreg_delta()`. #> See ?visreg_delta() for examples."},{"path":"https://sdmTMB.github.io/sdmTMB/reference/predict.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict from an sdmTMB model — predict.sdmTMB","title":"Predict from an sdmTMB model — predict.sdmTMB","text":"Make predictions sdmTMB model; can predict original new data.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/predict.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict from an sdmTMB model — predict.sdmTMB","text":"","code":"# S3 method for class 'sdmTMB' predict(   object,   newdata = NULL,   type = c(\"link\", \"response\"),   se_fit = FALSE,   re_form = NULL,   re_form_iid = NULL,   nsim = 0,   sims_var = \"est\",   model = c(NA, 1, 2),   offset = NULL,   mcmc_samples = NULL,   return_tmb_object = FALSE,   return_tmb_report = FALSE,   return_tmb_data = FALSE,   ... )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/predict.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict from an sdmTMB model — predict.sdmTMB","text":"object model fitted sdmTMB(). newdata data frame make predictions . data frame predictor columns fitted data time column (spatiotemporal model) name fitted data. type est column link (default) response space? se_fit standard errors predictions calculated? Warning: can slow large datasets high-resolution projections random fields included. faster uncertainty estimation, either use re_form = NA exclude random fields use nsim argument simulate joint precision matrix. re_form NULL include spatial/spatiotemporal random fields predictions. ~0 NA population-level predictions (predictions fixed effects , marginalizing random fields). Often used se_fit = TRUE visualize marginal effects. affect get_index() calculations. re_form_iid NULL specify including random intercepts predictions. ~0 NA population-level predictions. options (e.g., random intercepts) implemented yet. affects predictions newdata. affects get_index(). nsim > 0, simulate joint precision matrix nsim draws. Returns matrix nrow(newdata) nsim column representing one draw linear predictor (link space). Simulating joint precision matrix accounts uncertainty fixed random effects. Use derive uncertainty predictions (e.g., apply(x, 1, sd)) propagate uncertainty derived quantities. fastest way characterize spatial uncertainty sdmTMB. sims_var Experimental: TMB reported variable model extracted joint precision matrix simulation draws? Defaults link-space predictions. Options include: \"omega_s\", \"zeta_s\", \"epsilon_st\", \"est_rf\" (described ). options passed verbatim. model component predict delta/hurdle models nsim > 0 mcmc_samples supplied. NA (default) returns combined prediction components; 1 returns binomial component ; 2 returns positive component . Predictions link response scale depending type. regular predictions (without simulation), components returned. See delta-model vignette. offset numeric vector optional offset values. left default NULL, offset implicitly left 0. mcmc_samples See extract_mcmc() sdmTMBextra package details Bayesian vignette. specified, predict function return matrix similar form nsim > 0 representing Bayesian posterior samples Stan model. return_tmb_object Logical. TRUE, include TMB object list format output. Necessary get_index() get_cog() functions. return_tmb_report Logical: return output TMB report? regular prediction, reported variables MLE parameter values. nsim > 0 mcmc_samples supplied, list element sample contents element output report sample. return_tmb_data Logical: return formatted data TMB? Used internally. ... implemented.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/predict.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict from an sdmTMB model — predict.sdmTMB","text":"return_tmb_object = FALSE (nsim = 0 mcmc_samples = NULL): data frame: est: Estimate link space (everything included) est_non_rf: Estimate everything except random fields (fixed effects, random intercepts, time-varying effects, etc.) est_rf: Estimate random fields combined omega_s: Spatial random field (models consistent spatial patterns) zeta_s: Spatially varying coefficient field (models effects vary across space) epsilon_st: Spatiotemporal random field (models spatial patterns vary time) return_tmb_object = TRUE (nsim = 0 mcmc_samples = NULL): list: data: data frame described report: TMB report parameter values obj: TMB object returned prediction run fit_obj: original TMB model object case, likely need data element end user. elements included functions. nsim > 0 mcmc_samples NULL: matrix: Columns represent samples Rows represent predictions one row per row newdata","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/predict.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict from an sdmTMB model — predict.sdmTMB","text":"","code":"d <- pcod_2011 mesh <- make_mesh(d, c(\"X\", \"Y\"), cutoff = 30) # a coarse mesh for example speed m <- sdmTMB(  data = d, formula = density ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,  time = \"year\", mesh = mesh, family = tweedie(link = \"log\") )  # Predictions at original data locations -------------------------------  predictions <- predict(m) head(predictions) #> # A tibble: 6 × 17 #>    year     X     Y depth density present   lat   lon depth_mean depth_sd #>   <int> <dbl> <dbl> <dbl>   <dbl>   <dbl> <dbl> <dbl>      <dbl>    <dbl> #> 1  2011  435. 5718.   241    245.       1  51.6 -130.       5.16    0.445 #> 2  2011  487. 5719.    52      0        0  51.6 -129.       5.16    0.445 #> 3  2011  490. 5717.    47      0        0  51.6 -129.       5.16    0.445 #> 4  2011  545. 5717.   157      0        0  51.6 -128.       5.16    0.445 #> 5  2011  404. 5720.   398      0        0  51.6 -130.       5.16    0.445 #> 6  2011  420. 5721.   486      0        0  51.6 -130.       5.16    0.445 #> # ℹ 7 more variables: depth_scaled <dbl>, depth_scaled2 <dbl>, est <dbl>, #> #   est_non_rf <dbl>, est_rf <dbl>, omega_s <dbl>, epsilon_st <dbl>  predictions$resids <- residuals(m) # randomized quantile residuals  library(ggplot2) ggplot(predictions, aes(X, Y, col = resids)) + scale_colour_gradient2() +   geom_point() + facet_wrap(~year)  hist(predictions$resids)  qqnorm(predictions$resids);abline(a = 0, b = 1)   # Predictions onto new data --------------------------------------------  qcs_grid_2011 <- replicate_df(qcs_grid, \"year\", unique(pcod_2011$year)) predictions <- predict(m, newdata = qcs_grid_2011)  # \\donttest{ # A short function for plotting our predictions: plot_map <- function(dat, column = est) {   ggplot(dat, aes(X, Y, fill = {{ column }})) +     geom_raster() +     facet_wrap(~year) +     coord_fixed() }  plot_map(predictions, exp(est)) +   scale_fill_viridis_c(trans = \"sqrt\") +   ggtitle(\"Prediction (fixed effects + all random effects)\")   plot_map(predictions, exp(est_non_rf)) +   ggtitle(\"Prediction (fixed effects and any time-varying effects)\") +   scale_fill_viridis_c(trans = \"sqrt\")   plot_map(predictions, est_rf) +   ggtitle(\"All random field estimates\") +   scale_fill_gradient2()   plot_map(predictions, omega_s) +   ggtitle(\"Spatial random effects only\") +   scale_fill_gradient2()   plot_map(predictions, epsilon_st) +   ggtitle(\"Spatiotemporal random effects only\") +   scale_fill_gradient2()   # Visualizing a marginal effect ----------------------------------------  # See the visreg package or the ggeffects::ggeffect() or # ggeffects::ggpredict() functions # To do this manually:  nd <- data.frame(depth_scaled =   seq(min(d$depth_scaled), max(d$depth_scaled), length.out = 100)) nd$depth_scaled2 <- nd$depth_scaled^2  # Because this is a spatiotemporal model, you'll need at least one time # element. If time isn't also a fixed effect then it doesn't matter what you pick: nd$year <- 2011L # L: integer to match original data p <- predict(m, newdata = nd, se_fit = TRUE, re_form = NA) ggplot(p, aes(depth_scaled, exp(est),   ymin = exp(est - 1.96 * est_se), ymax = exp(est + 1.96 * est_se))) +   geom_line() + geom_ribbon(alpha = 0.4)   # Plotting marginal effect of a spline ---------------------------------  m_gam <- sdmTMB(  data = d, formula = density ~ 0 + as.factor(year) + s(depth_scaled, k = 5),  time = \"year\", mesh = mesh, family = tweedie(link = \"log\") ) if (require(\"visreg\", quietly = TRUE)) {   visreg::visreg(m_gam, \"depth_scaled\") }   # or manually: nd <- data.frame(depth_scaled =   seq(min(d$depth_scaled), max(d$depth_scaled), length.out = 100)) nd$year <- 2011L p <- predict(m_gam, newdata = nd, se_fit = TRUE, re_form = NA) ggplot(p, aes(depth_scaled, exp(est),   ymin = exp(est - 1.96 * est_se), ymax = exp(est + 1.96 * est_se))) +   geom_line() + geom_ribbon(alpha = 0.4)   # Forecasting ---------------------------------------------------------- mesh <- make_mesh(d, c(\"X\", \"Y\"), cutoff = 15)  unique(d$year) #> [1] 2011 2013 2015 2017 m <- sdmTMB(   data = d, formula = density ~ 1,   spatiotemporal = \"AR1\", # using an AR1 to have something to forecast with   extra_time = 2019L, # `L` for integer to match our data   spatial = \"off\",   time = \"year\", mesh = mesh, family = tweedie(link = \"log\") )  # Add a year to our grid: grid2019 <- qcs_grid_2011[qcs_grid_2011$year == max(qcs_grid_2011$year), ] grid2019$year <- 2019L # `L` because `year` is an integer in the data qcsgrid_forecast <- rbind(qcs_grid_2011, grid2019)  predictions <- predict(m, newdata = qcsgrid_forecast) plot_map(predictions, exp(est)) +   scale_fill_viridis_c(trans = \"log10\")  plot_map(predictions, epsilon_st) +   scale_fill_gradient2()   # Estimating local trends ----------------------------------------------  d <- pcod d$year_scaled <- as.numeric(scale(d$year)) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 25) m <- sdmTMB(data = d, formula = density ~ depth_scaled + depth_scaled2,   mesh = mesh, family = tweedie(link = \"log\"),   spatial_varying = ~ 0 + year_scaled, time = \"year\", spatiotemporal = \"off\") nd <- replicate_df(qcs_grid, \"year\", unique(pcod$year)) nd$year_scaled <- (nd$year - mean(d$year)) / sd(d$year) p <- predict(m, newdata = nd)  plot_map(subset(p, year == 2003), zeta_s_year_scaled) + # pick any year   ggtitle(\"Spatial slopes\") +   scale_fill_gradient2()   plot_map(p, est_rf) +   ggtitle(\"Random field estimates\") +   scale_fill_gradient2()   plot_map(p, exp(est_non_rf)) +   ggtitle(\"Prediction (fixed effects only)\") +   scale_fill_viridis_c(trans = \"sqrt\")   plot_map(p, exp(est)) +   ggtitle(\"Prediction (fixed effects + all random effects)\") +   scale_fill_viridis_c(trans = \"sqrt\")  # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/priors.html","id":null,"dir":"Reference","previous_headings":"","what":"Prior distributions — sdmTMBpriors","title":"Prior distributions — sdmTMBpriors","text":"Optional priors/penalties model parameters. results penalized likelihood within TMB can used priors model passed tmbstan (see Bayesian vignette). Note Jacobian adjustments made bayesian = TRUE sdmTMB() model fit. .e., final model fit tmbstan priors specified bayesian set TRUE. Otherwise, leave bayesian = FALSE. pc_matern() Penalized Complexity prior Matern covariance function.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/priors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prior distributions — sdmTMBpriors","text":"","code":"sdmTMBpriors(   matern_s = pc_matern(range_gt = NA, sigma_lt = NA),   matern_st = pc_matern(range_gt = NA, sigma_lt = NA),   phi = halfnormal(NA, NA),   ar1_rho = normal(NA, NA),   tweedie_p = normal(NA, NA),   b = normal(NA, NA),   sigma_V = gamma_cv(NA, NA),   threshold_breakpt_slope = normal(NA, NA),   threshold_breakpt_cut = normal(NA, NA),   threshold_logistic_s50 = normal(NA, NA),   threshold_logistic_s95 = normal(NA, NA),   threshold_logistic_smax = normal(NA, NA) )  normal(location = 0, scale = 1)  halfnormal(location = 0, scale = 1)  gamma_cv(location, cv)  mvnormal(location = 0, scale = diag(length(location)))  pc_matern(range_gt, sigma_lt, range_prob = 0.05, sigma_prob = 0.05)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/priors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prior distributions — sdmTMBpriors","text":"matern_s PC (Penalized Complexity) prior (pc_matern()) spatial random field Matérn parameters. matern_st matern_s spatiotemporal random field. Note likely want set share_fields = FALSE choose set spatial spatiotemporal Matérn PC prior since include prior spatial range parameter. phi halfnormal() prior dispersion parameter observation distribution. ar1_rho normal() prior AR1 random field parameter. Note parameter support -1 < ar1_rho < 1. tweedie_p normal() prior Tweedie power parameter. Note parameter support 1 < tweedie_p < 2 choose mean appropriately. b normal() priors main population-level 'beta' effects. sigma_V gamma_cv() priors time-varying parameter SDs. threshold_breakpt_slope normal() prior slope linear (hockey stick) function. threshold_breakpt_cut normal() prior cutoff linear (hockey stick) function. threshold_logistic_s50 normal() prior parameter f(x) = 0.5. threshold_logistic_s95 normal() prior parameter f(x) = 0.95. threshold_logistic_smax normal() prior parameter f(x) maximized. location Location parameter(s). Typically mean. scale Scale parameter. normal()/halfnormal(): standard deviation(s). mvnormal(): variance-covariance matrix. cv Coefficient variation (SD/mean). range_gt value one expects spatial spatiotemporal range greater 1 - range_prob probability. sigma_lt value one expects spatial spatiotemporal marginal standard deviation (sigma_O sigma_E internally) less 1 - sigma_prob probability. range_prob Probability. See description range_gt. sigma_prob Probability. See description sigma_lt.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/priors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prior distributions — sdmTMBpriors","text":"named list values specified priors.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/priors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prior distributions — sdmTMBpriors","text":"Meant passed priors argument sdmTMB(). normal() halfnormal() define normal half-normal priors , point, must location (mean) parameter 0. halfnormal() normal() can used make syntax clearer. intended used parameters support > 0. See https://arxiv.org/abs/1503.00256 description PC prior Gaussian random fields. Quoting discussion (substituting argument names pc_matern()): \"simulation study observe good coverage equal-tailed 95% credible intervals prior satisfies P(sigma > sigma_lt) = 0.05 P(range < range_gt) = 0.05, sigma_lt 2.5 40 times true marginal standard deviation range_gt 1/10 1/2.5 true range.\" Keep mind range dependent units scale coordinate system. practice, may choose try fitting model without PC prior constraining model . better option simulate model given range sigma choose reasonable values system base prior knowledge model fit similar system spatial information data.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/priors.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prior distributions — sdmTMBpriors","text":"Fuglstad, G.-., Simpson, D., Lindgren, F., Rue, H. (2016) Constructing Priors Penalize Complexity Gaussian Random Fields. arXiv:1503.00256 Simpson, D., Rue, H., Martins, T., Riebler, ., Sørbye, S. (2015) Penalising model component complexity: principled, practical approach constructing priors. arXiv:1403.4630","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/reference/priors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prior distributions — sdmTMBpriors","text":"","code":"normal(0, 1) #>      [,1] [,2] #> [1,]    0    1 #> attr(,\"dist\") #> [1] \"normal\" halfnormal(0, 1) #>      [,1] [,2] #> [1,]    0    1 #> attr(,\"dist\") #> [1] \"normal\" gamma_cv(0.5, 0.2) #>      [,1] [,2] #> [1,]   25 0.02 #> attr(,\"dist\") #> [1] \"gamma\" mvnormal(c(0, 0)) #>      [,1] [,2] [,3] #> [1,]    0    1    0 #> [2,]    0    0    1 #> attr(,\"dist\") #> [1] \"mvnormal\" pc_matern(range_gt = 5, sigma_lt = 1) #> [1] 5.00 1.00 0.05 0.05 #> attr(,\"dist\") #> [1] \"pc_matern\" plot_pc_matern(range_gt = 5, sigma_lt = 1)   # \\donttest{ d <- subset(pcod, year > 2011) pcod_spde <- make_mesh(d, c(\"X\", \"Y\"), cutoff = 30)  # - no priors on population-level effects (`b`) # - halfnormal(0, 10) prior on dispersion parameter `phi` # - Matern PC priors on spatial `matern_s` and spatiotemporal #   `matern_st` random field parameters m <- sdmTMB(density ~ s(depth, k = 3),   data = d, mesh = pcod_spde, family = tweedie(),   share_range = FALSE, time = \"year\",   priors = sdmTMBpriors(     phi = halfnormal(0, 10),     matern_s = pc_matern(range_gt = 5, sigma_lt = 1),     matern_st = pc_matern(range_gt = 5, sigma_lt = 1)   ) )  # - no prior on intercept # - normal(0, 1) prior on depth coefficient # - no prior on the dispersion parameter `phi` # - Matern PC prior m <- sdmTMB(density ~ depth_scaled,   data = d, mesh = pcod_spde, family = tweedie(),   spatiotemporal = \"off\",   priors = sdmTMBpriors(     b = normal(c(NA, 0), c(NA, 1)),     matern_s = pc_matern(range_gt = 5, sigma_lt = 1)   ) )  # You get a prior, you get a prior, you get a prior! # (except on the annual means; see the `NA`s) m <- sdmTMB(density ~ 0 + depth_scaled + depth_scaled2 + as.factor(year),   data = d, time = \"year\", mesh = pcod_spde, family = tweedie(link = \"log\"),   share_range = FALSE, spatiotemporal = \"AR1\",   priors = sdmTMBpriors(     b = normal(c(0, 0, NA, NA, NA), c(2, 2, NA, NA, NA)),     phi = halfnormal(0, 10),     # tweedie_p = normal(1.5, 2),     ar1_rho = normal(0, 1),     matern_s = pc_matern(range_gt = 5, sigma_lt = 1),     matern_st = pc_matern(range_gt = 5, sigma_lt = 1)) ) # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/project.html","id":null,"dir":"Reference","previous_headings":"","what":"Project from an sdmTMB model using simulation — project","title":"Project from an sdmTMB model using simulation — project","text":"function enables projecting forward time sdmTMB model using simulation approach computational efficiency. can helpful calculating predictive intervals long projections including time elements extra_time model estimation can slow. Inspiration approach comes VAST function project_model().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/project.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project from an sdmTMB model using simulation — project","text":"","code":"project(   object,   newdata,   nsim = 1,   uncertainty = c(\"both\", \"random\", \"none\"),   silent = FALSE,   sims_var = \"eta_i\",   sim_re = c(0, 1, 0, 0, 1, 0),   return_tmb_report = FALSE,   ... )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/project.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project from an sdmTMB model using simulation — project","text":"object fitted model sdmTMB(). newdata new data frame predict . contain historical new time elements predict . nsim Number simulations. uncertainty sample uncertainty fitted parameters: \"\" joint fixed random effect precision matrix, \"random\" random effect precision matrix (holding fixed effects MLE), \"none\" neither. silent Silent? sims_var Element extract TMB report. Also see return_tmb_report. sim_re vector 0s 1s representing random effects simulate projection. Generally, leave untouched. Order : spatial fields, spatiotemporal fields, spatially varying coefficient fields, random intercepts, time-varying coefficients, smoothers. default simulate spatiotemporal fields time-varying coefficients, present. return_tmb_report Return TMB report simulate()? lets parse whatever elements want simulation including grabbing multiple elements one set simulations. See examples. ... Passed predict.sdmTMB().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/project.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project from an sdmTMB model using simulation — project","text":"Default: list elements est epsilon_st (spatiotemporal effects present). list element includes matrix rows corresponding rows newdata nsim columns. delta models, components est1, est2, epsilon_st, epsilon_st2 1st 2nd linear predictors. cases, returned values link space. return_tmb_report = TRUE, list TMB reports simulate(). Run names() output see options.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/project.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Project from an sdmTMB model using simulation — project","text":"project_model() VAST package.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/project.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Project from an sdmTMB model using simulation — project","text":"J.T. Thorson wrote original version VAST package. S.C. Anderson wrote version inspired VAST version help .J. Allyn.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/project.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project from an sdmTMB model using simulation — project","text":"","code":"# \\donttest{ library(ggplot2)  mesh <- make_mesh(dogfish, c(\"X\", \"Y\"), cutoff = 25) historical_years <- 2004:2022 to_project <- 10 future_years <- seq(max(historical_years) + 1, max(historical_years) + to_project) all_years <- c(historical_years, future_years) proj_grid <- replicate_df(wcvi_grid, \"year\", all_years)  # we could fit our model like this, but for long projections, this becomes slow: if (FALSE) {   fit <- sdmTMB(     catch_weight ~ 1,     time = \"year\",     offset = log(dogfish$area_swept),     extra_time = all_years, #< note that all years here     spatial = \"on\",     spatiotemporal = \"ar1\",     data = dogfish,     mesh = mesh,     family = tweedie(link = \"log\")   ) }  # instead, we could fit our model like this and then take simulation draws # from the projection time period: fit2 <- sdmTMB(   catch_weight ~ 1,   time = \"year\",   offset = log(dogfish$area_swept),   extra_time = historical_years, #< does *not* include projection years   spatial = \"on\",   spatiotemporal = \"ar1\",   data = dogfish,   mesh = mesh,   family = tweedie(link = \"log\") )  # we will only use 20 `nsim` so this example runs quickly # you will likely want many more (> 200) in practice so the result # is relatively stable  set.seed(1) out <- project(fit2, newdata = proj_grid, nsim = 20) #> Fitted object contains an offset but the offset is `NULL` in `predict.sdmTMB()` #> and `newdata` were supplied. #> Prediction will proceed assuming the offset vector is 0 in the prediction. #> Specify an offset vector in `predict.sdmTMB()` to override this. names(out) #> [1] \"est\"        \"epsilon_st\" est_mean <- apply(out$est, 1, mean) # summarize however you'd like est_se <- apply(out$est, 1, sd)  # visualize: proj_grid$est_mean <- est_mean ggplot(subset(proj_grid, year > 2021), aes(X, Y, fill = est_mean)) +   geom_raster() +   facet_wrap(~year) +   coord_fixed() +   scale_fill_viridis_c() +   ggtitle(\"Projection simulation (mean)\")   # visualize the spatiotemporal random fields: proj_grid$eps_mean <- apply(out$epsilon_st, 1, mean) proj_grid$eps_se <- apply(out$epsilon_st, 1, sd) ggplot(subset(proj_grid, year > 2021), aes(X, Y, fill = eps_mean)) +   geom_raster() +   facet_wrap(~year) +   scale_fill_gradient2() +   coord_fixed() +   ggtitle(\"Projection simulation\\n(spatiotemporal fields)\")   ggplot(subset(proj_grid, year > 2021), aes(X, Y, fill = eps_se)) +   geom_raster() +   facet_wrap(~year) +   scale_fill_viridis_c() +   coord_fixed() +   ggtitle(\"Projection simulation\\n(spatiotemporal fields standard error)\")  # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. generics tidy","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/replicate_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Replicate a prediction data frame over time — replicate_df","title":"Replicate a prediction data frame over time — replicate_df","text":"Useful replicating prediction grids across time slices used model fitting.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/replicate_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replicate a prediction data frame over time — replicate_df","text":"","code":"replicate_df(dat, time_name, time_values)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/replicate_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replicate a prediction data frame over time — replicate_df","text":"dat Data frame. time_name Name time column output. time_values Time values replicate dat .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/replicate_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replicate a prediction data frame over time — replicate_df","text":"data frame replicated time_values new column based time_name.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/replicate_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replicate a prediction data frame over time — replicate_df","text":"","code":"df <- data.frame(variable = c(\"a\", \"b\")) replicate_df(df, time_name = \"year\", time_values = 1:3) #>   variable year #> 1        a    1 #> 2        b    1 #> 3        a    2 #> 4        b    2 #> 5        a    3 #> 6        b    3  head(qcs_grid) #>     X    Y    depth depth_scaled depth_scaled2 #> 1 456 5636 347.0834    1.5608122    2.43613479 #> 2 458 5636 223.3348    0.5697699    0.32463771 #> 3 460 5636 203.7408    0.3633693    0.13203724 #> 4 462 5636 183.2987    0.1257046    0.01580166 #> 5 464 5636 182.9998    0.1220368    0.01489297 #> 6 466 5636 186.3892    0.1632882    0.02666303 nd <- replicate_df(qcs_grid, \"year\", unique(pcod$year)) head(nd) #>     X    Y    depth depth_scaled depth_scaled2 year #> 1 456 5636 347.0834    1.5608122    2.43613479 2003 #> 2 458 5636 223.3348    0.5697699    0.32463771 2003 #> 3 460 5636 203.7408    0.3633693    0.13203724 2003 #> 4 462 5636 183.2987    0.1257046    0.01580166 2003 #> 5 464 5636 182.9998    0.1220368    0.01489297 2003 #> 6 466 5636 186.3892    0.1632882    0.02666303 2003 table(nd$year) #>  #> 2003 2004 2005 2007 2009 2011 2013 2015 2017  #> 7314 7314 7314 7314 7314 7314 7314 7314 7314"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals method for sdmTMB models — residuals.sdmTMB","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"See residual-checking vignette: browseVignettes(\"sdmTMB\") documentation site. See notes types residuals 'Details' section .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"","code":"# S3 method for class 'sdmTMB' residuals(   object,   type = c(\"mle-mvn\", \"mle-eb\", \"mle-mcmc\", \"response\", \"pearson\", \"deviance\"),   model = c(1, 2),   mcmc_samples = NULL,   qres_func = NULL,   ... )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"object sdmTMB() model. type Residual type. See details. model delta/hurdle model component? mcmc_samples vector MCMC samples linear predictor link space. See predict_mle_mcmc() function sdmTMBextra package. qres_func custom quantile residuals function. Function take arguments object, y, mu, ... return vector length length(y). ... Passed custom qres_func function. Unused.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"vector residuals. Note randomization single random effect posterior sample randomized quantile routines result different residuals call. suggested set randomization seed go \"fishing\" perfect residuals present inspected residuals.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"Randomized quantile residuals: mle-mvn, mle-eb, mle-mcmc implementations randomized quantile residuals (Dunn & Smyth 1996), also known probability integral transform (PIT) residuals (Smith 1985). data consistent model assumptions, residuals distributed normal(0, 1). Randomization added account integer binary response observations. example, Poisson observation likelihood observations y mean predictions mu, create randomized quantile residuals :   Types residuals: Acronyms: EB: Empirical Bayes MCMC: Markov chain Monte Carlo MLE: Maximum Likelihood Estimate MVN: Multivariate normal mle-mvn: Fixed effects held MLEs random effects taken single approximate posterior sample. \"approximate\" part refers sample taken random effects' assumed MVN distribution. practice, sample obtained based mode Hessian random effects taking advantage sparsity Hessian computational efficiency. sample taken obj$MC(), obj TMB object created TMB::MakeADFun(). See Waagepetersen (2006) description source code internal TMB function TMB:::oneSamplePosterior(). Residuals converted randomized quantile residuals described . mle-eb: Fixed effects held MLEs random effects taken EB estimates. used default residuals sdmTMB (called mle-laplace). available backwards compatibility research purposes recommended checking goodness fit. Residuals converted randomized quantile residuals described . mle-mcmc: Fixed effects held MLEs random effects taken single posterior sample obtained MCMC. excellent option since make assumption distribution random effects (compared mle-mvn option) can slow obtain. See Waagepetersen (2006) Thygesen et al. (2017). Residuals converted randomized quantile residuals described . See sdmTMBextra package function predict_mle_mcmc(), can generate MCMC samples pass mcmc_samples argument. Ideally MCMC run convergence last iteration can used residuals. defaults may sufficient many models. response: simple observed minus predicted residuals. pearson: Pearson residuals: response residuals scaled standard deviation. weights present, residuals multiplied sqrt(weights).","code":"a <- ppois(y - 1, mu) b <- ppois(y, mu) u <- runif(n = length(y), min = a, max = b) qnorm(u)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"Dunn, P.K. & Smyth, G.K. (1996). Randomized Quantile Residuals. Journal Computational Graphical Statistics, 5, 236–244. Smith, J.Q. (1985). Diagnostic checks non-standard time series models. Journal Forecasting, 4, 283–291. Waagepetersen, R. (2006). simulation-based goodness--fit test random effects generalized linear mixed models. Scandinavian Journal Statistics, 33(4), 721-731. Thygesen, U.H., Albertsen, C.M., Berg, C.W., Kristensen, K., Nielsen, . 2017. Validation ecological state space models using Laplace approximation. Environ Ecol Stat 24(2): 317–339. doi:10.1007/s10651-017-0372-4 Rufener, M.-C., Kristensen, K., Nielsen, J.R., Bastardie, F. 2021. Bridging gap commercial fisheries survey data model spatiotemporal dynamics marine species. Ecological Applications. e02453. doi:10.1002/eap.2453","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"","code":"mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), cutoff = 10) fit <- sdmTMB(   present ~ as.factor(year) + poly(depth, 2),   data = pcod_2011, mesh = mesh,   family = binomial() )  # the default \"mle-mvn\" residuals use fixed effects at their MLE and a # single sample from the approximate random effect posterior: set.seed(9283) r <- residuals(fit, type = \"mle-mvn\") qqnorm(r) abline(0, 1)   # response residuals will be not be normally distributed unless # the family is Gaussian: r <- residuals(fit, type = \"response\") qqnorm(r) abline(0, 1)   # \"mle-eb\" are quick but are not expected to be N(0, 1); not recommended: set.seed(2321) r <- residuals(fit, type = \"mle-eb\") qqnorm(r) abline(0, 1)   # see also \"mle-mcmc\" residuals with the help of the sdmTMBextra package # we can fake them here by taking a single sample from the joint precision # matrix and pretending they are MCMC samples: set.seed(82728) p <- predict(fit, nsim = 1) # pretend these are from sdmTMBextra::predict_mle_mcmc() r <- residuals(fit, mcmc_samples = p) qqnorm(r) abline(0, 1)"},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/reference/run_extra_optimization.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run extra optimization on an already fitted object — run_extra_optimization","text":"","code":"run_extra_optimization(object, nlminb_loops = 0, newton_loops = 1)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/run_extra_optimization.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run extra optimization on an already fitted object — run_extra_optimization","text":"object object sdmTMB(). nlminb_loops many extra times run stats::nlminb() optimization. Sometimes restarting optimizer previous best values aids convergence. newton_loops many extra Newton optimization loops try stats::optimHess(). Sometimes aids convergence.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/run_extra_optimization.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run extra optimization on an already fitted object — run_extra_optimization","text":"updated model fit class sdmTMB.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/run_extra_optimization.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run extra optimization on an already fitted object — run_extra_optimization","text":"","code":"# Run extra optimization steps to help convergence: # (Not typically needed) fit <- sdmTMB(density ~ 0 + poly(depth, 2) + as.factor(year),   data = pcod_2011, mesh = pcod_mesh_2011, family = tweedie()) fit_1 <- run_extra_optimization(fit, newton_loops = 1) #> attempting to improve convergence with Newton update(s) #> retaining parameters from before Newton update #> and skipping further Newton updates max(fit$gradients) #> [1] 5.791606e-09 max(fit_1$gradients) #> [1] 5.791606e-09"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sanity.html","id":null,"dir":"Reference","previous_headings":"","what":"Sanity check of an sdmTMB model — sanity","title":"Sanity check of an sdmTMB model — sanity","text":"Sanity check sdmTMB model","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sanity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sanity check of an sdmTMB model — sanity","text":"","code":"sanity(object, big_sd_log10 = 2, gradient_thresh = 0.001, silent = FALSE)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sanity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sanity check of an sdmTMB model — sanity","text":"object Fitted model sdmTMB(). big_sd_log10 Value check size standard errors . value 2 indicate standard errors greater 10^2 (.e., 100) flagged. gradient_thresh Gradient threshold issue warning. silent Logical: suppress messages? Useful set TRUE running large numbers models just interested returning sanity list objects.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sanity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sanity check of an sdmTMB model — sanity","text":"invisible named list checks.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sanity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sanity check of an sdmTMB model — sanity","text":"object NA, NULL, class \"try-error\", sanity() return FALSE. facilitate using sanity() models try() tryCatch(). See examples section.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sanity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sanity check of an sdmTMB model — sanity","text":"","code":"fit <- sdmTMB(   present ~ s(depth),   data = pcod_2011, mesh = pcod_mesh_2011,   family = binomial() ) sanity(fit) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameter doesn't look unreasonably large  s <- sanity(fit) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameter doesn't look unreasonably large s #> $hessian_ok #> [1] TRUE #>  #> $eigen_values_ok #> [1] TRUE #>  #> $nlminb_ok #> [1] TRUE #>  #> $range_ok #> [1] TRUE #>  #> $gradients_ok #> [1] TRUE #>  #> $se_magnitude_ok #> [1] TRUE #>  #> $se_na_ok #> [1] TRUE #>  #> $sigmas_ok #> [1] TRUE #>  #> $all_ok #> [1] TRUE #>   # If fitting many models in a loop, you may want to wrap # sdmTMB() in try() to handle errors. sanity() will take an object # of class \"try-error\" and return FALSE. # Here, we will use stop() to simulate a failed sdmTMB() fit: failed_fit <- try(stop()) #> Error in try(stop()) :  s2 <- sanity(failed_fit) all(unlist(s)) #> [1] TRUE all(unlist(s2)) #> [1] FALSE"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"Fit spatial spatiotemporal generalized linear mixed effects model (GLMM) TMB (Template Model Builder) R package. Spatial spatiotemporal random fields approximated using SPDE (stochastic partial differential equation) approach, allows efficient modeling data correlated space /time. See model description vignette details.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"","code":"sdmTMB(   formula,   data,   mesh,   time = NULL,   family = gaussian(link = \"identity\"),   spatial = c(\"on\", \"off\"),   spatiotemporal = c(\"iid\", \"ar1\", \"rw\", \"off\"),   share_range = TRUE,   time_varying = NULL,   time_varying_type = c(\"rw\", \"rw0\", \"ar1\"),   spatial_varying = NULL,   weights = NULL,   offset = NULL,   extra_time = NULL,   reml = FALSE,   silent = TRUE,   anisotropy = FALSE,   control = sdmTMBcontrol(),   priors = sdmTMBpriors(),   knots = NULL,   bayesian = FALSE,   previous_fit = NULL,   do_fit = TRUE,   do_index = FALSE,   predict_args = NULL,   index_args = NULL,   experimental = NULL )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"formula Model formula. IID random intercepts slopes possible using lme4 syntax, e.g., + (1 | g) + (0 + depth | g) + (1 + depth | g) g column class character factor representing groups. Penalized splines possible via mgcv s(). Optionally list delta (hurdle) models.  See examples details . data data frame. mesh object make_mesh(). time optional time column name (character). Can left NULL model spatial random fields; however, data actually spatiotemporal wish use get_index() get_cog() downstream, supply time argument. family family link. Supports gaussian(), Gamma(), binomial(), poisson(), Beta(), betabinomial(), nbinom2(), truncated_nbinom2(), nbinom1(), truncated_nbinom1(), censored_poisson(), gamma_mix(), lognormal_mix(), student(), tweedie(), gengamma(). Delta/hurdle models (zero-inflated data) include: delta_beta(), delta_gamma(), delta_gamma_mix(), delta_lognormal_mix(), delta_lognormal(), delta_truncated_nbinom2(). See delta-model vignette details. binomial family options, see 'Binomial families' Details section . spatial Estimate spatial random fields? Options '' / '' TRUE / FALSE. Optionally, list delta models, e.g. list('', ''). spatiotemporal Estimate spatiotemporal random fields 'iid' (independent identically distributed; default), stationary 'ar1' (first-order autoregressive), random walk ('rw'), fixed 0 ''. set '' time = NULL. delta model, can list. E.g., list('', 'ar1'). Guidance: Use 'iid' temporal correlation negligible already accounted fixed effects; 'ar1' correlation consecutive time steps decays gradually; 'rw' changes time steps cumulative (step builds last). AR1 correlation coefficient (rho) estimated close 1 (say > 0.99), consider switching 'rw'. See model description vignette mathematical details. Capitalization ignored. TRUE gets converted 'iid' FALSE gets converted ''. share_range Logical: estimate shared spatial spatiotemporal range parameter (TRUE, default) independent range parameters (FALSE). delta model, can list. E.g., list(TRUE, FALSE). time_varying optional one-sided formula describing covariates modelled time-varying process. Set type process time_varying_type. See help time_varying_type warnings modelling first time step. Structure shared delta models. time_varying_type Type time-varying process apply time_varying formula. Options: 'rw' (random walk, default), 'rw0' (random walk mean-zero prior first time step), 'ar1' (autoregressive, coefficients fluctuate around mean). 'rw0' 'ar1', coefficient starts zero first time step. 'rw' (default), first time step estimated separately—case, avoid including covariates formula time_varying prevent non-identifiability (use ~ 0 ~ -1 least one). Structure shared delta models. spatial_varying optional one-sided formula coefficients vary space random fields. Allows effect covariate differ spatially. likely want include variable fixed effect formula estimate average effect—spatial field represents deviations average (since mean zero). example, use formula = y ~ depth spatial_varying = ~ 0 + depth model average depth effect plus spatially varying deviations. (scaled) time column used, creates local-time-trend model. See doi:10.1111/ecog.05176  spatial trends vignette. Predictors usually centered mean zero standard deviation approximately 1. spatial intercept controlled spatial argument; set spatial = '' '' include exclude . factor predictors, spatial_varying excludes intercept (~ 0 ~ -1), set spatial = '' match. Structure must shared delta models. weights numeric vector representing optional likelihood weights conditional model. Implemented glmmTMB: weights sum one internally modified. Can also used trials binomial family; weights argument needs vector name variable data frame. See Details section . offset numeric vector representing model offset character value representing column name offset. delta/hurdle models, applies positive component. Usually log transformed variable. extra_time Optional extra time slices (e.g., years) include interpolation forecasting predict function. See Details section . reml Logical: use REML (restricted maximum likelihood) estimation rather maximum likelihood? REML accounts uncertainty estimating fixed effects can reduce bias variance parameter estimates, prevents likelihood-based model comparison (e.g., AIC) models different fixed effects. Use TRUE focus random effect variance parameters; use FALSE (default) comparing models different fixed effects performing index standardization. silent Silent include optimization details? Helpful set FALSE models take fit. anisotropy Logical: allow anisotropy (spatial correlation directionally dependent)? See plot_anisotropy(). Must shared across delta models. control Optimization control options via sdmTMBcontrol(). priors Optional penalties/priors via sdmTMBpriors(). Must currently shared across delta models. knots Optional named list containing knot values used basis construction smoothing terms. See mgcv::gam() mgcv::gamm(). E.g., s(x, bs = 'cc', k = 4), knots = list(x = c(1, 2, 3, 4)) bayesian Logical indicating model passed tmbstan. TRUE, Jacobian adjustments applied account parameter transformations priors applied. previous_fit previously fitted sdmTMB model initialize optimization . Can greatly speed fitting. Note model must set exactly way. However, data weights arguments can change, can useful cross-validation. do_fit Fit model (TRUE) return processed data without fitting (FALSE)? do_index index standardization calculations fitting? Saves memory time working large datasets projection grids since TMB object rebuilt predict.sdmTMB() get_index(). TRUE, predict_args must newdata element supplied area can supplied index_args. users can ignore option. fitted object can passed directly get_index(). predict_args list arguments pass predict.sdmTMB() do_index = TRUE. users can ignore option. index_args list arguments pass get_index() do_index = TRUE. Currently, area supported. Bias correction can done calling get_index() resulting fitted object. users can ignore option. experimental named list esoteric -development options. dragons.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"object (list) class sdmTMB. Useful elements include: sd_report: output TMB::sdreport() gradients: marginal log likelihood gradients respect fixed effect model: output stats::nlminb() data: fitted data spde: object supplied mesh argument family: family object, includes inverse link function family$linkinv() tmb_params: parameters list passed TMB::MakeADFun() tmb_map: 'map' list passed TMB::MakeADFun() tmb_data: data list passed TMB::MakeADFun() tmb_obj: TMB object created TMB::MakeADFun()","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"Model description sdmTMB fits GLMMs spatial /spatiotemporal random fields, account correlation data due spatial proximity, alternatively, latent spatial spatiotemporal effects. Spatial fields represent consistent spatial patterns, spatiotemporal fields represent spatial patterns vary time. See model description vignette mathematical details paper: doi:10.1101/2022.03.24.485545 Binomial families Following structure stats::glm() glmmTMB, binomial family can specified one 4 ways: (1) response may factor (model classifies first level versus others), (2) response may binomial (0/1), (3) response can matrix form cbind(success, failure), (4) response may observed proportions, 'weights' argument used specify Binomial size (N) parameter (prob ~ ..., weights = N). Smooth terms Smooth terms can included following GAMs (generalized additive models) using + s(x), implements smooth mgcv::s(). sdmTMB uses penalized smooths, constructed via mgcv::smooth2random(). similar approach implemented gamm4 brms, among packages. Within smooths, syntax commonly used mgcv::s() mgcv::t2() can applied, e.g. 2-dimensional smooths may constructed + s(x, y) + t2(x, y); smooths can specific various factor levels, + s(x, = group); basis function dimensions may specified, e.g. + s(x, k = 4); various types splines may constructed cyclic splines model seasonality (perhaps knots argument also supplied). Threshold models linear break-point relationship covariate can included via + breakpt(variable) formula, variable single covariate corresponding column data. case, relationship linear point constant (hockey-stick shaped). Similarly, logistic-function threshold model can included via + logistic(variable). option models relationship logistic function 50% 95% values. similar length- size-based selectivity fisheries, parameterized points f(x) = 0.5 0.95. See threshold vignette. Note single threshold covariate can included covariate included components delta families. Extra time: forecasting interpolating Extra time slices (e.g., years) can included interpolation forecasting predict function via extra_time argument. predict function requires time slices defined fitting model ensure various time indices set correctly. careful including extra time slices model remains identifiable. example, including + .factor(year) formula render model data inform expected value missing year. sdmTMB() makes attempt determine model makes sense forecasting interpolation. options time_varying, spatiotemporal = \"rw\", spatiotemporal = \"ar1\", smoother time column provide mechanisms predict missing time slices process error. extra_time can also used fill missing time steps purposes random walk AR(1) process gaps time steps uneven. extra_time can include extra time steps time steps including found fitted data. latter option may simpler. Regularization priors can achieve regularization via penalties (priors) fixed effect parameters. See sdmTMBpriors(). can fit model without penalties look output print(your_model) tidy(your_model) fit model do_fit = FALSE inspect head(your_model$tmb_data$X_ij[[1]]) want see formula translated fixed effect model matrix. Also see Bayesian vignette. Delta/hurdle models Delta models (also known hurdle models) can fit two separate models time using appropriate delta family. E.g.: delta_gamma(), delta_beta(), delta_lognormal(), delta_truncated_nbinom2(). fit delta family, default formula, spatial, spatiotemporal components shared. elements can specified independently two models using list format. include formula, spatial, spatiotemporal, share_range. first element list binomial component second element positive component (e.g., Gamma). elements must shared now (e.g., spatially varying coefficients, time-varying coefficients). Furthermore, currently limitations specifying two formulas list: two formulas smoothers threshold effects. now, must specified single formula shared across two models. main advantage specifying models using delta family (compared fitting two separate models) (1) coding simplicity (2) calculation uncertainty derived quantities index abundance get_index() using generalized delta method within TMB. Also, selected parameters can shared across models. See delta-model vignette. Index standardization index standardization, may wish include 0 + .factor(year) (whatever time column called) formula. See basic example index standardization relevant package vignette. need specify time argument. See get_index().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"Main reference introducing package cite using sdmTMB: Anderson, S.C., E.J. Ward, P.. English, L..K. Barnett. 2022. sdmTMB: R package fast, flexible, user-friendly generalized linear mixed effects models spatial spatiotemporal random fields. bioRxiv 2022.03.24.485545; doi:10.1101/2022.03.24.485545 . Reference local trends: Barnett, L..K., E.J. Ward, S.C. Anderson. 2021. Improving estimates species distribution change incorporating local trends. Ecography. 44(3):427-439. doi:10.1111/ecog.05176 . explanation model application calculating climate velocities: English, P., E.J. Ward, C.N. Rooper, R.E. Forrest, L.. Rogers, K.L. Hunter, .M. Edwards, B.M. Connors, S.C. Anderson. 2021. Contrasting climate velocity impacts warm cool locations show effects marine warming worse already warmer temperate waters. Fish Fisheries. 23(1) 239-255. doi:10.1111/faf.12613 . Discussion illustration decision points fitting models: Commander, C.J.C., L..K. Barnett, E.J. Ward, S.C. Anderson, T.E. Essington. 2022. shadow model: small choices spatially explicit species distribution models affect predictions. PeerJ 10: e12783. doi:10.7717/peerj.12783 . Application description threshold/break-point models: Essington, T.E., S.C. Anderson, L..K. Barnett, H.M. Berger, S.. Siedlecki, E.J. Ward. 2022. Advancing statistical models reveal effect dissolved oxygen spatial distribution marine taxa using thresholds physiologically based index. Ecography. 2022: e06249 doi:10.1111/ecog.06249 . Application fish body condition: Lindmark, M., S.C. Anderson, M. Gogina, M. Casini. Evaluating drivers spatiotemporal individual condition bottom-associated marine fish. bioRxiv 2022.04.19.488709. doi:10.1101/2022.04.19.488709 . Several sections original TMB model code adapted VAST R package: Thorson, J.T. 2019. Guidance decisions using Vector Autoregressive Spatio-Temporal (VAST) package stock, ecosystem, habitat climate assessments. Fish. Res. 210:143–161. doi:10.1016/j.fishres.2018.10.013 . Code family R--TMB implementation, selected parameterizations observation likelihoods, general package structure inspiration, idea behind TMB prediction approach adapted glmmTMB R package: Brooks, M.E., K. Kristensen, K.J. van Benthem, . Magnusson, C.W. Berg, . Nielsen, H.J. Skaug, M. Maechler, B.M. Bolker. 2017. glmmTMB Balances Speed Flexibility Among Packages Zero-inflated Generalized Linear Mixed Modeling. R Journal, 9(2):378-400. doi:10.32614/rj-2017-066 . Implementation geometric anisotropy SPDE use random field GLMMs index standardization: Thorson, J.T., .O. Shelton, E.J. Ward, H.J. Skaug. 2015. Geostatistical delta-generalized linear mixed models improve precision estimated abundance indices West Coast groundfishes. ICES J. Mar. Sci. 72(5): 1297–1310. doi:10.1093/icesjms/fsu243 .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"","code":"library(sdmTMB)  # Build a mesh to implement the SPDE approach: mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), cutoff = 20)  # - this example uses a fairly coarse mesh so these examples run quickly # - 'cutoff' is the minimum distance between mesh vertices in units of the #   x and y coordinates # - 'cutoff = 10' might make more sense in applied situations for this dataset # - or build any mesh in 'fmesher' and pass it to the 'mesh' argument in make_mesh()` # - the mesh is not needed if you will be turning off all #   spatial/spatiotemporal random fields  # Quick mesh plot: plot(mesh)   # Fit a Tweedie spatial random field GLMM with a smoother for depth: fit <- sdmTMB(   density ~ s(depth),   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)     2.16    0.34 #> sdepth          1.94    3.13 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)     13.07 #>  #> Dispersion parameter: 13.68 #> Tweedie p: 1.58 #> Matérn range: 16.84 #> Spatial SD: 2.20 #> ML criterion at convergence: 2937.789 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Extract coefficients: tidy(fit, conf.int = TRUE) #> # A tibble: 2 × 5 #>   term        estimate std.error conf.low conf.high #>   <chr>          <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)     2.16     0.340     1.50      2.83 #> 2 sdepth          1.94     3.13     -4.19      8.07 tidy(fit, effects = \"ran_par\", conf.int = TRUE) #> # A tibble: 5 × 5 #>   term         estimate std.error conf.low conf.high #>   <chr>           <dbl>     <dbl>    <dbl>     <dbl> #> 1 range           16.8    13.7       3.40      83.3  #> 2 phi             13.7     0.663    12.4       15.0  #> 3 sigma_O          2.20    1.23      0.735      6.59 #> 4 tweedie_p        1.58    0.0153    1.55       1.61 #> 5 sd__s(depth)    13.1    NA         6.07      28.2   # Perform several 'sanity' checks: sanity(fit) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameter doesn't look unreasonably large  # Predict on the fitted data; see ?predict.sdmTMB p <- predict(fit)  # Predict on new data: p <- predict(fit, newdata = qcs_grid) head(p) #>     X    Y    depth depth_scaled depth_scaled2       est est_non_rf      est_rf #> 1 456 5636 347.0834    1.5608122    2.43613479 -4.726631  -4.567379 -0.15925224 #> 2 458 5636 223.3348    0.5697699    0.32463771  2.342471   2.368314 -0.02584342 #> 3 460 5636 203.7408    0.3633693    0.13203724  3.087513   2.979948  0.10756540 #> 4 462 5636 183.2987    0.1257046    0.01580166  3.878560   3.637586  0.24097423 #> 5 464 5636 182.9998    0.1220368    0.01489297  4.020914   3.646531  0.37438305 #> 6 466 5636 186.3892    0.1632882    0.02666303  4.050895   3.543104  0.50779187 #>       omega_s #> 1 -0.15925224 #> 2 -0.02584342 #> 3  0.10756540 #> 4  0.24097423 #> 5  0.37438305 #> 6  0.50779187  # \\donttest{ # Visualize the depth effect with ggeffects: ggeffects::ggpredict(fit, \"depth [all]\") |> plot()   # Visualize depth effect with visreg: (see ?visreg_delta) visreg::visreg(fit, xvar = \"depth\") # link space; randomized quantile residuals  visreg::visreg(fit, xvar = \"depth\", scale = \"response\")  visreg::visreg(fit, xvar = \"depth\", scale = \"response\", gg = TRUE, rug = FALSE) #> Warning: `aes_string()` was deprecated in ggplot2 3.0.0. #> ℹ Please use tidy evaluation idioms with `aes()`. #> ℹ See also `vignette(\"ggplot2-in-packages\")` for more information. #> ℹ The deprecated feature was likely used in the visreg package. #>   Please report the issue at <https://github.com/pbreheny/visreg/issues>. #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead. #> ℹ The deprecated feature was likely used in the ggplot2 package. #>   Please report the issue at <https://github.com/tidyverse/ggplot2/issues>.   # Add spatiotemporal random fields: fit <- sdmTMB(   density ~ 0 + as.factor(year),   time = \"year\", #<   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ 0 + as.factor(year) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #> Conditional model: #>                     coef.est coef.se #> as.factor(year)2011     2.76    0.36 #> as.factor(year)2013     3.10    0.35 #> as.factor(year)2015     3.21    0.35 #> as.factor(year)2017     2.47    0.36 #>  #> Dispersion parameter: 14.83 #> Tweedie p: 1.57 #> Matérn range: 13.31 #> Spatial SD: 3.16 #> Spatiotemporal IID SD: 1.79 #> ML criterion at convergence: 3007.552 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Make the fields AR1: fit <- sdmTMB(   density ~ s(depth),   time = \"year\",   spatial = \"off\",   spatiotemporal = \"ar1\", #<   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)     1.84    0.33 #> sdepth          1.96    3.27 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)      13.6 #>  #> Dispersion parameter: 12.84 #> Tweedie p: 1.55 #> Spatiotemporal AR1 correlation (rho): 0.67 #> Matérn range: 12.22 #> Spatiotemporal marginal AR1 SD: 3.28 #> ML criterion at convergence: 2914.393 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Make the fields a random walk: fit <- sdmTMB(   density ~ s(depth),   time = \"year\",   spatial = \"off\",   spatiotemporal = \"rw\", #<   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)     1.95    0.34 #> sdepth          1.96    3.18 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)     13.22 #>  #> Dispersion parameter: 12.84 #> Tweedie p: 1.56 #> Matérn range: 14.66 #> Spatiotemporal RW SD: 2.17 #> ML criterion at convergence: 2919.181 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Depth smoothers by year: fit <- sdmTMB(   density ~ s(depth, by = as.factor(year)), #<   time = \"year\",   spatial = \"off\",   spatiotemporal = \"rw\",   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth, by = as.factor(year)) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #> Conditional model: #>                             coef.est coef.se #> (Intercept)                     1.76    0.34 #> sdepth):as.factor(year)2011     0.07    4.02 #> sdepth):as.factor(year)2013     4.59    3.28 #> sdepth):as.factor(year)2015     5.97    6.01 #> sdepth):as.factor(year)2017    -1.97    3.22 #>  #> Smooth terms: #>                                  Std. Dev. #> sd__s(depth):as.factor(year)2011     16.62 #> sd__s(depth):as.factor(year)2013     13.57 #> sd__s(depth):as.factor(year)2015     28.24 #> sd__s(depth):as.factor(year)2017     18.65 #>  #> Dispersion parameter: 12.70 #> Tweedie p: 1.55 #> Matérn range: 8.62 #> Spatiotemporal RW SD: 3.14 #> ML criterion at convergence: 2924.193 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # 2D depth-year smoother: fit <- sdmTMB(   density ~ s(depth, year), #<   spatial = \"off\",   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth, year) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #> Conditional model: #>              coef.est coef.se #> (Intercept)      2.55    0.24 #> sdepthyear_1     0.15    0.09 #> sdepthyear_2     2.93    2.07 #>  #> Smooth terms: #>                   Std. Dev. #> sd__s(depth,year)      6.08 #>  #> Dispersion parameter: 14.95 #> Tweedie p: 1.60 #> ML criterion at convergence: 2974.143 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Turn off spatial random fields: fit <- sdmTMB(   present ~ poly(log(depth)),   spatial = \"off\", #<   data = pcod_2011, mesh = mesh,   family = binomial() ) fit #> Model fit by ML ['sdmTMB'] #> Formula: present ~ poly(log(depth)) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: binomial(link = 'logit') #>   #> Conditional model: #>                  coef.est coef.se #> (Intercept)         -0.16    0.07 #> poly(log(depth))   -13.19    2.14 #>  #> ML criterion at convergence: 648.334 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Which, matches glm(): fit_glm <- glm(   present ~ poly(log(depth)),   data = pcod_2011,   family = binomial() ) summary(fit_glm) #>  #> Call: #> glm(formula = present ~ poly(log(depth)), family = binomial(),  #>     data = pcod_2011) #>  #> Coefficients: #>                   Estimate Std. Error z value Pr(>|z|)     #> (Intercept)       -0.16433    0.06583  -2.496   0.0126 *   #> poly(log(depth)) -13.18981    2.14179  -6.158 7.35e-10 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for binomial family taken to be 1) #>  #>     Null deviance: 1337.2  on 968  degrees of freedom #> Residual deviance: 1296.7  on 967  degrees of freedom #> AIC: 1300.7 #>  #> Number of Fisher Scoring iterations: 4 #>  AIC(fit, fit_glm) #>         df      AIC #> fit      2 1300.668 #> fit_glm  2 1300.668  # Delta/hurdle binomial-Gamma model: fit_dg <- sdmTMB(   density ~ poly(log(depth), 2),   data = pcod_2011, mesh = mesh,   spatial = \"off\",   family = delta_gamma() #< ) fit_dg #> Model fit by ML ['sdmTMB'] #> Formula: density ~ poly(log(depth), 2) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: delta_gamma(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #> Conditional model: #>                      coef.est coef.se #> (Intercept)             -0.48    0.09 #> poly(log(depth), 2)1   -23.06    3.15 #> poly(log(depth), 2)2   -48.79    4.45 #>  #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: Gamma(link = 'log')  #> Conditional model: #>                      coef.est coef.se #> (Intercept)              4.24    0.08 #> poly(log(depth), 2)1    -5.49    3.50 #> poly(log(depth), 2)2   -13.26    3.23 #>  #> Dispersion parameter: 0.64 #>  #> ML criterion at convergence: 2936.579 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Delta model with different formulas and spatial structure: fit_dg <- sdmTMB(   list(density ~ depth_scaled, density ~ poly(depth_scaled, 2)), #<   data = pcod_2011, mesh = mesh,   spatial = list(\"off\", \"on\"), #<   family = delta_gamma() ) fit_dg #> Spatial model fit by ML ['sdmTMB'] #> Formula: list(density ~ depth_scaled, density ~ poly(depth_scaled, 2)) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: delta_gamma(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #> Conditional model: #>              coef.est coef.se #> (Intercept)     -0.17    0.07 #> depth_scaled    -0.43    0.07 #>  #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: Gamma(link = 'log')  #> Conditional model: #>                        coef.est coef.se #> (Intercept)                4.08    0.14 #> poly(depth_scaled, 2)1    -6.15    4.52 #> poly(depth_scaled, 2)2   -12.58    4.14 #>  #> Dispersion parameter: 0.72 #> Matérn range: 0.01 #> Spatial SD: 2148.87 #>  #> ML criterion at convergence: 3034.512 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. #>  #> **Possible issues detected! Check output of sanity().**  # Delta/hurdle truncated NB2: pcod_2011$count <- round(pcod_2011$density) fit_nb2 <- sdmTMB(   count ~ s(depth),   data = pcod_2011, mesh = mesh,   spatial = \"off\",   family = delta_truncated_nbinom2() #< ) fit_nb2 #> Model fit by ML ['sdmTMB'] #> Formula: count ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: delta_truncated_nbinom2(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #> Conditional model: #>             coef.est coef.se #> (Intercept)    -0.69    0.21 #> sdepth          0.29    2.37 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)       9.6 #>  #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: truncated_nbinom2(link = 'log')  #> Conditional model: #>             coef.est coef.se #> (Intercept)     4.18    0.22 #> sdepth         -0.37    1.77 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)      6.73 #>  #> Dispersion parameter: 0.49 #>  #> ML criterion at convergence: 2915.733 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Regular NB2: fit_nb2 <- sdmTMB(   count ~ s(depth),   data = pcod_2011, mesh = mesh,   spatial = \"off\",   family = nbinom2() #< ) fit_nb2 #> Model fit by ML ['sdmTMB'] #> Formula: count ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: nbinom2(link = 'log') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)     2.49    0.27 #> sdepth          3.61    3.96 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)      16.4 #>  #> Dispersion parameter: 0.14 #> ML criterion at convergence: 3006.939 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # IID random intercepts by year: pcod_2011$fyear <- as.factor(pcod_2011$year) fit <- sdmTMB(   density ~ s(depth) + (1 | fyear), #<   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth) + (1 | fyear) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #> Random intercepts and/or slopes: #>  #> Conditional model: #>      Groups        Name    Variance    Std.Dev.  #>       fyear (Intercept)        0.09        0.30  #>  #> Conditional model: #>             coef.est coef.se #> (Intercept)     2.13    0.37 #> sdepth          1.82    2.99 #>  #> Smooth terms: #>              Std. Dev. #> sd__s(depth)     12.51 #>  #> Dispersion parameter: 13.55 #> Tweedie p: 1.58 #> Matérn range: 16.66 #> Spatial SD: 2.21 #> ML criterion at convergence: 2933.138 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # IID random slopes and intercepts (implicit) by year: fit <- sdmTMB(   density ~ (depth | fyear), #<   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") )  # Spatially varying coefficient of year: pcod_2011$year_scaled <- as.numeric(scale(pcod_2011$year)) fit <- sdmTMB(   density ~ year_scaled,   spatial_varying = ~ 0 + year_scaled, #<   data = pcod_2011, mesh = mesh, family = tweedie(), time = \"year\" ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ year_scaled #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)     2.86    0.33 #> year_scaled    -0.06    0.15 #>  #> Dispersion parameter: 14.79 #> Tweedie p: 1.56 #> Matérn range: 20.56 #> Spatial SD: 2.38 #> Spatially varying coefficient SD (year_scaled): 0.81 #> Spatiotemporal IID SD: 1.11 #> ML criterion at convergence: 3008.886 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Time-varying effects of depth and depth squared: fit <- sdmTMB(   density ~ 0 + as.factor(year),   time_varying = ~ 0 + depth_scaled + depth_scaled2, #<   data = pcod_2011, time = \"year\", mesh = mesh,   family = tweedie() ) print(fit) #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ 0 + as.factor(year) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #> Conditional model: #>                     coef.est coef.se #> as.factor(year)2011     3.73    0.30 #> as.factor(year)2013     3.64    0.28 #> as.factor(year)2015     4.00    0.29 #> as.factor(year)2017     3.31    0.32 #>  #> Time-varying parameters: #>                    coef.est coef.se #> depth_scaled-2011     -0.87    0.16 #> depth_scaled-2013     -0.81    0.13 #> depth_scaled-2015     -0.75    0.13 #> depth_scaled-2017     -1.11    0.23 #> depth_scaled2-2011    -1.92    0.29 #> depth_scaled2-2013    -0.92    0.14 #> depth_scaled2-2015    -1.59    0.22 #> depth_scaled2-2017    -2.20    0.35 #>  #> Dispersion parameter: 12.80 #> Tweedie p: 1.56 #> Matérn range: 0.01 #> Spatial SD: 2572.95 #> Spatiotemporal IID SD: 2087.95 #> ML criterion at convergence: 2911.371 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. #>  #> **Possible issues detected! Check output of sanity().** # Extract values: est <- as.list(fit$sd_report, \"Estimate\") se <- as.list(fit$sd_report, \"Std. Error\") est$b_rw_t[, , 1] #>            [,1]       [,2] #> [1,] -0.8738038 -1.9199722 #> [2,] -0.8115162 -0.9195934 #> [3,] -0.7514766 -1.5858307 #> [4,] -1.1064060 -2.1992575 se$b_rw_t[, , 1] #>           [,1]      [,2] #> [1,] 0.1619744 0.2944087 #> [2,] 0.1287059 0.1386946 #> [3,] 0.1346182 0.2197914 #> [4,] 0.2305927 0.3514650  # Linear break-point effect of depth: fit <- sdmTMB(   density ~ breakpt(depth_scaled), #<   data = pcod_2011,   mesh = mesh,   family = tweedie() ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ breakpt(depth_scaled) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #> Conditional model: #>                      coef.est coef.se #> (Intercept)              4.11    0.33 #> depth_scaled-slope       1.07    0.22 #> depth_scaled-breakpt    -1.30    0.25 #>  #> Dispersion parameter: 15.19 #> Tweedie p: 1.58 #> Matérn range: 23.57 #> Spatial SD: 1.92 #> ML criterion at convergence: 2997.241 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross validation with sdmTMB models — sdmTMB_cv","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"Performs k-fold leave-future-cross validation sdmTMB models. Returns sum log likelihoods held-data (log predictive density), can used compare models—higher values indicate better --sample prediction. default, creates folds randomly stratified time (set seed reproducibility), folds can manually assigned via fold_ids. See Ward Anderson (2025) References cross-validation vignette.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"","code":"sdmTMB_cv(   formula,   data,   mesh_args,   mesh = NULL,   time = NULL,   k_folds = 8,   fold_ids = NULL,   lfo = FALSE,   lfo_forecast = 1,   lfo_validations = 5,   parallel = TRUE,   use_initial_fit = FALSE,   save_models = TRUE,   future_globals = NULL,   ... )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"formula Model formula. data data frame. mesh_args Arguments make_mesh(). supplied, mesh reconstructed fold. mesh Output make_mesh(). supplied, mesh used folds. faster usually want. time name time column. Leave NULL spatial data. k_folds Number folds. fold_ids Optional vector containing user fold IDs. Can also single string, e.g. \"fold_id\" representing name variable data. Ignored lfo TRUE lfo Logical. Use leave-future-(LFO) cross validation? TRUE, data earlier time steps used predict future time steps. time argument must specified. See Details section . lfo_forecast lfo = TRUE, number time steps ahead forecast. example, lfo_forecast = 1 means fitting time steps 1 T validating T + 1. See Details section . lfo_validations lfo = TRUE, number times step LFO process (.e., number validation folds). Defaults 5. See Details section . parallel TRUE future::plan() supplied, run parallel. use_initial_fit Fit first fold use parameter values starting values subsequent folds? Can faster many folds. save_models Logical. TRUE (default), fitted model object fold stored output. FALSE, models saved, can substantially reduce memory usage large datasets many folds. FALSE, functions require access fitted models (e.g., tidy(), cv_to_waywiser()) work. future_globals character vector global variables used within arguments error returned future.apply find object. vector appended TRUE passed argument future.globals future.apply::future_lapply(). Useful global objects used specify arguments like priors, families, etc. ... arguments required run sdmTMB() model. weights argument supported combined internal fold-assignment mechanism (held-data assigned weight 0).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"list: data: Original data plus columns fold ID (cv_fold), CV predicted value (cv_predicted), CV log likelihood (cv_loglik), CV deviance residuals (cv_deviance_resid). models: list fitted models, one per fold. NULL save_models = FALSE. fold_loglik: Sum log likelihoods held-data per fold (log predictive density per fold). positive values indicate better --sample prediction. sum_loglik: Sum fold_loglik across folds (total log predictive density). Use compare models—positive values better. pdHess: Logical vector: Hessian positive definite fold? converged: Logical: folds converge (pdHess TRUE)? max_gradients: Maximum absolute gradient fold.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"Parallel processing Parallel processing can used setting future::plan(). example:   Leave-future-cross validation (LFOCV) example LFOCV 9 time steps, lfo_forecast = 1, lfo_validations = 2: Fit data time steps 1 7, predict validate step 8. Fit data time steps 1 8, predict validate step 9. example LFOCV 9 time steps, lfo_forecast = 2, lfo_validations = 3: Fit data time steps 1 5, predict validate step 7. Fit data time steps 1 6, predict validate step 8. Fit data time steps 1 7, predict validate step 9. Note time steps presented order data. example, pcod data example steps data points always one year lfo_forecast = 2 forecasts 2 time steps presented two years. See example .","code":"library(future) plan(multisession) # now use sdmTMB_cv() ..."},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"Ward, E.J., S.C. Anderson. 2025. Approximating spatial processes many knots degrades quality probabilistic predictions. bioRxiv 2025.11.14.688354. doi:10.1101/2025.11.14.688354 .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"","code":"mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 25)  # Set parallel processing first if desired with the future package. # See the Details section above.  m_cv <- sdmTMB_cv(   density ~ 0 + depth_scaled + depth_scaled2,   data = pcod, mesh = mesh, spatial = \"off\",   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  m_cv$fold_loglik #> [1] -4292.305 -4321.288 m_cv$sum_loglik #> [1] -8613.593  head(m_cv$data) #> # A tibble: 6 × 16 #>    year     X     Y depth density present   lat   lon depth_mean depth_sd #>   <int> <dbl> <dbl> <dbl>   <dbl>   <dbl> <dbl> <dbl>      <dbl>    <dbl> #> 1  2003  446. 5793.   201   113.        1  52.3 -130.       5.16    0.445 #> 2  2003  446. 5800.   212    41.7       1  52.3 -130.       5.16    0.445 #> 3  2003  449. 5802.   220     0         0  52.4 -130.       5.16    0.445 #> 4  2003  437. 5802.   197    15.7       1  52.4 -130.       5.16    0.445 #> 5  2003  421. 5771.   256     0         0  52.1 -130.       5.16    0.445 #> 6  2003  418. 5772.   293     0         0  52.1 -130.       5.16    0.445 #> # ℹ 6 more variables: depth_scaled <dbl>, depth_scaled2 <dbl>, cv_fold <int>, #> #   cv_predicted <dbl>, cv_deviance_resid <dbl>, cv_loglik <dbl> m_cv$models[[1]] #> Model fit by ML ['sdmTMB'] #> Formula: density ~ 0 + depth_scaled + depth_scaled2 #> Family: tweedie(link = 'log') #>   #> Conditional model: #>               coef.est coef.se #> depth_scaled     -1.83    0.15 #> depth_scaled2     2.00    0.21 #>  #> Dispersion parameter: 76.49 #> Tweedie p: 1.90 #> ML criterion at convergence: 4280.128 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. m_cv$max_gradients #> [1] 2.272052e-11 2.044996e-11   # \\donttest{ # Create mesh each fold: m_cv2 <- sdmTMB_cv(   density ~ 0 + depth_scaled + depth_scaled2,   data = pcod, mesh_args = list(xy_cols = c(\"X\", \"Y\"), cutoff = 20),   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  # Use fold_ids: m_cv3 <- sdmTMB_cv(   density ~ 0 + depth_scaled + depth_scaled2,   data = pcod, mesh = mesh,   family = tweedie(link = \"log\"),   fold_ids = rep(seq(1, 3), nrow(pcod))[seq(1, nrow(pcod))] ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  # LFOCV: m_lfocv <- sdmTMB_cv(   present ~ s(year, k = 4),   data = pcod,   lfo = TRUE,   lfo_forecast = 2,   lfo_validations = 3,   family = binomial(),   mesh = mesh,   spatial = \"off\", # fast example   spatiotemporal = \"off\", # fast example   time = \"year\" # must be specified ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  # See how the LFOCV folds were assigned: fold_table <- table(m_lfocv$data$cv_fold, m_lfocv$data$year) fold_table #>     #>     2013 2015 2017 #>   3  240    0    0 #>   4    0  238    0 #>   5    0    0  240 # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","title":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","text":"sdmTMB_simulate() uses TMB simulate new data given specified parameter values. simulate.sdmTMB(), hand, takes existing model fit simulates new observations optionally new random effects.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","text":"","code":"sdmTMB_simulate(   formula,   data,   mesh,   family = gaussian(link = \"identity\"),   time = NULL,   B = NULL,   range = NULL,   rho = NULL,   sigma_O = NULL,   sigma_E = NULL,   sigma_Z = NULL,   phi = NULL,   tweedie_p = NULL,   df = NULL,   threshold_coefs = NULL,   fixed_re = list(omega_s = NULL, epsilon_st = NULL, zeta_s = NULL),   previous_fit = NULL,   seed = sample.int(1e+06, 1),   time_varying = NULL,   time_varying_type = c(\"rw\", \"rw0\", \"ar1\"),   sigma_V = NULL,   rho_time = NULL,   ... )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","text":"formula one-sided formula describing fixed-effect structure. Random intercepts (yet) supported. Fixed effects match corresponding B argument vector coefficient values. data data frame containing predictors described formula time column time specified. mesh Output make_mesh(). family Family sdmTMB(). Delta families supported. Instead, simulate two component models separately combine. time time column name. B vector beta values (fixed-effect coefficient values). range Parameter controls decay spatial correlation. vector length 2, share_range set FALSE spatial spatiotemporal ranges unique. rho Spatiotemporal correlation years; -1 1. sigma_O SD spatial process (Omega). sigma_E SD spatiotemporal process (Epsilon). sigma_Z SD spatially varying coefficient field (Zeta). phi Observation error scale parameter (e.g., SD Gaussian). tweedie_p Tweedie p (power) parameter; 1 2. df Student-t degrees freedom. threshold_coefs optional vector threshold coefficient values formula includes breakpt() logistic(). breakpt(), slope cut values. logistic(), threshold function 50% maximum, threshold function 95% maximum, maximum. See model description vignette details. fixed_re list optional random effects fix specified (e.g., previously estimated) values. Values NULL result random effects simulated. previous_fit (Deprecated; please use simulate.sdmTMB()). optional previous sdmTMB() fit pull parameter values. -ruled non-NULL specified parameter arguments. seed Seed number. time_varying optional one-sided formula describing time-varying covariates passed sdmTMB() building time-varying random effect design matrix. time_varying_type Type temporal process applied time_varying. Must one 'rw', 'rw0', 'ar1'. sigma_V SD(s) time-varying process. Provide single value vector matching number time-varying coefficients. rho_time Autoregressive correlation(s) time-varying parameters time_varying_type = \"ar1\". Values must lie -1 1 may supplied single value vector length sigma_V. ... arguments pass sdmTMB().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_simulate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","text":"data frame : 1st column time variable (present). 2nd 3rd columns spatial coordinates. omega_s represents simulated spatial random effects (present). zeta_s represents simulated spatial varying covariate field (present). epsilon_st represents simulated spatiotemporal random effects (present). eta true value link space mu true value inverse link space. observed represents simulated process observation error. remaining columns fixed-effect model matrix.","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","text":"","code":"set.seed(123)    # make fake predictor(s) (a1) and sampling locations:   predictor_dat <- data.frame(     X = runif(300), Y = runif(300),     a1 = rnorm(300), year = rep(1:6, each = 50)   )   mesh <- make_mesh(predictor_dat, xy_cols = c(\"X\", \"Y\"), cutoff = 0.1)    sim_dat <- sdmTMB_simulate(     formula = ~ 1 + a1,     data = predictor_dat,     time = \"year\",     mesh = mesh,     family = gaussian(),     range = 0.5,     sigma_E = 0.1,     phi = 0.1,     sigma_O = 0.2,     seed = 42,     B = c(0.2, -0.4) # B0 = intercept, B1 = a1 slope   )   head(sim_dat) #>   year         X           Y     omega_s  epsilon_st         mu        eta #> 1    1 0.2875775 0.784575267 -0.02131861 -0.02779393  0.4369843  0.4369843 #> 2    1 0.7883051 0.009429905  0.28852319  0.09092583  0.8805246  0.8805246 #> 3    1 0.4089769 0.779065883  0.13541643 -0.08468148  0.6261504  0.6261504 #> 4    1 0.8830174 0.729390652  0.28597232 -0.01660011  0.8903775  0.8903775 #> 5    1 0.9404673 0.630131853  0.21070545  0.02005202  0.6056213  0.6056213 #> 6    1 0.0455565 0.480910830 -0.08071932 -0.11409909 -0.1272901 -0.1272901 #>     observed (Intercept)         a1 #> 1  0.4176273           1 -0.7152422 #> 2  0.8802910           1 -0.7526890 #> 3  0.6248675           1 -0.9385387 #> 4  0.9055722           1 -1.0525133 #> 5  0.6654724           1 -0.4371595 #> 6 -0.1399113           1  0.3311792    if (require(\"ggplot2\", quietly = TRUE)) {     ggplot(sim_dat, aes(X, Y, colour = observed)) +       geom_point() +       facet_wrap(~year) +       scale_color_gradient2()   }     # fit to the simulated data:   fit <- sdmTMB(observed ~ a1, data = sim_dat, mesh = mesh, time = \"year\")   fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: observed ~ a1 #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #> Conditional model: #>             coef.est coef.se #> (Intercept)     0.23    0.09 #> a1             -0.39    0.01 #>  #> Dispersion parameter: 0.09 #> Matérn range: 0.40 #> Spatial SD: 0.21 #> Spatiotemporal IID SD: 0.11 #> ML criterion at convergence: -162.527 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"approach described Yao et al. (2018) doi:10.1214/17-BA1091 . general method minimizes (maximizes) quantity across models. simple models normal error, may root mean squared error (RMSE), approaches include log score. adopt latter , log scores used generate stacking predictive distributions","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"","code":"sdmTMB_stacking(model_list, include_folds = NULL)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"model_list list models fit sdmTMB_cv() generate estimates predictive densities. want set seed value fitting model manually construct fold IDs across models. include_folds optional numeric vector specifying folds include calculations. example, 5 folds used k-fold cross validation, first 4 needed generate weights, include_folds = 1:4.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"vector model weights.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"Yao, Y., Vehtari, ., Simpson, D., Gelman, . 2018. Using Stacking Average Bayesian Predictive Distributions (Discussion). Bayesian Analysis 13(3): 917–1007. International Society Bayesian Analysis. doi:10.1214/17-BA1091","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"","code":"# \\donttest{ # Set parallel processing if desired. See 'Details' in ?sdmTMB_cv  # Depth as quadratic: set.seed(1) m_cv_1 <- sdmTMB_cv(   density ~ 0 + depth_scaled + depth_scaled2,   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing. # Depth as linear: set.seed(1) m_cv_2 <- sdmTMB_cv(   density ~ 0 + depth_scaled,   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  # Only an intercept: set.seed(1) m_cv_3 <- sdmTMB_cv(   density ~ 1,   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  models <- list(m_cv_1, m_cv_2, m_cv_3) weights <- sdmTMB_stacking(models) weights #> [1] 0.87857001 0.01750509 0.10392489 # }"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimization control options — sdmTMBcontrol","title":"Optimization control options — sdmTMBcontrol","text":"sdmTMB() stats::nlminb() control options.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization control options — sdmTMBcontrol","text":"","code":"sdmTMBcontrol(   eval.max = 2000L,   iter.max = 1000L,   normalize = FALSE,   nlminb_loops = 1L,   newton_loops = 1L,   getsd = TRUE,   quadratic_roots = FALSE,   start = NULL,   map = NULL,   lower = NULL,   upper = NULL,   censored_upper = NULL,   multiphase = TRUE,   profile = FALSE,   get_joint_precision = TRUE,   parallel = getOption(\"sdmTMB.cores\", 1L),   suppress_nlminb_warnings = TRUE,   collapse_spatial_variance = FALSE,   collapse_threshold = 0.01,   ... )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimization control options — sdmTMBcontrol","text":"eval.max Maximum number evaluations objective function allowed. iter.max Maximum number iterations allowed. normalize Logical: use TMB::normalize() normalize process likelihood using Laplace approximation? Can result substantial speed boost cases. used default FALSE prior May 2021. Currently working models fit REML random intercepts. nlminb_loops many times run stats::nlminb() optimization. Sometimes restarting optimizer previous best values aids convergence. maximum gradient still large, try increasing 2. newton_loops many Newton optimization steps try running stats::nlminb(). sometimes aids convergence reducing log-likelihood gradient respect fixed effects. calculates Hessian current MLE stats::optimHess() using finite-difference approach uses update fixed effect estimates. getsd Logical indicating whether call TMB::sdreport(). quadratic_roots Experimental feature internal use right now; may moved branch. Logical: quadratic roots calculated? Note: sdmTMB side, first two coefficients used generate quadratic parameters. means want generate quadratic profile depth, depth depth^2 part formula, need make sure listed first intercept included. example, formula = cpue ~ 0 + depth + depth2 + .factor(year). start named list specifying starting values parameters. can see necessary structure fitting model inspecting your_model$tmb_obj$env$parList(). Elements start specified replace default starting values. map named list factor NAs specifying parameter values fixed constant value. See documentation TMB::MakeADFun(). usually used start specify fixed value. lower optional named list lower bounds within optimization. Parameter vectors name (e.g., b_j ln_kappa cases) can specified numeric vector. E.g. lower = list(b_j = c(-5, -5)). Note stats::optimHess() implement lower upper bounds, must set newton_loops = 0 setting limits. upper optional named list upper bounds within optimization. censored_upper optional vector upper bounds sdmTMBcontrol(). Values NA indicate unbounded right-censored distribution, values greater observation indicate upper bound, values equal observation indicate censoring. multiphase Logical: estimate fixed random effects phases? Phases usually faster stable. profile Logical: population-level/fixed effects profiled likelihood? appended random effects vector without Laplace approximation. See TMB::MakeADFun(). can dramatically speed model fit many fixed effects experimental stage. get_joint_precision Logical. Passed getJointPrecision TMB::sdreport(). Must TRUE use simulation-based methods predict.sdmTMB() [get_index_sims()]. needed, setting FALSE reduce object size. parallel Argument currently ignored. parallel processing 3 cores, example, use TMB::openmp(n = 3, DLL = \"sdmTMB\"). careful, always faster cores definitely upper limit. suppress_nlminb_warnings Suppress uninformative warnings stats::nlminb() arising function evaluation NA, replaced Inf avoided estimation? collapse_spatial_variance Logical: spatial /spatiotemporal random fields automatically dropped estimated standard deviation effectively zero (.e., collapse_threshold)? helps prevent overfitting numerical instability data provide little evidence spatial spatiotemporal variation. .e., variance parameter estimated near boundary zero. enabled, model automatically refitted via update.sdmTMB() corresponding field(s) disabled. adds computational cost (single model refit collapsing occurs) can yield simpler, stable model reliable inference. Default FALSE backwards compatibility. collapse_threshold Numeric: standard deviation threshold random fields considered collapsing zero. used collapse_spatial_variance = TRUE. Values standard deviation scale (.e., square root variance). Default 0.01. ... Anything else. See 'Control parameters' section stats::nlminb().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimization control options — sdmTMBcontrol","text":"list control arguments","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimization control options — sdmTMBcontrol","text":"Usually used within sdmTMB(). example:","code":"sdmTMB(..., control = sdmTMBcontrol(newton_loops = 2))"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimization control options — sdmTMBcontrol","text":"","code":"sdmTMBcontrol() #> $eval.max #> [1] 2000 #>  #> $iter.max #> [1] 1000 #>  #> $normalize #> [1] FALSE #>  #> $nlminb_loops #> [1] 1 #>  #> $newton_loops #> [1] 1 #>  #> $getsd #> [1] TRUE #>  #> $profile #> [1] FALSE #>  #> $quadratic_roots #> [1] FALSE #>  #> $start #> NULL #>  #> $map #> NULL #>  #> $lower #> NULL #>  #> $upper #> NULL #>  #> $censored_upper #> NULL #>  #> $multiphase #> [1] TRUE #>  #> $parallel #> [1] 1 #>  #> $get_joint_precision #> [1] TRUE #>  #> $collapse_spatial_variance #> [1] FALSE #>  #> $collapse_threshold #> [1] 0.01 #>"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/set_delta_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Set delta model for ggeffects::ggpredict() — set_delta_model","title":"Set delta model for ggeffects::ggpredict() — set_delta_model","text":"Set delta model component predict ggeffects::ggpredict().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/set_delta_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set delta model for ggeffects::ggpredict() — set_delta_model","text":"","code":"set_delta_model(x, model = c(NA, 1, 2))"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/set_delta_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set delta model for ggeffects::ggpredict() — set_delta_model","text":"x sdmTMB() model fit delta family delta_gamma(). model delta/hurdle linear predictor predict/plot . NA combined prediction, 1 binomial part, 2 positive part.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/set_delta_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set delta model for ggeffects::ggpredict() — set_delta_model","text":"fitted model new attribute named delta_model_predict. suggest use set_delta_model() pipe (examples) attribute persist. Otherwise, predict.sdmTMB() choose model component default. can also remove attribute :","code":"attr(fit, \"delta_model_predict\") <- NULL"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/set_delta_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set delta model for ggeffects::ggpredict() — set_delta_model","text":"complete version examples :   run CRAN next version ggeffects available CRAN. now, can install GitHub version ggeffects. https://github.com/strengejacke/ggeffects.","code":"fit <- sdmTMB(density ~ poly(depth_scaled, 2), data = pcod_2011,   spatial = \"off\", family = delta_gamma())  # binomial part: set_delta_model(fit, model = 1) |>   ggeffects::ggpredict(\"depth_scaled [all]\")  # gamma part: set_delta_model(fit, model = 2) |>   ggeffects::ggpredict(\"depth_scaled [all]\")  # combined: set_delta_model(fit, model = NA) |>   ggeffects::ggpredict(\"depth_scaled [all]\")"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/set_delta_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set delta model for ggeffects::ggpredict() — set_delta_model","text":"","code":"fit <- sdmTMB(density ~ poly(depth_scaled, 2), data = pcod_2011,   spatial = \"off\", family = delta_gamma())  # binomial part: set_delta_model(fit, model = 1) #> Model fit by ML ['sdmTMB'] #> Formula: density ~ poly(depth_scaled, 2) #> Mesh: NULL (isotropic covariance) #> Data: pcod_2011 #> Family: delta_gamma(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #> Conditional model: #>                        coef.est coef.se #> (Intercept)               -0.48    0.09 #> poly(depth_scaled, 2)1   -23.06    3.15 #> poly(depth_scaled, 2)2   -48.79    4.45 #>  #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: Gamma(link = 'log')  #> Conditional model: #>                        coef.est coef.se #> (Intercept)                4.24    0.08 #> poly(depth_scaled, 2)1    -5.49    3.50 #> poly(depth_scaled, 2)2   -13.26    3.23 #>  #> Dispersion parameter: 0.64 #>  #> ML criterion at convergence: 2936.579 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # gamma part: set_delta_model(fit, model = 2) #> Model fit by ML ['sdmTMB'] #> Formula: density ~ poly(depth_scaled, 2) #> Mesh: NULL (isotropic covariance) #> Data: pcod_2011 #> Family: delta_gamma(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #> Conditional model: #>                        coef.est coef.se #> (Intercept)               -0.48    0.09 #> poly(depth_scaled, 2)1   -23.06    3.15 #> poly(depth_scaled, 2)2   -48.79    4.45 #>  #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: Gamma(link = 'log')  #> Conditional model: #>                        coef.est coef.se #> (Intercept)                4.24    0.08 #> poly(depth_scaled, 2)1    -5.49    3.50 #> poly(depth_scaled, 2)2   -13.26    3.23 #>  #> Dispersion parameter: 0.64 #>  #> ML criterion at convergence: 2936.579 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # combined: set_delta_model(fit, model = NA) #> Model fit by ML ['sdmTMB'] #> Formula: density ~ poly(depth_scaled, 2) #> Mesh: NULL (isotropic covariance) #> Data: pcod_2011 #> Family: delta_gamma(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #> Conditional model: #>                        coef.est coef.se #> (Intercept)               -0.48    0.09 #> poly(depth_scaled, 2)1   -23.06    3.15 #> poly(depth_scaled, 2)2   -48.79    4.45 #>  #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: Gamma(link = 'log')  #> Conditional model: #>                        coef.est coef.se #> (Intercept)                4.24    0.08 #> poly(depth_scaled, 2)1    -5.49    3.50 #> poly(depth_scaled, 2)2   -13.26    3.23 #>  #> Dispersion parameter: 0.64 #>  #> ML criterion at convergence: 2936.579 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sigma.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract residual standard deviation or dispersion parameter — sigma.sdmTMB","title":"Extract residual standard deviation or dispersion parameter — sigma.sdmTMB","text":"Extract residual standard deviation dispersion parameter","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sigma.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract residual standard deviation or dispersion parameter — sigma.sdmTMB","text":"","code":"# S3 method for class 'sdmTMB' sigma(object, ...)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/sigma.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract residual standard deviation or dispersion parameter — sigma.sdmTMB","text":"object fitted sdmTMB model object ... Currently ignored","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/simulate.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","title":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","text":"simulate.sdmTMB S3 method producing matrix simulations fitted model. similar lme4::simulate.merMod() glmmTMB::simulate.glmmTMB(). can used DHARMa package among uses.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/simulate.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","text":"","code":"# S3 method for class 'sdmTMB' simulate(   object,   nsim = 1L,   seed = sample.int(1e+06, 1L),   type = c(\"mle-eb\", \"mle-mvn\"),   model = c(NA, 1, 2),   newdata = NULL,   re_form = NULL,   mle_mvn_samples = c(\"single\", \"multiple\"),   mcmc_samples = NULL,   return_tmb_report = FALSE,   observation_error = TRUE,   size = NULL,   silent = FALSE,   ... )"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/simulate.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","text":"object sdmTMB model nsim Number response lists simulate. Defaults 1. seed Random number seed type parameters treated. \"mle-eb\": fixed effects maximum likelihood (MLE) estimates  random effects empirical Bayes (EB) estimates. \"mle-mvn\": fixed effects MLEs random effects taken single approximate sample. latter option suggested approach simulations used goodness fit testing (e.g., DHARMa package). model delta/hurdle model, model simulate ? NA = combined, 1 = first model, 2 = second mdoel. newdata Optional new data frame simulate. re_form NULL specify simulation conditional fitted random effects (simulates observation error). ~0 NA simulate new random affects (smoothers, internally random effects, simulated new). mle_mvn_samples Applies type = \"mle-mvn\". \"single\", take single MVN draw random effects. \"multiple\", take MVN draw random effects nsim. mcmc_samples optional matrix MCMC samples. See extract_mcmc() sdmTMBextra package. return_tmb_report Return TMB report simulate()? lets parse whatever elements want simulation. usually needed. observation_error Logical. Simulate observation error? size vector size (trials) case binomial family newdata specified. left NULL newdata, assumed vector 1s. silent Logical. Silent? ... Extra arguments passed predict.sdmTMB(). E.g., one may wish pass offset argument newdata supplied model offset.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/simulate.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","text":"Returns matrix; number columns nsim.","code":""},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/reference/simulate.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","text":"","code":"# start with some data simulated from scratch: set.seed(1) predictor_dat <- data.frame(X = runif(300), Y = runif(300), a1 = rnorm(300)) mesh <- make_mesh(predictor_dat, xy_cols = c(\"X\", \"Y\"), cutoff = 0.1) dat <- sdmTMB_simulate(   formula = ~ 1 + a1,   data = predictor_dat,   mesh = mesh,   family = poisson(),   range = 0.5,   sigma_O = 0.2,   seed = 42,   B = c(0.2, -0.4) # B0 = intercept, B1 = a1 slope ) fit <- sdmTMB(observed ~ 1 + a1, data = dat, family = poisson(), mesh = mesh)  # simulate from the model: s1 <- simulate(fit, nsim = 300) dim(s1) #> [1] 300 300  # test whether fitted models are consistent with the observed number of zeros: sum(s1 == 0)/length(s1) #> [1] 0.3297667 sum(dat$observed == 0) / length(dat$observed) #> [1] 0.3466667  # simulate with random effects sampled from their approximate posterior s2 <- simulate(fit, nsim = 1, params = \"mle-mvn\") # these may be useful in conjunction with DHARMa simulation-based residuals  # simulate with new random fields: s3 <- simulate(fit, nsim = 1, re_form = ~ 0)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/surveydata.html","id":null,"dir":"Reference","previous_headings":"","what":"Example fish survey data — pcod","title":"Example fish survey data — pcod","text":"Various fish survey datasets.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/surveydata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example fish survey data — pcod","text":"","code":"pcod  pcod_2011  pcod_mesh_2011  qcs_grid  dogfish  yelloweye  hbll_s_grid  wcvi_grid"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/surveydata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example fish survey data — pcod","text":"pcod: Trawl survey data Pacific Cod Queen Charlotte Sound. data frame. pcod_2011: version pcod years 2011 (smaller speed). data frame. pcod_mesh_2011: mesh pre-built pcod_2011 examples. list class sdmTMBmesh. qcs_grid 2x2km prediction grid Queen Charlotte Sound. data frame. dogfish: Trawl survey data Pacific Spiny Dogfish West Coast Vancouver Island. data frame. yelloweye: Survey data Yelloweye Rockfish Hard Bottom Longline Survey (South) West Coast Vancouver Island. hbll_s_grid: survey domain grid go yelloweye. data frame. wcvi_grid: survey domain grid go dogfish. data frame.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"Turn sdmTMB model output tidy data frame","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"","code":"# S3 method for class 'sdmTMB' tidy(   x,   effects = c(\"fixed\", \"ran_pars\", \"ran_vals\", \"ran_vcov\"),   model = 1,   conf.int = TRUE,   conf.level = 0.95,   exponentiate = FALSE,   silent = FALSE,   ... )  # S3 method for class 'sdmTMB_cv' tidy(x, ...)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"x Output sdmTMB(). effects character value. One \"fixed\" ('fixed' main-effect parameters), \"ran_pars\" (standard deviations, spatial range, random effect dispersion-related terms), \"ran_vals\" (individual random intercepts slopes, included; behaves like ranef()), \"ran_vcov\" (list variance covariance matrices random effects, model group). model model tidy delta model (1 2). model ignored effects \"ran_vals\" (returned single dataframe) conf.int Include confidence interval? conf.level Confidence level CI. exponentiate Whether exponentiate fixed-effect coefficient estimates confidence intervals. silent Omit messages? ... Extra arguments (used).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"data frame","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"Follows conventions broom broom.mixed packages. Currently, effects = \"ran_pars\" also includes dispersion-related terms (e.g., phi), actually associated random effects. Standard errors spatial variance terms fit log space (e.g., variance terms, range, parameters associated observation error) omitted avoid confusion. Confidence intervals still available.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"","code":"fit <- sdmTMB(density ~ poly(depth_scaled, 2, raw = TRUE),   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie() ) tidy(fit) #> # A tibble: 3 × 5 #>   term                               estimate std.error conf.low conf.high #>   <chr>                                 <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)                            3.65     0.281     3.10     4.20  #> 2 poly(depth_scaled, 2, raw = TRUE)1    -1.54     0.186    -1.90    -1.17  #> 3 poly(depth_scaled, 2, raw = TRUE)2    -1.11     0.101    -1.31    -0.913 tidy(fit, conf.int = TRUE) #> # A tibble: 3 × 5 #>   term                               estimate std.error conf.low conf.high #>   <chr>                                 <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)                            3.65     0.281     3.10     4.20  #> 2 poly(depth_scaled, 2, raw = TRUE)1    -1.54     0.186    -1.90    -1.17  #> 3 poly(depth_scaled, 2, raw = TRUE)2    -1.11     0.101    -1.31    -0.913 tidy(fit, \"ran_pars\", conf.int = TRUE) #> # A tibble: 4 × 5 #>   term      estimate std.error conf.low conf.high #>   <chr>        <dbl>     <dbl>    <dbl>     <dbl> #> 1 range        19.1    14.0       4.58      80.0  #> 2 phi          14.0     0.677    12.8       15.4  #> 3 sigma_O       2.14    0.941     0.906      5.07 #> 4 tweedie_p     1.58    0.0153    1.55       1.61  pcod_2011$fyear <- as.factor(pcod_2011$year) fit <- sdmTMB(density ~ poly(depth_scaled, 2, raw = TRUE) + (1 | fyear),   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie() ) tidy(fit, \"ran_vals\") #> # A tibble: 4 × 7 #>   group_name term        level_ids estimate std.error conf.low conf.high #>   <chr>      <chr>       <chr>        <dbl>     <dbl>    <dbl>     <dbl> #> 1 fyear      (Intercept) 2011        0.0163     0.187   -0.351    0.384  #> 2 fyear      (Intercept) 2013        0.177      0.188   -0.192    0.545  #> 3 fyear      (Intercept) 2015        0.232      0.189   -0.139    0.603  #> 4 fyear      (Intercept) 2017       -0.431      0.205   -0.833   -0.0287"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/update.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Update an sdmTMB model — update.sdmTMB","title":"Update an sdmTMB model — update.sdmTMB","text":"method updates sdmTMB model new arguments, automatically handling mesh object avoid environment issues loading models saved files.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/update.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update an sdmTMB model — update.sdmTMB","text":"","code":"# S3 method for class 'sdmTMB' update(object, formula., ..., evaluate = TRUE)"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/update.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update an sdmTMB model — update.sdmTMB","text":"object sdmTMB model object formula. Optional updated formula ... arguments update model call evaluate TRUE (default), updated call evaluated; FALSE, call returned unevaluated","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/update.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update an sdmTMB model — update.sdmTMB","text":"updated sdmTMB model object (evaluate = TRUE) unevaluated call (evaluate = FALSE)","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/update.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update an sdmTMB model — update.sdmTMB","text":"","code":"mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), cutoff = 20) fit <- sdmTMB(density ~ 1, data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\")) fit2 <- update(fit, family = delta_gamma())"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/visreg_delta.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot sdmTMB models with the visreg package — visreg_delta","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"sdmTMB models fit regular (non-delta) families can passed visreg::visreg() visreg::visreg2d() directly. Examples shown . Delta models can use helper functions visreg_delta() visreg2d_delta() described .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/visreg_delta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"","code":"visreg_delta(object, ..., model = c(1, 2))  visreg2d_delta(object, ..., model = c(1, 2))"},{"path":"https://sdmTMB.github.io/sdmTMB/reference/visreg_delta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"object Fit sdmTMB() ... arguments passed visreg::visreg() visreg::visreg2d() model 1st 2nd delta model","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/visreg_delta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"plot visreg package. Optionally, data plotted invisibly plot = FALSE. useful want make plot .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/visreg_delta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"Note residuals currently randomized quantile residuals, deviance residuals usual GLMs visreg.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/reference/visreg_delta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"","code":"if (require(\"ggplot2\", quietly = TRUE) &&   require(\"visreg\", quietly = TRUE)) {  # \\donttest{   fit <- sdmTMB(     density ~ s(depth_scaled),     data = pcod_2011,     spatial = \"off\",     family = tweedie()   )   visreg::visreg(fit, xvar = \"depth_scaled\")    visreg::visreg(fit, xvar = \"depth_scaled\", scale = \"response\")   v <- visreg::visreg(fit, xvar = \"depth_scaled\")   head(v$fit)   # now use ggplot2 etc. if desired    # Delta model example:   fit_dg <- sdmTMB(     density ~ s(depth_scaled, year, k = 8),     data = pcod_2011, mesh = pcod_mesh_2011,     spatial = \"off\",     family = delta_gamma()   )   visreg_delta(fit_dg, xvar = \"depth_scaled\", model = 1, gg = TRUE)   visreg_delta(fit_dg, xvar = \"depth_scaled\", model = 2, gg = TRUE)   visreg_delta(fit_dg,     xvar = \"depth_scaled\", model = 1,     scale = \"response\", gg = TRUE   )   visreg_delta(fit_dg,     xvar = \"depth_scaled\", model = 2,     scale = \"response\"   )   visreg_delta(fit_dg,     xvar = \"depth_scaled\", model = 2,     scale = \"response\", gg = TRUE, rug = FALSE   )   visreg2d_delta(fit_dg,     xvar = \"depth_scaled\", yvar = \"year\",     model = 2, scale = \"response\"   )   visreg2d_delta(fit_dg,     xvar = \"depth_scaled\", yvar = \"year\",     model = 1, scale = \"response\", plot.type = \"persp\"   )   visreg2d_delta(fit_dg,     xvar = \"depth_scaled\", yvar = \"year\",     model = 2, scale = \"response\", plot.type = \"gg\"   )   # } }    #> These are residuals for delta model component 1. Use the `model` argument to #> select the other component. #> These are residuals for delta model component 2. Use the `model` argument to #> select the other component. #> These are residuals for delta model component 1. Use the `model` argument to #> select the other component. #> These are residuals for delta model component 2. Use the `model` argument to #> select the other component.  #> These are residuals for delta model component 2. Use the `model` argument to #> select the other component."},{"path":[]},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"new-features-0-8-0","dir":"Changelog","previous_headings":"","what":"New features","title":"sdmTMB 0.8.0","text":"sdmTMB_cv() now supports weights argument. User-supplied weights combined internal fold-assignment mechanism (held-data assigned weight 0). Weights must positive (> 0). #486 Add experimental collapse_spatial_variance option sdmTMBcontrol() automatically detect turn spatial /spatiotemporal random fields SD parameters estimated small (threshold). enabled, model automatically refit appropriate fields turned SD parameters fall collapse_threshold (default 0.01). can help avoid boundary issues improve model stability random fields needed. Set FALSE default. #263 Add new experimental function get_range_edge() calculate range edges density-weighted quantiles along spatial axis (e.g., latitude, coastal distance). Range edges calculated positions cumulative density equals specified quantiles. Uses linear interpolation accurate quantile estimation simulation joint precision matrix uncertainty quantification. Implements similar approach VAST range edge calculations following Fredston et al. (2021) https://doi.org/10.1111/gcb.15614. See new range edge vignette https://sdmTMB.github.io/sdmTMB/articles/ Student-t degrees freedom parameter now estimated default student(). Previously fixed 3. fix specific value, set df numeric value (e.g., student(df = 3)). estimate (new default), set df = NULL omit argument. parameter constrained > 1. function now prints informative message df parameter behavior. Add deviance residuals left-data cross validation output. can used calculate deviance explained left-data. See cv_deviance_resid column data element output sdmTMB_cv(). Add save_models argument sdmTMB_cv() (defaults TRUE). Setting save_models = FALSE prevents storing fitted model objects fold, can substantially reduce memory usage large datasets many folds. FALSE, functions requiring model access (tidy(), cv_to_waywiser()) error informative messages. Essential CV metrics (predictions, log likelihoods, deviance residuals, convergence info) remain available. Extend sdmTMB_simulate() support time-varying effects vector sigma_V inputs AR1 correlation (rho_time). #447 Add new function cv_to_waywiser() convert cross-validation results sf format use waywiser package. enables multi-scale spatial assessment model predictions. #193 Add vignette demonstrating fit zero-one-inflated beta (ZOIB) models fitting three separate model components combining predictions. #440 #441 Add argument fix probability extreme events *_mix() familes. Note internal parameter name also changed p_mix p_extreme logit_p_mix logit_p_extreme. #318 #474 Add beta-binomial family (betabinomial()) modeling overdispersed binomial data. Supports logit cloglog links, includes proper residuals support. Add new function get_weighted_average() calculate biomass-weighted averages user-supplied vectors (e.g., depth, temperature). function follows pattern get_cog() allows users specify variable weighted averaging. Supports bias correction area weighting. Add vignette age (length) composition standardization. help add new experimental function make_category_svc(). Add emmeans support delta/hurdle models. Use model = 1 binomial component model = 2 positive component calling emmeans(). Example: emmeans(fit, ~ predictor, model = 2). #247 #249","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"minor-improvements-and-fixes-0-8-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and fixes","title":"sdmTMB 0.8.0","text":"Fix barrier model implementation. SPDE input matrices barrier model INLA INLAspacetime changed. sdmTMB now appropriately uses new matrices unit tests sdmTMBextra catch change future. #457 Fix Student-t deviance residuals, incorrectly returning NaNs. Fix sign() utility function avoid NaN x = 0. Now returns standard mathematical sign function behavior: sign(0) = 0. Fix bug sdmTMB_cv() automatic fold generation result unbalanced folds duplicate missing fold IDs. bug severe large k_folds values (e.g., leave-one-cross-validation k_folds = nrow(data)), cause errors folds data. User-supplied fold_ids affected. Add check newdata filtered prediction passing get_*() function. Fix tidy() include model column delta models. non-delta models, model column longer included output effects = \"ran_pars\" effects = \"ran_vals\", making output cleaner consistent. Update package logo. Add residuals truncated negative binomial families. #481 Thanks @Joseph-Barss Fix issue residuals delta models consistently using get_par(), another issue specifically delta truncated negative binomial models replacing NaN NA. #484 Fix tidy() effects = \"ran_pars\" report min/max anisotropic ranges (e.g., range_min, range_max) models fit anisotropy = TRUE, matching values shown print_anisotropy(). Standard errors confidence intervals set NA since uncertainty range parameter H matrix easily propagated. Fix issue ggeffects multiple smoothers + offsets. #450 Improve t2() printing appearance tidy.sdmTMB(). #415 #472 Fix emmeans support models smoothers (s() terms). Previously, emmeans fail “Non-conformable elements reference grid” smoothers included model formula.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-074","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.7.4","title":"sdmTMB 0.7.4","text":"CRAN release: 2025-07-29","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"minor-improvements-and-fixes-0-7-4","dir":"Changelog","previous_headings":"","what":"Minor improvements and fixes","title":"sdmTMB 0.7.4","text":"Let simulate.sdmTMB() work binomial GLMs size specified via weights newdata supplied. #465 Fix issue fold logic LFO (leave-future-) cross validation lfo_forecast > 1. #454 Thanks @Joseph-Barss. Add update.sdmTMB() mesh argument doesn’t specified model loaded fresh session. #461 Change default get_index() etc. bias_correct = TRUE. recommended setting final inference speed improvements within TMB made viable include bias correction default. #456 retain Newton update parameters improve objective function. #455 run Newton updates maximum absolute gradient >= 1e-9 save time. #455 Suppress nlminb() warnings default, can usually ignored user may confusing. can controlled via sdmTMB(..., control = sdmTMBcontrol(suppress_nlminb_warnings = FALSE)). option now mirrors tinyVAST. Round time-varying AR(1) rho 2 decimals model printing/summary.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-072","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.7.2","title":"sdmTMB 0.7.2","text":"CRAN release: 2025-06-19","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"new-features-0-7-2","dir":"Changelog","previous_headings":"","what":"New features","title":"sdmTMB 0.7.2","text":"Add deviance residuals (residuals(fit, type = \"deviance\")) deviance.sdmTMB() method (deviance(fit)). Proportion deviance explained can calculated 1 - deviance(fit) / deviance(fit_null) fit_null null model, e.g., fit formula = ~ 1 turning random fields desired (e.g., spatial = \"\", spatiotemporal = \"\"). Add observation_error argument simulate.sdmTMB() allow turning observation error simulation. intended use-case simulating random effects adding observation error. #431","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"minor-improvements-and-fixes-0-7-2","dir":"Changelog","previous_headings":"","what":"Minor improvements and fixes","title":"sdmTMB 0.7.2","text":"Change default dharma_residuals() test_uniformity = FALSE. Based simulation testing, generally recommend using p-values reject models. Fix bug introduced version 0.7.0 printing 2nd linear predictor smoother fixed effects (bs) accidentally copy 1st linear predictor smoother fixed effects. Fix bug simulation time-varying AR(1) using project() function. Thanks . Allyn pointing bug. Fix reporting converged models sdmTMB_cv(). recent change resulted reporting 1 model converged models converged. Remove warning old default residuals type. Fix project() simulate.sdmTMB(..., newdata = ...) random intercepts/slopes present. #431 Remove extra TMB data slots project() simulate.sdmTMB(..., newdata = ...) save memory. #431","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-070","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.7.0","title":"sdmTMB 0.7.0","text":"CRAN release: 2025-04-01","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"new-features-0-7-0","dir":"Changelog","previous_headings":"","what":"New features","title":"sdmTMB 0.7.0","text":"Add option random slopes, random intercepts passed lme4 style formulas, density ~ (1 | fyear) density ~ (depth | fyear), Matches output lme4 glmmTMB, summarizes output tidy(). Add project() experimental function. Add get_eao() calculate effective area occupied. Allow predicting new data t2() smoothers. #413 Add priors breakpt() logistic() parameters. #403 Add priors time-varying SD parameters (sigma_V). Add cAIC() calculating conditional AIC. Theory based https://arxiv.org/abs/2411.14185; also see https://doi.org/10.1002/ecy.4327. J.T. Thorson wrote function code. EDF (effective degrees freedom) ultimately split (e.g., split smoothers) added summary.sdmTMB(). #383 #387 Add EDF (effective degrees freedom) printing smoothers print.sdmTMB() summary.sdmTMB(). Set argument edf = TRUE. E.g. print(fit, edf = TRUE). #383 #387 experimental function get_index_split(), takes care splitting prediction grid time, undoing prediction area-integration index calculations chunk save memory. Add newdata argument simulate.sdmTMB(). enables simulating new data frame similar one predict new data. Add mle_mvn_samples argument simulate.sdmTMB(). Defaults “single”. “multiple”, sample random effects taken simulation iteration. Allow specifying lower upper limits. #394 sdmTMB_cv() gains tidy() print() method output. #319 simulate.sdmTMB() method now return_tmb_report argument.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"new-vignettesarticles-0-7-0","dir":"Changelog","previous_headings":"","what":"New vignettes/articles","title":"sdmTMB 0.7.0","text":"Add forecasting presence-article vignettes. See https://sdmTMB.github.io/sdmTMB/articles/ Add vignette multispecies models sdmTMB (case one wants additional spatial spatiotemporal fields group). See https://sdmTMB.github.io/sdmTMB/articles/","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"minor-improvements-and-fixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and fixes","title":"sdmTMB 0.7.0","text":"Add useful error memory error occurs index calculation. Fix bug check make_mesh() around coordinates look overly large. #427 Re-enable bias correction get_cog() (get center gravity). Add check Inf/-Inf values fitting. #408 Add linear component smoothers tidy(). #90 Add time varying AR(1) correlation tidy() print(). #374 Warn parameter limits set newton_loops > 0. #394 Fix bug est column predicting new data Poisson-link delta models type = \"link\" re_form = NA. #389 Fix bug s95 parameter reporting tidy() method. s95 present logistic threshold models. model fine s95 parameter supposed reported tidy() combination two parameters. also affected output print()/summary(). Add progress bar simulate.sdmTMB(). #346 Add AUC TSS examples cross validation vignette. #268 Add model (linear predictor number) argument coef() method. Also, write documentation ?coef.sdmTMB. #351 Add helpful error message coordinates make_mesh() NA. #365 Add informative message fitting offset predicting offset argument left NULL newdata. #372 Fix passing offset argument sdmTMB_cv(). omitted prediction (.e., set 0). #372 Fig bug exponentiate argument tidy(). Set conf.int = TRUE default. #353 Fix bug prediction delta_truncated_nbinom1() delta_truncated_nbinom2() families. positive component needs transformed represent mean untruncated distribution first multiplying probability non-zero. Thanks @tom-peatman #350 Add option area passed name column data frame used area weighting. Used get_index(), get_cog(), get_eao(), etc.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-060","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.6.0","title":"sdmTMB 0.6.0","text":"CRAN release: 2024-05-29 Pass several arguments DHARMa::plotQQunif(). Add silent option simulate.sdmTMB(). Setting FALSE allows monitoring simulations larger models. Fix bug est_non_rf1 est_non_rf2 columns following conditions true: predicting new data using delta model including IID random intercepts time-varying coefficients See #342. Thanks @tom-peatman issue report. Fix delta-gamma binomial link printing type = 'poisson-link' #340 Add suggestion use optimized BLAS library README. Add warning ’s detected problems reloading (e.g., readRDS()) fitted model. Simultaneously revert approach reloaded models reattached. Move log_ratio_mix parameter 2nd phase starting value -1 instead 0 improve convergence. Fix bugs nbinom1() nbinom2_mix() simulation. Allow profile argument control list take character vector parameters. move parameters outer optimization problem inner problem (omits Laplace approximation). See documentation TMB. can considerably speed fitting models many fixed effects. Add theoretical quantile residuals generalized gamma distribution. Thanks J.C. Dunic. #333 Add \"poisson-link\" option delta-mixture lognormal. Fix bug simulation Poisson-link delta models. Simplify internal treatment extra time slices (extra_time). #329 much less bug prone also fixes recently introduced bug. #335 can slightly affect model results compared previous approach extra time used along smoothers since ‘fake’ extra data previously used included mgcv determined knot locations smoothers.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-050","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.5.0","title":"sdmTMB 0.5.0","text":"CRAN release: 2024-04-03 Overhaul residuals vignette (‘article’) https://sdmTMB.github.io/sdmTMB/articles/residual-checking.html including brief intros randomized quantile residuals, simulation-based residuals, ‘one-sample’ residuals, uniform vs. Gaussian residuals. Add check prediction coordinates appear outside fitted coordinates. #285 Fix memory issue Tweedie family large datasets. #302 Add experimental option return standard normal residuals dharma_residuals(). Make simulate.sdmTMB() include extra_time elements. Improved re-initialization saved fitted model objects new sessions. Fix important bug simulate.sdmTMB() method delta families positive linear predictor getting simulated observations present fitted data. Add new \"mle-mvn\" type residuals.sdmTMB() make default. fast option evaluating goodness fit better previous default. See details section ?residuals.sdmTMB details. previous default now called \"mvn-eb\" recommended. Bring dharma_residuals() back sdmTMBextra sdmTMB. Add new option type argument (\"mle-mvn\") make simulation residuals consistent expected distribution. See new documentation ?residuals.sdmTMB. examples ?dharma_residuals illustrate suggested use. Fix bug sanity() gradient checks missing abs() large negative gradients weren’t getting caught. #324 Return offset vector fitted object element. Ensure extra time rows data data element fitted object include extra time slices. Add experimental residuals option “mle-mvn” single approximate posterior sample random effects drawn combined MLE fixed effects produce residuals. may become default option. Add generalized gamma distribution (thanks J.T. Thorson additional work J.C. Dunic.) See gengamma(). distribution still testing phase recommended applied use yet. #286 Detect possible issue factor(time) formula column name used time extra_time specified. #320 Improve sanity() check output NA fixed effect standard errors. Set intern = FALSE within index bias correction, seems considerably faster testing models.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-043","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.4.3","title":"sdmTMB 0.4.3","text":"CRAN release: 2024-02-29 Fix bug likely introduced July 2023 caused issues extra_time specified. important bug models fit extra_time date (using GitHub version) v0.4.2.9004 (2024-02-24) checked current version sdmTMB (v0.4.2.9005 greater). CRAN, affected v0.4.0 (2023-10-20) v0.4.2. Details: essence bug extra_time works padding data fake row data every extra time element (using first row data template). supposed omitted likelihood impact model fitting beyond spacing time-series processes appropriately setting internal structures forecasting. Unfortunately, bug introduced caused fake data (1 per extra time element) included likelihood. Issue error time column NAs. #298 #299 Fix bug get_cog(..., format = \"wide\") time column hardcoded \"year\" accident. Poisson-link delta models now use type argument delta_gamma() delta_lognormal(). delta_poisson_link_gamma() delta_poisson_link_lognormal() deprecated. #290 Delta families can now pass links different default \"logit\" \"log\". #290","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-042","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.4.2","title":"sdmTMB 0.4.2","text":"CRAN release: 2024-01-18 Force rebuild CRAN binaries fix issue breaking Matrix ABI change causing NaN gradient errors. #288 #287 Fix crash sdmTMB(..., do_index = TRUE) extra_time supplied along predict_args = list(newdata = ...) lacked extra_time elements. Allow get_index() work missing time elements. Add ability pass custom randomized quantile function qres_func residuals.sdmTMB(). Add check factor random intercept columns newdata avoid crash. #278 #280 Improve warnings/errors around use do_index = TRUE get_index() newdata = NULL. #276 Fix prediction offset newdata NULL offset specified. #274 Fix prediction failure offset nsim provided model includes extra_time. #273","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-041","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.4.1","title":"sdmTMB 0.4.1","text":"CRAN release: 2023-11-03 Fix memory issues detected CRAN ‘Additional issues’ clang-UBSAN, valgrind. Fix bug predicting new data specified offset extra_time. #270 Add warning around non-factor handling spatial_varying formula. #269 Add experimental set_delta_model() plotting delta models ggeffects::ggpredict() (GitHub version next CRAN version).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-040","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.4.0","title":"sdmTMB 0.4.0","text":"CRAN release: 2023-10-20 Move add_barrier_mesh() sdmTMBextra avoid final INLA dependency. https://github.com/sdmTMB/sdmTMBextra Switch using new fmesher package mesh/SPDE calculations. INLA longer dependency. Switch diagonal.penalty = FALSE mgcv::smoothCon(). changes scale linear component smoother, result model. https://github.com/glmmTMB/glmmTMB/issues/928#issuecomment-1642862066 Implement cross validation delta models #239 Remove ELPD cross validation output. Use sum_loglik instead. #235 Turn Newton optimization default. #182 print() now checks sanity() issues warning may issues. #176 Poisson-link delta models censored likelihood distributions made considerably robust. #186 Standard errors now available SD parameters etc. tidy() #240 Fix bug print()/tidy() delta-model positive model component sigma_E. recently introduce bug causing sigma_E 2nd model reported 1st model component sigma_E. Add new anisotropy plotting function. Add anisotropic range printing. #149 @jdunic","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-030","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.3.0","title":"sdmTMB 0.3.0","text":"CRAN release: 2023-01-28 Create sdmTMBextra package remove rstan/tmbstan helpers, causing memory sanitizer errors CRAN. https://github.com/sdmTMB/sdmTMBextra following functions affected: predict.sdmTMB() now takes mcmc_samples, output sdmTMBextra::extract_mcmc(). simulate.sdmTMB() now takes mcmc_samples, output sdmTMBextra::extract_mcmc(). residuals.sdmTMB() now takes mcmc_samples, output sdmTMBextra::predict_mle_mcmc(). affects residuals(..., type = \"mle-mcmc\"). Move dharma_residuals() sdmTMBextra reduce heavy dependencies. See examples Bayesian residuals vignettes help files functions within sdmTMBextra.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-022","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.2.2","title":"sdmTMB 0.2.2","text":"Various fixes pass CRAN checks. #158 Fix memory issue highlighted Additional issues CRAN checks. #158 ‘offset’ argument can now character value indicating column name. preferred way using offset parallel cross validation. #165 Fix parallel cross validation using offset vector. #165 Add leave-future-cross validation functionality. #156 Example data qcs_grid longer replicated year save package space. #158 Add message tidy(fit, \"ran_pars\") SEs NA. Add anisotropy print() #157 Fix predict(..., type = \"response\", se_fit = TRUE), involves issuing warning sticking link space. #140","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-021","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.2.1","title":"sdmTMB 0.2.1","text":"CRAN release: 2023-01-10 Fixes resubmission CRAN.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-020","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.2.0","title":"sdmTMB 0.2.0","text":"Initial submission CRAN.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-014","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.1.4","title":"sdmTMB 0.1.4","text":"Relax range parameter sanity() check 1x 1.5x greatest distance data. Add Pearson residuals several families. residuals(fit, type = \"pearson\") Useful checking overdispersion N > 1 binomial Poisson families, among uses. See overdisp_fun() function : https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#testing--overdispersioncomputing-overdispersion-factor Fix bug using residuals() simulate() binomial families specified via cbind() weights = N. binomial sample size wasn’t passed typically resulting Inf/-Inf. Add mixture families: gamma_mix(), lognormal_mix() associated delta/hurdle families: delta_gamma_mix(), delta_lognormal_mix(). families feature mixture two distributions different means shared variance parameters. Add delta_beta() family.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-013","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.1.3","title":"sdmTMB 0.1.3","text":"Tweak sanity() checking standard error size. Export previously experimental plot_anisotropy() function. old function now plot_anisotropy2(). Allow passing offset data predict.sdmTMB() via offset argument.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-012","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.1.2","title":"sdmTMB 0.1.2","text":"Switch effects = 'ran_vals' random intercept values tidy.sdmTMB() match broom.mixed package. Make tidy.sdmTMB() return tibble tibble package installed. Note affect old code since drop = FALSE default tibbles drop = TRUE default data frames (.e., tibbles always return data frame subsetted). Fix longstanding issue predicting newdata mgcv’s t2(). Previously disabled issues. now works expected. Add knots argument sdmTMB(), passed mgcv. common use specify end points cyclical spline (e.g., s(x, bs = 'cc', k = 4), knots = list(x = c(1, 3, 5, 7))) data don’t extend fully boundaries match .","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-011","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.1.1","title":"sdmTMB 0.1.1","text":"Preparing release CRAN. Add time-varying AR1 option (originally always random walk). See time_varying_type argument ?sdmTMB. Allow prediction newdata missing time elements. #130 Add check offset() (work sdmTMB, use offset argument instead). #131 Add check random slopes (sdmTMB currently random intercepts, although slopes can vary spatially). #131","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-010","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.1.0","title":"sdmTMB 0.1.0","text":"ADREPORT several parameters natural space. https://github.com/sdmTMB/sdmTMB/discussions/113 Improve robustness model print() esoteric mgcv smoothers. Let sims_var work multiple spatially varying slopes (zeta_s); return output named list coefficients. #107 Add threshold_coefs sdmTMB_simulate(). Don’t make fake mesh non-spatial model (faster).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00269001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.26.9001","title":"sdmTMB 0.0.26.9001","text":"Add vignettes visreg, ggeffects, delta families (thanks J. Indivero!) #83 #87 #89 Forecasting presence-vignettes merged soon. Add support emmeans package. See ?emmeans.sdmTMB examples. Add support effects package. ggeffects::ggeffect() function can used make fast marginal effects plots. ggeffects::ggpredict() works custom fork ggeffects. pull request made shortly. #101 Add vcov(), fixef(), df.residual(), formula(), terms(), model.frame() methods. Add support \"cloglog\" link. Code adapted glmmTMB robust likelihood implementation. delta models, default share anisotropy parameters VAST. Separate anisotropy (old behavior) can estimated control = sdmTMBcontrol(map = list(ln_H_input = factor(c(1, 2, 3, 4)))) Add experimental do_index, predict_args, index_args sdmTMB(). can used perform prediction index calculation time fitting. large datasets meshes can save time compared fitting, predicting, index calculation 3 separate steps since TMB AD object doesn’t rebuilt. somewhat slow initial fitting. Remove max_gradient bad_eig get_index() output. Use unique locations prediction huge speedups large newdata gridded data. Fix bug rare cases get_index() return gibberish small values. Add bayesian argument, TRUE adds Jacobian adjustments non-linear transformed parameters. TRUE model passed tmbstan, FALSE otherwise. #95 Add experimental -yet-exported sdmTMB:::plot_anisotropy2(). Add many anisotropy, delta model, index calculation unit tests.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00249001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.24.9001","title":"sdmTMB 0.0.24.9001","text":"Enable random walk random field TMB simulation sdmTMB_simulate(). Add check irregular time AR1 random walk processes. Fix bugs introduced delta model code (offsets extra_time threshold model prediction). Fix bug sanity() message small random field SDs.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00249000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.24.9000","title":"sdmTMB 0.0.24.9000","text":"Add support ‘delta’ (‘hurdle’) models. See examples documentation ?sdmTMB. resulted substantial restructuring internal model code. default model components (e.g., binomial & Gamma) share formula, spatial, spatiotemporal structure, can separated supplying argument values lists first element corresponds first model second element corresponds second model (limitations described ?sdmTMB documentation ‘Details’). Add support multiple spatially varying coefficients (used limited single variable). Add compatibility ‘visreg’ package visualizing conditional effects parameters. See ?visreg_delta examples. Add MCMC residual type residuals.sdmTMB(). ‘better’ residuals slower calculate. See documentation ‘Details’ ?residuals.sdmTMB. Make offset argument sdmTMB(). Using reserved word offset formula now deprecated. Add sanity() function perform basic sanity checks model fits. Make sdmTMB() model object compatible update() method. Remove several deprecated arguments. Overhaul examples ?sdmTMB. Use faster “low-rank sparse hessian bias-correction” TMB bias correction. Add parallel processing support. See parallel argument sdmTMBcontrol. default, grabs value sdmTMB.cores option. E.g. options(sdmTMB.cores = 4). currently enabled Mac/Linux. Using many cores can much slower 1 core. Use ‘cli’ package cli_abort()/cli_warn()/cli_inform() stop()/warning()/message(). Add many unit tests.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00239000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.23.9000","title":"sdmTMB 0.0.23.9000","text":"package version number used internal testing ‘delta’ branch several people.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00229001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.22.9001","title":"sdmTMB 0.0.22.9001","text":"Switch TMBad library ~3-fold speedup(!)","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00229000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.22.9000","title":"sdmTMB 0.0.22.9000","text":"Fix bug predictions poly(..., raw = FALSE) newdata. #77","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00219009","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.21.9009","title":"sdmTMB 0.0.21.9009","text":"Add experimental sdmTMB_stacking() ensemble model stacking weights. Add fake mesh random fields . #59 Make predict(..., newdata = NULL) also use last.par.best instead last.par match newdata = df. Fix bug MVN fixed-effect prior indexing sims n_sims arguments deprecated standardized nsim match simulate() S3 method. Bias correction get_index() get_cog() now selective just applied necessary derived parameters. INLA projection matrix ‘’ now shared across spatial spatiotemporal fields. Add add_utm_columns() ease adding UTM columns.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00209001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.20.9001","title":"sdmTMB 0.0.20.9001","text":"Add dharma_residuals(). Fix bug simulate.sdmTMB() residuals.sdmTMB() binomial family.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00209000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.20.9000","title":"sdmTMB 0.0.20.9000","text":"Smoothers now appear print() output. format roughly match brms. main-effect component (e.g., sdepth s(depth)) represents linear component random effect (e.g., sds(depth)) component output corresponds standard deviation penalized weights. Add censored_poisson(link = 'log') family; implemented @joenomiddlename fields sdmTMB() now deprecated replaced spatiotemporal. include_spatial sdmTMB() now deprecated replaced spatial. spatial_only sdmTMB() now deprecated replaced spatiotemporal. E.g. spatial_only = TRUE now spatiotemporal = '' leaving time = NULL. spde sdmTMB() now deprecated replaced mesh. sdmTMB_simulate() new likely replace sdmTMB_sim() eventually. sdmTMB_simulate() set take formula data frame easier use want different spatial observations (covariates) time slice. can also take fitted model modify parts simulate. Finally, function uses TMB simulation much faster flexible can simulate (e.g., anisotropy) previous version. spatial_trend now spatial_varying accepts one-sided formula single predictor coefficient varying space random field. Note may want include fixed effect variable improve interpretability. (scaled) time column used, represent local-time-trend model . Tweedie power (p) parameter now print() tidy() output. thetaf now tweedie_p sdmTMB_sim().","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00199003","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.19.9003","title":"sdmTMB 0.0.19.9003","text":"Fix bug affecting prediction se_fit = TRUE breakpoint models.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00199002","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.19.9002","title":"sdmTMB 0.0.19.9002","text":"Simulation parameter covariance matrix works random effects turned . #57","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00199000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.19.9000","title":"sdmTMB 0.0.19.9000","text":"Smoothers s() now penalized smoothers: determine degree wiggliness (mgcv) longer necessary choose appropriate k value priori. Models fit previous versions sdmTMB s(x, k = ...) match models specified way version >= 0.0.19 since basis functions now penalized. various mgcv::s() options supported t2() (ti() te()) supported.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00189001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.18.9001","title":"sdmTMB 0.0.18.9001","text":"Add ELPD (expected log predictive density) sdmTMB_cv() https://arxiv.org/abs/1507.04544 Fix bug evaluating ... sdmTMB_cv() called within function. #54","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00189000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.18.9000","title":"sdmTMB 0.0.18.9000","text":"Fix minor error PC Matern prior","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00179000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.17.9000","title":"sdmTMB 0.0.17.9000","text":"Add random walk option: fields = \"RW\". Depreciate ar1_fields argument. See new fields argument `sdmTMB(). Many packages moved ‘Imports’ ‘Suggests’","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00169000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.16.9000","title":"sdmTMB 0.0.16.9000","text":"Lower default nlminb() eval.max iter.max 1000 2000. Added profile option sdmTMBcontrol(). can dramatically improve model fitting speed many fixed effects. Note result likely slightly different TRUE vs. FALSE. Added simulation MVN precision matrix predict.sdmTMB(). See sims argument. Added gather_sims() spread_sims() extract parameter simulations joint precision matrix format matches tidybayes package. Added get_index_sims() population index calculated MVN simulation draws. Added extract_mcmc() extract MCMC samples model passed tmbstan. Added ability predict model fitted tmbstan. See tmbstan_model argument predict.sdmTMB(). Allowed separate random field Matern range parameters spatial spatiotemporal fields. E.g. sdmTMB(shared_range = FALSE) Bounded AR1 rho parameter -0.999 0.999 improve convergence; -1 1. Please post issue creates problems model. Added map, start, lower, upper options control model fitting. See sdmTMBcontrol(). Added priors parameters. See ?sdmTMB::priors priors argument sdmTMB(). PC priors available random fields. See ?pc_matern details . Moved many less-common arguments sdmTMB() sdmTMBcontrol(). Fix bug sdmTMB_cv() fitting testing data splits reversed. .e., small chunk fit; big chunk tested.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00159000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.15.9000","title":"sdmTMB 0.0.15.9000","text":"Added experimental penalized complexity (PC) prior used INLA. See arguments matern_prior_O matern_prior_E. Added back normalize argument sdmTMB() default FALSE. Setting TRUE can dramatically speed model fits (~4 times test models).","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00149003","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.14.9003","title":"sdmTMB 0.0.14.9003","text":"Added vignette making pretty maps output","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00149001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.14.9001","title":"sdmTMB 0.0.14.9001","text":"AR1 spatial-model Missing factor levels time Coordinate systems big","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00149000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.14.9000","title":"sdmTMB 0.0.14.9000","text":"Add re_form_iid predict.sdmTMB(). Add map_rf option sdmTMB(). lets map (fix starting values zero) random fields produce classic GLM/GLMM.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00139000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.13.9000","title":"sdmTMB 0.0.13.9000","text":"Add IID random intercepts interface. E.g. ... + (1 | g) #34","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00129000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.12.9000","title":"sdmTMB 0.0.12.9000","text":"Add epsilon_predictor argument sdmTMB() allow model spatiotemporal variance time.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00119000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.11.9000","title":"sdmTMB 0.0.11.9000","text":"Add penalties argument allow regularization.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00109001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.10.9001","title":"sdmTMB 0.0.10.9001","text":"Fix Student-t degrees freedom randomized quantile residuals","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-00109000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.10.9000","title":"sdmTMB 0.0.10.9000","text":"Fixed parameter initialization inverse links #35 Switched Gamma ‘phi’ parameter representing shape instead CV match glm(), glmmTMB(), etc.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-0099000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.9.9000","title":"sdmTMB 0.0.9.9000","text":"Switched density/abundance index calculation use link function opposed hardcoded log() get_generic() function can used grab things like standardized average values response across grid. used log_total raw TMB output now link_total users shouldn’t notice difference.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-0089000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.8.9000","title":"sdmTMB 0.0.8.9000","text":"Overhauled simulation function. function now called sdmTMB_sim() uses INLA functions instead RandomFields functions simulating random fields. simulation function can now accommodate families links takes INLA mesh input.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-0079001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.7.9001","title":"sdmTMB 0.0.7.9001","text":"Allow specifying degrees freedom Student-t family #29","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-0079000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.7.9000","title":"sdmTMB 0.0.7.9000","text":"Added tidy() method (broom broom.mixed) return data frame parameter estimates. function can extract fixed effects random effect parameters (variances, AR1 correlation, spatial range). Added argument extra_time sdmTMB(). introduces additional time slices can predict want interpolate forecast. Internally, uses Eric Ward’s ‘weights hack’. also useful data unevenly spaced time want gaps evenly spaced random walk AR1 process (add missing years extra_time). make_spde() now replaced make_mesh() make_spde() soft deprecated. make_mesh() carries x y column names predict function line tidyverse style taking data frame first. make_mesh() can accept cutoff argument (INLA), likely better default way specify mesh since scales across regions better line literature INLA. make_mesh() can use binary search algorithm find cutoff best matches desired number knots (thanks Kelli Johnson idea). Barrier meshes now possible. See add_barrier_mesh() example. pkgdown website now gets auto generated GitHub actions. start model description vignette. much work progress.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-0069009","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.6.9009","title":"sdmTMB 0.0.6.9009","text":"Fixed bug dlnorm","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-0069005","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.6.9005","title":"sdmTMB 0.0.6.9005","text":"Fixed bug predictions standard errors one(?) parameter (breakpoint parameter) passed initial instead MLE value.","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-0069004","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.6.9004","title":"sdmTMB 0.0.6.9004","text":"Fixed bug predictions new data models break points Overhauled cross validation function. function now: uses Eric’s weights hack can also used forecasting initializes subsequent folds MLE first fold considerable speed increases works parallel future plan initialized; see examples Added threshold parameters print method Added forecasting example weights hack Fixed bug linear break point models","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-0069002","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.6.9002","title":"sdmTMB 0.0.6.9002","text":"Fixed GAM predictions 0s new data. Add linear logistic threshold models. #17","code":""},{"path":"https://sdmTMB.github.io/sdmTMB/news/index.html","id":"sdmtmb-0059000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.5.9000","title":"sdmTMB 0.0.5.9000","text":"Added parsing mgcv formulas splines. #16 Added ability predict standard errors population level. helps making marginal-effect plots. #15 Added optimization options aid convergence. Also added run_extra_optimization() run already fit models. Default extra optimization. Added binomial likelihood cross validation. Git hash ee3f3ba. Started keeping track news NEWS.md.","code":""}]
