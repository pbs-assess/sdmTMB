---
title: "Introduction to modelling with sdmTMB"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to modelling with sdmTMB}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

**If the code in this vignette has not been evaluated, a rendered version is available on the [documentation site](https://sdmTMB.github.io/sdmTMB/index.html) under 'Articles'.**

```{r setup, include = FALSE, cache=FALSE}
dplyr_installed <- require("dplyr", quietly = TRUE)
ggplot_installed <- require("ggplot2", quietly = TRUE)
sdmTMBextra_installed <- require("sdmTMBextra", quietly = TRUE)
pkgs <- dplyr_installed && ggplot_installed && sdmTMBextra_installed
EVAL <- identical(Sys.getenv("NOT_CRAN"), "true") && pkgs
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.asp = 0.618,
  eval = EVAL,
  purl = EVAL
)
```

```{r packages, message=FALSE, warning=TRUE}
library(ggplot2)
library(dplyr)
library(sdmTMB)
```

In this vignette, we describe the basic steps to fitting a spatial or spatiotemporal GLMM with sdmTMB. The goal is to show how to (i) build a mesh that captures spatial structure, (ii) fit increasingly rich models (GLM → spatial → spatiotemporal), (iii) interpret coefficients and random fields, and (iv) check predictions/uncertainty. These models are useful for (dynamic, i.e. changing through time) species distribution models and relative abundance index standardization among many other uses. See the [model description](https://sdmTMB.github.io/sdmTMB/articles/model-description.html) for full model structure and equations.

We will use built-in package data for Pacific Cod from a fisheries independent trawl survey (kg caught, swept area, and tow time).

- Density is in kg/km^2^ (biomass standardization using swept area and tow duration).
- X and Y are coordinates in UTM zone 9. We could add these to a new dataset with `sdmTMB::add_utm_columns()`.
- Depth was centered and scaled by its standard deviation so that coefficient sizes weren't too big or small.
- There are columns for depth (`depth_scaled`) and depth squared (`depth_scaled2`).

Before fitting, it helps to see the raw data we're fitting to:

```{r plot-pcod-raw, fig.asp=0.7}
ggplot(pcod, aes(X, Y, col = density)) +
  geom_point() +
  coord_fixed() +
  scale_colour_viridis_c(trans = "sqrt") +
  labs(colour = "Density", title = "Observed survey tows")
```

```{r glimpse-pcod}
glimpse(pcod)
```

The most basic model structure possible in sdmTMB replicates a GLM as can be fit with `glm()` or a GLMM as can be fit with lme4 or glmmTMB, for example.
The spatial components in sdmTMB are included as random fields using a triangulated ("finite element") mesh with vertices (knots) that approximate spatial variability.
A Gaussian Markov random field (GMRF) is a set of spatial random effects with a sparse precision matrix; the SPDE approach (Lindgren et al., 2011) links a Gaussian random field with Matérn covariance to this discrete GMRF.
Bilinear interpolation is used to approximate a continuous spatial field (Rue et al., 2009; Lindgren et al., 2011) from the estimated values of the spatial surface at these knot locations to other locations including those of actual observations.

There are different options for creating the spatial mesh (see `sdmTMB::make_mesh()`).
We will start with a relatively coarse mesh for a balance between speed and accuracy (`cutoff = 10`, where cutoff is in the units of X and Y (km here) and represents the minimum distance between knots before a new mesh vertex is added). 
Smaller values create meshes with more knots (finer spatial detail, slower fitting). 
Larger values create fewer knots (faster, but coarser). 
In applied scenarios, start coarse, then check whether a finer mesh changes conclusions.
The circles represent observations and the vertices are the knot locations.

```{r spde, fig.asp=0.8}
mesh <- make_mesh(pcod, c("X", "Y"), cutoff = 10)
plot(mesh)
```

We will start with a logistic regression of Pacific Cod encounter/non-encounter in tows as a function of depth and depth squared. We will first use `sdmTMB()` without any spatial random effects (`spatial = "off"`). This mirrors a standard GLM and serves as a baseline:

```{r basic-logistic}
m <- sdmTMB(
  data = pcod,
  formula = present ~ depth_scaled + depth_scaled2,
  family = binomial(link = "logit"),
  spatial = "off"
)
m
AIC(m)
```

For comparison, here's the same model with `glm()`:

```{r glm-logistic}
m0 <- glm(
  data = pcod,
  formula = present ~ depth_scaled + depth_scaled2,
  family = binomial(link = "logit")
)
summary(m0)
```

Notice that the AIC, log likelihood, parameter estimates, and standard errors are all identical. 
Interpreting these coefficients: a negative linear depth term with a positive quadratic suggests peak presence at intermediate depths; the logit link means these are log-odds changes per SD of depth.

Next, we can incorporate spatial random effects into the above model by changing `spatial` to `"on"` and adding our `mesh`.
These spatial random fields absorb spatial structure not explained by depth and typically reduce residual spatial autocorrelation. 
Expect coefficient estimates and their standard errors to shift once spatial structure is accounted for:

```{r spatial-logistic}
m1 <- sdmTMB(
  data = pcod,
  formula = present ~ depth_scaled + depth_scaled2,
  mesh = mesh,
  family = binomial(link = "logit"),
  spatial = "on"
)
m1
AIC(m1)
```

To add spatiotemporal random fields to this model, we need to include both the time argument that indicates what column of your data frame contains the time slices at which spatial random fields should be estimated (e.g., `time = "year"`) and we need to choose whether these fields are independent and identically distributed (`spatiotemporal = "IID"`), first-order autoregressive (`spatiotemporal = "AR1"`, each year correlated with the previous), or a random walk (`spatiotemporal = "RW"`, cumulative drift). We will stick with IID for these examples.

```{r spatiotemporal-logistic}
m2 <- sdmTMB(
  data = pcod,
  formula = present ~ depth_scaled + depth_scaled2,
  mesh = mesh,
  family = binomial(link = "logit"),
  spatial = "on",
  time = "year",
  spatiotemporal = "IID"
)
m2
```

We can also model biomass density using a Tweedie distribution (handles zero-inflated continuous biomass). 
We'll switch to `poly()` notation to make some of the plotting easier.

```{r tweedie}
m3 <- sdmTMB(
  data = pcod,
  formula = density ~ poly(log(depth), 2),
  mesh = mesh,
  family = tweedie(link = "log"),
  spatial = "on",
  time = "year",
  spatiotemporal = "IID"
)
m3
```

## Parameter estimates

We can view the confidence intervals on the fixed effects by using the tidy function.
For interpretation, think of a 1-unit increase in a standardized covariate as 1 SD in the original units; exponentiate log-linked effects to get multiplicative changes in biomass density:

```{r tweedie-fe}
tidy(m3, conf.int = TRUE)
```

And similarly for the random effect and variance parameters:

```{r tweedie-re}
tidy(m3, "ran_pars", conf.int = TRUE)
```

These parameters are defined as follows:

* `range`: A derived parameter that defines the distance at which 2 points are effectively independent (actually about 13% correlated). If the `share_range` argument is changed to `FALSE` then the spatial and spatiotemporal ranges will be unique, otherwise the default is for both to share the same range.

* `phi`: Observation error scale parameter (e.g., SD in Gaussian).

* `sigma_O`: SD of the spatial process ("Omega").

* `sigma_E`: SD of the spatiotemporal process ("Epsilon").

* `tweedie_p`: Tweedie p (power) parameter; between 1 and 2.

If the model used AR1 spatiotemporal fields then:

* `rho`: Spatiotemporal correlation between years; between -1 and 1.

## Model diagnostics

We can inspect randomized quantile residuals:

```{r residuals, fig.width = 8}
pcod$resids <- residuals(m3, type = "mle-mvn") # randomized quantile residuals
qqnorm(pcod$resids)
abline(0, 1)
ggplot(pcod, aes(X, Y, col = resids)) +
  scale_colour_gradient2() +
  geom_point() +
  facet_wrap(~year) +
  coord_fixed()
```

Look for straight QQ lines and no large spatial patches of residuals; strong spatial patterns suggest missing covariates or a too-coarse mesh.

We can also use simulation-based randomized quantile residuals.

```{r residuals, fig.width = 8}
set.seed(19283)
s <- simulate(m3, nsim = 300, type = "mle-mvn")
dharma_residuals(s, m3)
```

See `?residuals.sdmTMB()` and the [residuals vignette](https://sdmtmb.github.io/sdmTMB/articles/residual-checking.html).

## Spatial predictions

Now, for the purposes of this example (e.g., visualization), we want to predict on a fine-scale grid on the entire survey domain. 
There is a grid built into the package for Queen Charlotte Sound named `qcs_grid`. 
See [this discussion](https://github.com/sdmTMB/sdmTMB/discussions/151) thread if you're looking for some suggestions for how to form your own grid.
Our prediction grid also needs to have all the covariates that we used in the model above. 
We replicate the grid across years so that spatiotemporal fields can be projected to every time slice.

```{r glimpse-grid}
glimpse(qcs_grid)
```

We can replicate our grid across all necessary years:

```{r grid-replicate}
grid_yrs <- replicate_df(qcs_grid, "year", unique(pcod$year))
```

Now we will make the predictions on new data:

```{r predictions}
predictions <- predict(m3, newdata = grid_yrs)
```

Let's make a small function to help make maps.

```{r plot-map}
plot_map <- function(dat, column) {
  ggplot(dat, aes(X, Y, fill = {{ column }})) +
    geom_raster() +
    coord_fixed()
}
```

The `{{ }}` syntax is just a "[tidy-eval helper](https://ggplot2.tidyverse.org/reference/tidyeval.html)" that lets us supply the unquoted column name and pass it on to ggplot.

There are four kinds of predictions that we get out of the model. Use cases:
- `est`: fixed + spatial + spatiotemporal; use for maps and indices.
- `est_non_rf`: fixed effects only; use to understand covariate-driven signal.
- `omega_s`: spatial random effects; use to see persistent spatial deviations.
- `epsilon_st`: spatiotemporal random effects; use to see year-specific anomalies.

First, we will show the predictions that incorporate all fixed effects and random effects:

```{r plot-all-effects, fig.width = 8}
plot_map(predictions, exp(est)) +
  scale_fill_viridis_c(
    trans = "sqrt",
    # trim extreme high values to make spatial variation more visible:
    na.value = "yellow", limits = c(0, quantile(exp(predictions$est), 0.995))
  ) +
  facet_wrap(~year) +
  ggtitle("Prediction (fixed effects + all random effects)",
    subtitle = paste("maximum estimated biomass density =", round(max(exp(predictions$est))))
  )
```

We can also look at just the fixed effects, here only a quadratic effect of depth:

```{r plot-fix-defects, fig.width = 6}
plot_map(predictions, exp(est_non_rf)) +
  scale_fill_viridis_c(trans = "sqrt") +
  ggtitle("Prediction (fixed effects only)")
```

We can look at the spatial random effects that represent consistent deviations in space through time that are not accounted for by our fixed effects.
In other words, these deviations represent consistent spatially structured biotic and abiotic factors that are affecting biomass density but are not accounted for in the model.

```{r plot-spatial-effects, fig.width = 6}
plot_map(predictions, omega_s) +
  scale_fill_gradient2() +
  ggtitle("Spatial random effects only")
```

And finally we can look at the spatiotemporal random effects that represent deviation from the fixed effect predictions and the spatial random effect deviations.
These represent spatially structured biotic and abiotic factors that are changing through time and are not accounted for in the model.

```{r plot-spatiotemporal-effects, fig.width = 8}
plot_map(predictions, epsilon_st) +
  scale_fill_gradient2() +
  facet_wrap(~year) +
  ggtitle("Spatiotemporal random effects only")
```

We can also estimate the uncertainty in our spatiotemporal density predictions using simulations from the joint precision matrix by setting `nsim > 0` in the predict function.
Here we generate 100 estimates and use `apply()` to calculate upper and lower confidence intervals, a standard deviation, and a coefficient of variation (CV).

```{r sim-cv}
sim <- predict(m3, newdata = grid_yrs, nsim = 100)
sim_last <- sim[grid_yrs$year == max(grid_yrs$year), ] # just plot last year
pred_last <- predictions[predictions$year == max(grid_yrs$year), ]
pred_last$lwr <- apply(exp(sim_last), 1, quantile, probs = 0.025)
pred_last$upr <- apply(exp(sim_last), 1, quantile, probs = 0.975)
pred_last$sd <- round(apply(exp(sim_last), 1, function(x) sd(x)), 2)
pred_last$cv <- round(apply(exp(sim_last), 1, function(x) sd(x) / mean(x)), 2)
```

Plot the CV on the estimates:

```{r plot-cv, fig.width = 6}
ggplot(pred_last, aes(X, Y, fill = cv)) +
  geom_raster() +
  scale_fill_viridis_c()
```

## Conditional effects

We can visualize the conditional effect of any covariates by feeding simplified data frames to the predict function that fix covariate values we want fixed (e.g., at means) and vary parameters we want to visualize (across a range of values):

```{r depth-eff, fig.width = 6}
nd <- data.frame(
  depth = seq(min(pcod$depth),
    max(pcod$depth),
    length.out = 100
  ),
  year = 2015L # a chosen year
)
p <- predict(m3, newdata = nd, se_fit = TRUE, re_form = NA)

ggplot(p, aes(depth, exp(est),
  ymin = exp(est - 1.96 * est_se),
  ymax = exp(est + 1.96 * est_se)
)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  scale_x_continuous() +
  coord_cartesian(expand = F) +
  labs(x = "Depth (m)", y = "Biomass density (kg/km2)")
```

We could also do this with the visreg package. This version is in link space and the residuals are partial randomized quantile residuals. See the `scale` argument in visreg for response scale plots.

```{r visreg}
visreg::visreg(m3, "depth")
```

Or the ggeffects package for a marginal effects plot. This will also be faster since it relies on the already estimated coefficients and variance-covariance matrix.

```{r ggeffects}
ggeffects::ggeffect(m3, "depth [0:500 by=1]") |> plot()
```

### Time-varying effects

We could also let the effect of depth vary through time.
We set up the time-varying coefficients to follow an AR1 process by setting `time_varying_type = "ar1"` (each year's coefficient is correlated with the previous year's). With `"ar1"` or `"rw0"`, the fixed effects represent the starting point of the time series and the time-varying process represents deviations from this over time.
If, instead, we had used `time_varying_type = "rw"`, the first time step of the random effect process would represent the initial year values and we would want to omit the matching effects in the main formula. For example:

```r
formula = density ~ 0,
time_varying = ~ 1 + depth_scaled + depth_scaled2,
time_varying_type = "rw"
```

We include a full length of time increments with `extra_time` to ensure we estimate time-varying coefficient values for each year, including any years that are missing from our data.
For this example, we turn off the spatiotemporal random effects because we were having convergence issues with them turned on.

```{r tv-effect}
m4 <- sdmTMB(
  density ~ 1 + depth_scaled + depth_scaled2,
  data = pcod,
  time_varying = ~ 1 + depth_scaled + depth_scaled2,
  time_varying_type = "ar1",
  extra_time = seq(min(pcod$year), max(pcod$year)),
  mesh = mesh,
  family = tweedie(link = "log"),
  spatial = "on",
  time = "year",
  spatiotemporal = "off"
)
m4
```

To plot these, we make a data frame that contains all combinations of the time-varying covariate and time.
This is easily created using `expand.grid()` or `tidyr::expand_grid()`.

```{r tv-depth-eff, fig.width = 6}
nd <- expand.grid(
  depth_scaled = seq(min(pcod$depth_scaled) + 0.2,
    max(pcod$depth_scaled) - 0.2,
    length.out = 50
  ),
  year = unique(pcod$year) # all years
)
nd$depth_scaled2 <- nd$depth_scaled^2

p <- predict(m4, newdata = nd, se_fit = TRUE, re_form = NA)

ggplot(p, aes(depth_scaled, exp(est),
  ymin = exp(est - 1.96 * est_se),
  ymax = exp(est + 1.96 * est_se),
  group = as.factor(year)
)) +
  geom_line(aes(colour = year), lwd = 1) +
  geom_ribbon(aes(fill = year), alpha = 0.1) +
  scale_colour_viridis_c() +
  scale_fill_viridis_c() +
  scale_x_continuous(labels = function(x) round(exp(x * pcod$depth_sd[1] + pcod$depth_mean[1]))) +
  coord_cartesian(expand = F) +
  labs(x = "Depth (m)", y = "Biomass density (kg/km2)")
```

