% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.R
\name{predict.sdmTMB}
\alias{predict.sdmTMB}
\title{Predict from an sdmTMB model}
\usage{
\method{predict}{sdmTMB}(
  object,
  newdata = NULL,
  se_fit = FALSE,
  xy_cols = c("X", "Y"),
  return_tmb_object = FALSE,
  area = 1,
  ...
)
}
\arguments{
\item{object}{An object from \code{\link[=sdmTMB]{sdmTMB()}}.}

\item{newdata}{An optional new data frame. This should be a data frame with
the same predictor columns as in the fitted data and a time column (if this
is a spatiotemporal model) with the same name as in the fitted data. There
should be predictor data for each year in the original data set.}

\item{se_fit}{Should standard errors on predictions at the new locations given by
\code{newdata} be calculated? Warning: the current implementation can be slow for
large data sets or high-resolution projections.}

\item{xy_cols}{A character vector of length 2 that gives the column names of
the x and y coordinates in \code{newdata}.}

\item{return_tmb_object}{Logical. If \code{TRUE}, will include the TMB object in
a list format output. Necessary for the \code{\link[=get_index]{get_index()}} or \code{\link[=get_cog]{get_cog()}} functions.}

\item{area}{A vector of areas for survey grid cells. Only necessary if the
output will be passed to \code{\link[=get_index]{get_index()}} or \code{\link[=get_cog]{get_cog()}}. Should be the same length
as the number of rows of \code{newdata}. Defaults to a sequence of 1s.}

\item{...}{Not implemented.}
}
\value{
If \code{return_tmb_object = FALSE}:
A data frame:
\itemize{
\item \code{est}: Estimate in link space (everything is in link space)
\item \code{est_non_rf}: Estimate from everything that isn't a random field
\item \code{est_rf}: Estimate from all random fields combined
\item \code{omega_s}: Spatial (intercept) random field that is constant through time
\item \code{zeta_s}: Spatial slope random field
\item \code{epsilon_st}: Spatiotemporal (intercept) random fields (could be
independent draws each year or AR1)
}

If \code{return_tmb_object = TRUE}:
A list:
\itemize{
\item \code{data}: The data frame described above
\item \code{report}: The TMB report on parameter values
\item \code{obj}: The TMB object returned from the prediction run.
\item \code{fit_obj}: The original TMB model object.
}

You likely only need the \code{data} element as an end user. The other elements
are included for other functions.
}
\description{
Can predict on the original data locations or on new data.
}
\examples{
# We'll only use a small number of knots so this example runs quickly
# but you will likely want to use many more in applied situations.

library(ggplot2)
d <- pcod

pcod_spde <- make_spde(d$X, d$Y, n_knots = 50) # just 50 for example speed
m <- sdmTMB(
 data = d, formula = density ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,
 time = "year", spde = pcod_spde, family = tweedie(link = "log")
)

# Predictions at original data locations:
predictions <- predict(m)
head(predictions)

predictions$resids <- residuals(m) # randomized quantile residuals
ggplot(predictions, aes(X, Y, col = resids)) + scale_colour_gradient2() +
  geom_point() + facet_wrap(~year)
hist(predictions$resids)
qqnorm(predictions$resids);abline(a = 0, b = 1)

# Predictions onto new data:
predictions <- predict(m, newdata = qcs_grid)

# A short function for plotting our predictions:
plot_map <- function(dat, column = "est") {
  ggplot(dat, aes_string("X", "Y", fill = column)) +
    geom_raster() +
    facet_wrap(~year) +
    coord_fixed()
}

plot_map(predictions, "exp(est)") +
  scale_fill_viridis_c(trans = "sqrt") +
  ggtitle("Prediction (fixed effects + all random effects)")

plot_map(predictions, "exp(est_non_rf)") +
  ggtitle("Prediction (fixed effects and any time-varying effects)") +
  scale_fill_viridis_c(trans = "sqrt")

plot_map(predictions, "est_rf") +
  ggtitle("All random field estimates") +
  scale_fill_viridis_c(trans = "sqrt")

plot_map(predictions, "omega_s") +
  ggtitle("Spatial random effects only") +
  scale_fill_gradient2()

plot_map(predictions, "epsilon_st") +
  ggtitle("Spatiotemporal random effects only") +
  scale_fill_gradient2()

\donttest{
# Spatial trend example:
pcod_spde <- make_spde(d$X, d$Y, n_knots = 100)
m <- sdmTMB(data = pcod, formula = density ~ depth_scaled + depth_scaled2,
  spde = pcod_spde, family = tweedie(link = "log"),
  spatial_trend = TRUE, time = "year", spatial_only = TRUE)
p <- predict(m, newdata = qcs_grid)

plot_map(p, "zeta_s") +
  ggtitle("Spatial slopes") +
  scale_fill_gradient2()

plot_map(p, "est_rf") +
  ggtitle("Random field estimates") +
  scale_fill_gradient2()

plot_map(p, "exp(est_non_rf)") +
  ggtitle("Prediction (fixed effects only)") +
  scale_fill_viridis_c(trans = "sqrt")

plot_map(p, "exp(est)") +
  ggtitle("Prediction (fixed effects + all random effects)") +
  scale_fill_viridis_c(trans = "sqrt")

# Example with standard errors on new location predictions.
# Note this example models presence/absence.
pcod_2017 <- d[d$year == 2017, ]
pcod_spde <- make_spde(pcod_2017$X, pcod_2017$Y, n_knots = 75)
m2017 <- sdmTMB(
  pcod_2017, present ~ 0 + depth_scaled + depth_scaled2,
  time = "year", spde = pcod_spde, family = binomial(link = "logit"),
  silent = FALSE
)

# Predictions at new data locations with standard errors.
# Note that this can currently be quite slow on large data sets.
predictions <- predict(m2017, newdata = qcs_grid, se_fit = TRUE)

plot_map(predictions, "stats::plogis(est)") +
  scale_fill_gradient2(midpoint = 0.5) +
  ggtitle("Predictions")

plot_map(predictions, "est_se") +
  scale_fill_viridis_c() +
  ggtitle("Prediction standard error")

plot_map(predictions, "stats::plogis(est + 2 * est_se)") +
  scale_fill_gradient2(midpoint = 0.5) +
  ggtitle("Prediction upper 95% CI")

plot_map(predictions, "stats::plogis(est - 2 * est_se)") +
  scale_fill_gradient2(midpoint = 0.5) +
  ggtitle("Prediction lower 95% CI")
}
}
