% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.R
\name{predict.sdmTMB}
\alias{predict.sdmTMB}
\title{Predict from an sdmTMB model}
\usage{
\method{predict}{sdmTMB}(
  object,
  newdata = object$data,
  se_fit = FALSE,
  return_tmb_object = FALSE,
  area = 1,
  re_form = NULL,
  re_form_iid = NULL,
  nsim = 0,
  sims = deprecated(),
  sims_var = "est",
  tmbstan_model = NULL,
  ...
)
}
\arguments{
\item{object}{An object from \code{\link[=sdmTMB]{sdmTMB()}}.}

\item{newdata}{A data frame to make predictions on. This should be a data
frame with the same predictor columns as in the fitted data and a time
column (if this is a spatiotemporal model) with the same name as in the
fitted data. There should be predictor data for each year in the original
data set.}

\item{se_fit}{Should standard errors on predictions at the new locations
given by \code{newdata} be calculated? Warning: the current implementation can
be very slow for large data sets or high-resolution projections. A \emph{much}
faster option is to use the \code{nsim} argument below and calculate uncertainty
on the simulations from the joint precision matrix.}

\item{return_tmb_object}{Logical. If \code{TRUE}, will include the TMB object in a
list format output. Necessary for the \code{\link[=get_index]{get_index()}} or \code{\link[=get_cog]{get_cog()}}
functions.}

\item{area}{A vector of areas for survey grid cells. Only necessary if the
output will be passed to \code{\link[=get_index]{get_index()}} or \code{\link[=get_cog]{get_cog()}} and not all grid
cells are of area 1. Should be the same length as the number of rows of
\code{newdata}. If length 1, will be repeated to match the rows of data.}

\item{re_form}{\code{NULL} to specify including all spatial/spatiotemporal random
effects in predictions. \code{~0} or \code{NA} for population-level predictions. Note
that unlike lme4 or glmmTMB, this only affects what the standard errors are
calculated on if \code{se_fit = TRUE}. This does not affect \code{\link[=get_index]{get_index()}}
calculations.}

\item{re_form_iid}{\code{NULL} to specify including all random intercepts in the
predictions. \code{~0} or \code{NA} for population-level predictions. No other
options (e.g., some but not all random intercepts) are implemented yet.
Only affects predictions with \code{newdata}. This also affects \code{\link[=get_index]{get_index()}}.}

\item{nsim}{\strong{Experimental.} If > 0, simulate from the joint precision matrix with \code{sims}
draws Returns a matrix of \code{nrow(data)} by \code{sim} representing the estimates
of the linear predictor (i.e., in link space). Can be useful for deriving
uncertainty on predictions (e.g., \code{apply(x, 1, sd)}) or propagating
uncertainty. This is currently the fastest way to generate estimates of
uncertainty on predictions in space with sdmTMB.}

\item{sims}{\strong{Deprecated}. Please use \code{nsim} instead.}

\item{sims_var}{\strong{Experimental.} Which TMB reported variable from the model
should be extracted from the joint precision matrix simulation draws?
Defaults to the link-space predictions. Options include: \code{"omega_s"},
\code{"zeta_s"}, \code{"epsilon_st"}, and \code{"est_rf"} (as described below).
Other options will be passed verbatim.}

\item{tmbstan_model}{A model fit with \code{\link[tmbstan:tmbstan]{tmbstan::tmbstan()}}. See
\code{\link[=extract_mcmc]{extract_mcmc()}} for more details and an example. If specified, the
predict function will return a matrix of a similar form as if \code{nsim > 0}
but representing Bayesian posterior samples from the Stan model.}

\item{...}{Not implemented.}
}
\value{
If \code{return_tmb_object = FALSE} (and \code{nsim = 0} and \code{tmbstan_model = NULL}):

A data frame:
\itemize{
\item \code{est}: Estimate in link space (everything is in link space)
\item \code{est_non_rf}: Estimate from everything that isn't a random field
\item \code{est_rf}: Estimate from all random fields combined
\item \code{omega_s}: Spatial (intercept) random field that is constant through time
\item \code{zeta_s}: Spatial slope random field
\item \code{epsilon_st}: Spatiotemporal (intercept) random fields, could be
off (zero), IID, AR1, or random walk
}

If \code{return_tmb_object = TRUE} (and \code{nsim = 0} and \code{tmbstan_model = NULL}):

A list:
\itemize{
\item \code{data}: The data frame described above
\item \code{report}: The TMB report on parameter values
\item \code{obj}: The TMB object returned from the prediction run
\item \code{fit_obj}: The original TMB model object
}

In this case, you likely only need the \code{data} element as an end user.
The other elements are included for other functions.

If \code{nsim > 0} or \code{tmbstan_model} is not \code{NULL}:

A matrix:
\itemize{
\item Columns represent samples
\item Rows represent predictions with one row per row of \code{newdata}
}
}
\description{
Make predictions from an sdmTMB model; can predict on the original or new
data.
}
\examples{
if (require("ggplot2", quietly = TRUE) && inla_installed()) {

d <- pcod_2011
mesh <- make_mesh(d, c("X", "Y"), cutoff = 30) # a coarse mesh for example speed
m <- sdmTMB(
 data = d, formula = density ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,
 time = "year", mesh = mesh, family = tweedie(link = "log")
)

# Predictions at original data locations -------------------------------

predictions <- predict(m)
head(predictions)

predictions$resids <- residuals(m, type = "randomized-quantile")

ggplot(predictions, aes(X, Y, col = resids)) + scale_colour_gradient2() +
  geom_point() + facet_wrap(~year)
hist(predictions$resids)
qqnorm(predictions$resids);abline(a = 0, b = 1)

# Predictions onto new data --------------------------------------------

qcs_grid_2011 <- subset(qcs_grid, year >= min(pcod_2011$year))
predictions <- predict(m, newdata = qcs_grid_2011)

# A short function for plotting our predictions:
plot_map <- function(dat, column = "est") {
  ggplot(dat, aes_string("X", "Y", fill = column)) +
    geom_raster() +
    facet_wrap(~year) +
    coord_fixed()
}

plot_map(predictions, "exp(est)") +
  scale_fill_viridis_c(trans = "sqrt") +
  ggtitle("Prediction (fixed effects + all random effects)")

plot_map(predictions, "exp(est_non_rf)") +
  ggtitle("Prediction (fixed effects and any time-varying effects)") +
  scale_fill_viridis_c(trans = "sqrt")

plot_map(predictions, "est_rf") +
  ggtitle("All random field estimates") +
  scale_fill_gradient2()

plot_map(predictions, "omega_s") +
  ggtitle("Spatial random effects only") +
  scale_fill_gradient2()

plot_map(predictions, "epsilon_st") +
  ggtitle("Spatiotemporal random effects only") +
  scale_fill_gradient2()

# Visualizing a marginal effect ----------------------------------------

nd <- data.frame(depth_scaled =
  seq(min(d$depth_scaled), max(d$depth_scaled), length.out = 100))
nd$depth_scaled2 <- nd$depth_scaled^2

# Because this is a spatiotemporal model, you'll need at least one time
# element. If time isn't also a fixed effect then it doesn't matter what you pick:
nd$year <- 2011L # L: integer to match original data
p <- predict(m, newdata = nd, se_fit = TRUE, re_form = NA)
ggplot(p, aes(depth_scaled, exp(est),
  ymin = exp(est - 1.96 * est_se), ymax = exp(est + 1.96 * est_se))) +
  geom_line() + geom_ribbon(alpha = 0.4)

# Plotting marginal effect of a spline ---------------------------------

m_gam <- sdmTMB(
 data = d, formula = density ~ 0 + as.factor(year) + s(depth_scaled, k = 5),
 time = "year", mesh = mesh, family = tweedie(link = "log")
)
plot_smooth(m_gam)

# or manually:
nd <- data.frame(depth_scaled =
  seq(min(d$depth_scaled), max(d$depth_scaled), length.out = 100))
nd$year <- 2011L
p <- predict(m_gam, newdata = nd, se_fit = TRUE, re_form = NA)
ggplot(p, aes(depth_scaled, exp(est),
  ymin = exp(est - 1.96 * est_se), ymax = exp(est + 1.96 * est_se))) +
  geom_line() + geom_ribbon(alpha = 0.4)

# Forecasting ----------------------------------------------------------
mesh <- make_mesh(d, c("X", "Y"), cutoff = 15)

unique(d$year)
m <- sdmTMB(
  data = d, formula = density ~ 1,
  spatiotemporal = "AR1", # using an AR1 to have something to forecast with
  extra_time = 2019L, # `L` for integer to match our data
  spatial = "off",
  time = "year", mesh = mesh, family = tweedie(link = "log")
)

# Add a year to our grid:
grid2019 <- qcs_grid_2011[qcs_grid_2011$year == max(qcs_grid_2011$year), ]
grid2019$year <- 2019L # `L` because `year` is an integer in the data
qcsgrid_forecast <- rbind(qcs_grid_2011, grid2019)

predictions <- predict(m, newdata = qcsgrid_forecast)
plot_map(predictions, "exp(est)") +
  scale_fill_viridis_c(trans = "log10")
plot_map(predictions, "epsilon_st") +
  scale_fill_gradient2()

# Estimating local trends ----------------------------------------------

d <- pcod
d$year_scaled <- as.numeric(scale(d$year))
mesh <- make_mesh(pcod, c("X", "Y"), cutoff = 25)
m <- sdmTMB(data = d, formula = density ~ depth_scaled + depth_scaled2,
  mesh = mesh, family = tweedie(link = "log"),
  spatial_varying = ~ 0 + year_scaled, time = "year", spatiotemporal = "off")
nd <- qcs_grid
nd$year_scaled <- (nd$year - mean(d$year)) / sd(d$year)
p <- predict(m, newdata = nd)

plot_map(p, "zeta_s") +
  ggtitle("Spatial slopes") +
  scale_fill_gradient2()

plot_map(p, "est_rf") +
  ggtitle("Random field estimates") +
  scale_fill_gradient2()

plot_map(p, "exp(est_non_rf)") +
  ggtitle("Prediction (fixed effects only)") +
  scale_fill_viridis_c(trans = "sqrt")

plot_map(p, "exp(est)") +
  ggtitle("Prediction (fixed effects + all random effects)") +
  scale_fill_viridis_c(trans = "sqrt")
}
}
