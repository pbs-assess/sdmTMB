% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit.R
\name{sdmTMB}
\alias{sdmTMB}
\title{Fit a spatial or spatiotemporal GLMM with TMB}
\usage{
sdmTMB(
  formula,
  data,
  spde,
  time = NULL,
  family = gaussian(link = "identity"),
  time_varying = NULL,
  weights = NULL,
  extra_time = NULL,
  reml = FALSE,
  silent = TRUE,
  multiphase = TRUE,
  anisotropy = FALSE,
  control = sdmTMBcontrol(),
  enable_priors = FALSE,
  ar1_fields = FALSE,
  include_spatial = TRUE,
  spatial_trend = FALSE,
  spatial_only = identical(length(unique(data[[time]])), 1L),
  nlminb_loops = 1,
  newton_steps = 0,
  mgcv = TRUE,
  previous_fit = NULL,
  quadratic_roots = FALSE,
  epsilon_model = NULL
)
}
\arguments{
\item{formula}{Model formula. See the Details section below for how to specify
offsets and threshold parameters. For index standardization, include \code{0 + as.factor(year)} (or whatever the time column is called) in the formula.}

\item{data}{A data frame.}

\item{spde}{An object from \code{\link[=make_mesh]{make_mesh()}}.}

\item{time}{The time column (as character). Leave as \code{NULL} for a spatial-only
model.}

\item{family}{The family and link. Supports \code{\link[=gaussian]{gaussian()}}, \code{\link[=Gamma]{Gamma()}},
\code{\link[=binomial]{binomial()}}, \code{\link[=poisson]{poisson()}}, \code{\link[sdmTMB:families]{Beta()}},
\code{\link[sdmTMB:families]{nbinom2()}}, and
\code{\link[sdmTMB:families]{tweedie()}}].}

\item{time_varying}{An optional formula describing covariates that should be
modelled as a random walk through time.}

\item{weights}{Optional likelihood weights for the conditional model.
Implemented as in \pkg{glmmTMB}. In other words, weights do not have to sum
to one and are not internally modified.}

\item{extra_time}{Optional extra time slices (e.g., years) to include for
interpolation or forecasting with the predict function. See details section.}

\item{reml}{Logical: use REML estimation rather than maximum likelihood?}

\item{silent}{Silent or include optimization details?}

\item{multiphase}{Logical: estimate the fixed and random effects in phases?
Phases are usually faster and more stable.}

\item{anisotropy}{Logical: allow for anisotropy? See \code{\link[=plot_anisotropy]{plot_anisotropy()}}.}

\item{control}{Optimization control options. See \code{\link[=sdmTMBcontrol]{sdmTMBcontrol()}}.}

\item{enable_priors}{Should weakly informative priors be enabled?
Experimental and likely for use with the \pkg{tmbstan} package. Note that
the priors are not yet sensible and Jacobian adjustments are not made. If you
are interested in this functionality, please contact the developers.}

\item{ar1_fields}{Estimate the spatiotemporal random fields as an AR1
process? Note that the parameter \code{ar1_phi} has been internally bounded
between \code{-1} and \code{1} with:  \code{2 * invlogit(ar1_phi) - 1} i.e. in R \code{2 * plogis(ar_phi) - 1}.}

\item{include_spatial}{Should a separate spatial random field be estimated?
If enabled then there will be separate spatial and spatiotemporal
fields.}

\item{spatial_trend}{Should a separate spatial field be included in the
trend? Requires spatiotemporal data.}

\item{spatial_only}{Logical: should only a spatial model be fit (i.e. do not
include spatiotemporal random effects)? By default a spatial-only model
will be fit if there is only one unique value in the time column or the
\code{time} argument is left at its default value of \code{NULL}.}

\item{nlminb_loops}{How many times to run \code{\link[stats:nlminb]{stats::nlminb()}} optimization.
Sometimes restarting the optimizer at the previous best values aids
convergence. If the maximum gradient is still too large,
try increasing this to \code{2}.}

\item{newton_steps}{How many Newton optimization steps to try with
\code{\link[stats:optim]{stats::optimHess()}} after running \code{\link[stats:nlminb]{stats::nlminb()}}. Sometimes aids
convergence.}

\item{mgcv}{Parse the formula with \code{\link[mgcv:gam]{mgcv::gam()}}?}

\item{previous_fit}{A previously fitted sdmTMB model to initialize the
optimization with. Can greatly speed up fitting. Note that the data and
model must be set up exactly the same way! However, the \code{weights} argument
can change, which can be useful for cross-validation.}

\item{quadratic_roots}{Experimental feature for internal use right now; may
be moved to a branch. Logical: should quadratic roots be calculated? Note:
on the sdmTMB side, the first two coefficients are used to generate the
quadratic parameters. This means that if you want to generate a quadratic
profile for depth, and depth and depth^2 are part of your formula, you need
to make sure these are listed first and that an intercept isn't included.
For example, \code{formula = cpue ~ 0 + depth + depth2 + as.factor(year)}.}

\item{epsilon_model}{Whether to include an optional non-stationary model for
epsilon (sd of spatiotemporal process). Defaults to NULL, but can also be
'loglinear'}
}
\description{
Fit a spatial or spatiotemporal GLMM with TMB. Particularly useful for
species distribution models and relative abundance index standardization.
}
\details{
\strong{Offsets}

In the model formula, an offset can be included by including \code{+ offset} in
the model formula (a reserved word). The offset will be included in any
prediction. \code{offset} must be a column in \code{data}.

\strong{Threshold models}

A linear break-point relationship for a covariate can be included via \code{+ breakpt(variable)} in the formula, where \code{variable} is a single covariate
corresponding to a column in \code{data}. In this case the relationship is linear
up to a point and then constant.

Similarly, a logistic-function threshold model can be included via \code{+ logistic(variable)}. This option models the relationship as a logistic
function of the 50\% and 95\% values. This is similar to length- or size-based
selectivity in fisheries, and is parameterized by the points at which f(x) =
0.5 or 0.95. See the vignette.

Note that only a single threshold covariate can be included.

\strong{Forecasting or interpolating}

Extra time slices (e.g., years) can be included for interpolation or
forecasting with the predict function via the \code{extra_time} argument. The
predict function requires all time slices to be defined when fitting the
model to ensure the various time indices are set up correctly. Be careful if
including extra time slices that the model remains identifiable. For example,
including \code{+ as.factor(year)} in \code{formula} will render a model with no data
to inform the expected value in the missing year. \code{\link[=sdmTMB]{sdmTMB()}} makes no attempt
to determine if the model makes sense for forecasting or interpolation. The
options \code{time_varying}, \code{include_spatial}, \code{ar1_fields}, \code{time = NULL}
provide mechanisms to predict over missing time slices.
}
\examples{
d <- subset(pcod, year >= 2011) # subset for example speed
pcod_spde <- make_mesh(d, c("X", "Y"), cutoff = 30) # a coarse mesh for example speed
plot(pcod_spde)

# Tweedie:
m <- sdmTMB(density ~ 0 + depth_scaled + depth_scaled2 + as.factor(year),
  data = d, time = "year", spde = pcod_spde, family = tweedie(link = "log"))
print(m)
tidy(m, conf.int = TRUE)
tidy(m, effects = "ran_par")

# Run extra optimization steps to help convergence:
m1 <- run_extra_optimization(m, nlminb_loops = 0, newton_steps = 1)
max(m$gradients)
max(m1$gradients)

# Binomial:
pcod_binom <- d
pcod_binom$present <- ifelse(pcod_binom$density > 0, 1L, 0L)
m_bin <- sdmTMB(present ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,
  data = pcod_binom, time = "year", spde = pcod_spde,
  family = binomial(link = "logit"))
print(m_bin)

# Gaussian:
pcod_gaus <- subset(d, density > 0 & year >= 2013)
pcod_spde_gaus <- make_mesh(pcod_gaus, c("X", "Y"), cutoff = 30)
m_pos <- sdmTMB(log(density) ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,
  data = pcod_gaus, time = "year", spde = pcod_spde_gaus)
print(m_pos)

# With splines via mgcv.
# Make sure to pre-specify an appropriate basis dimension (`k`) since
# the smoothers are not penalized in the current implementation.
# See ?mgcv::choose.k
m_gam <- sdmTMB(log(density) ~ 0 + as.factor(year) + s(depth_scaled, k = 4),
  data = pcod_gaus, time = "year", spde = pcod_spde_gaus)
print(m_gam)

\donttest{
# Fit a spatial only model:
m <- sdmTMB(
  density ~ depth_scaled + depth_scaled2, data = d,
  spde = pcod_spde, family = tweedie(link = "log"))
print(m)

# Spatial-trend example:
m <- sdmTMB(density ~ depth_scaled, data = d,
  spde = pcod_spde, family = tweedie(link = "log"),
  spatial_trend = TRUE, time = "year")
tidy(m, effects = "ran_par")

# Time-varying effects of depth and depth squared:
m <- sdmTMB(density ~ 0 + as.factor(year),
  time_varying = ~ 0 + depth_scaled + depth_scaled2,
  data = d, time = "year", spde = pcod_spde, family = tweedie(link = "log"))
print(m)

# See the b_rw_t estimates; these are the time-varying (random walk) effects.
# These could be added to tidy.sdmTMB() eventually.
summary(m$sd_report)[1:19,]

# Linear breakpoint model on depth:
m_pos <- sdmTMB(log(density) ~ 0 + as.factor(year) +
    breakpt(depth_scaled) + depth_scaled2, data = pcod_gaus,
  time = "year", spde = pcod_spde_gaus)
print(m_pos)

#' Non-stationary model on spatiotemporal variance:
m_pos <- sdmTMB(log(density) ~ depth_scaled + depth_scaled2 + as.factor(year),
   data = pcod_gaus, time = "year", spde = pcod_spde_gaus, epsilon_model="loglinear")
print(m_pos)
}
}
